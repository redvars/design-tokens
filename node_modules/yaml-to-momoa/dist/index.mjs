import { YAMLMap, YAMLSeq, Scalar, Alias, parseDocument, LineCounter } from 'yaml';

function transform(node, { doc, transformRange }) {
  const nullNode = {
    type: "Null",
    loc: transformRange(node?.range)
  };
  if (node instanceof YAMLMap) {
    return transformYAMLMap(node, { doc, transformRange });
  }
  if (node instanceof YAMLSeq) {
    return transformYAMLSeq(node, { doc, transformRange });
  }
  if (node instanceof Scalar) {
    return transformScalar(node, { transformRange });
  }
  if (node instanceof Alias) {
    const resolved = node.resolve(doc);
    if (resolved) {
      const cloned = resolved.clone();
      cloned.range = node.range ?? cloned.range;
      return transform(cloned, { doc, transformRange });
    }
    return nullNode;
  }
  return nullNode;
}
function transformYAMLMap(node, { doc, transformRange }) {
  return {
    type: "Object",
    members: node.items.map((item) => ({
      type: "Member",
      name: transform(item.key, { doc, transformRange }),
      value: transform(item.value, { doc, transformRange }),
      loc: transformRange([item.key.range?.[0] ?? -1, item.value?.range?.[1] ?? -1, item.value?.range?.[2] ?? -1])
      // note: the YAML parser doesnâ€™t keep a range on the item itself; use its children instead
    })),
    loc: transformRange(node.range)
  };
}
function transformYAMLSeq(node, { doc, transformRange }) {
  return {
    type: "Array",
    elements: node.items.map((item) => ({
      type: "Element",
      value: transform(item, { doc, transformRange }),
      loc: transformRange(item.range)
    })),
    loc: transformRange(node.range)
  };
}
function transformScalar(node, { transformRange }) {
  switch (typeof node.value) {
    case "string": {
      return {
        type: "String",
        value: node.value,
        loc: transformRange(node.range)
      };
    }
    case "boolean": {
      return {
        type: "Boolean",
        value: node.value,
        loc: transformRange(node.range)
      };
    }
    case "number": {
      return {
        type: "Number",
        value: node.value,
        loc: transformRange(node.range)
      };
    }
  }
  if (node.value === null) {
    return {
      type: "Null",
      loc: transformRange(node.range)
    };
  }
  throw new Error(`Unexpected scalar value: ${node.value}`);
}

function yamlToMomoa(yaml, parseOptions) {
  const doc = parseDocument(yaml, {
    lineCounter: new LineCounter(),
    keepSourceTokens: true,
    ...parseOptions
  });
  if (doc.errors?.length) {
    for (const error of doc.errors) {
      throw error;
    }
  }
  if (!doc.contents) {
    throw new Error("YAML content null");
  }
  const locMap = /* @__PURE__ */ new Map();
  let line = 1;
  let column = 0;
  for (let i = 0; i <= yaml.length; i++) {
    if (yaml[i] === "\n") {
      line++;
      column = 1;
    } else {
      column++;
    }
    locMap.set(i, { line, column });
  }
  function transformRange(range) {
    let [startOffset, endOffset] = range ?? [-1, 0];
    endOffset--;
    const start = locMap.get(startOffset) ?? { line: -1, column: -1 };
    const end = locMap.get(endOffset) ?? { line: -1, column: -1 };
    return { start: { ...start, offset: startOffset }, end: { ...end, offset: endOffset } };
  }
  const body = transform(doc.contents, {
    doc,
    transformRange
  });
  const docEnd = locMap.get(yaml.length - 1) ?? { line: -1, column: -1 };
  return {
    type: "Document",
    body,
    loc: { start: { line: 1, column: 1, offset: 0 }, end: { ...docEnd, offset: yaml.length - 1 } }
  };
}

export { yamlToMomoa as default };
//# sourceMappingURL=index.mjs.map
