{"version":3,"file":"index.js","names":["value: string","tokenId: string","globPatterns: string[]","input: string","id: string","value: unknown"],"sources":["../src/id.ts","../src/transform.ts"],"sourcesContent":["import wcmatch from 'wildcard-match';\n\nconst ALIAS_RE = /^\\{([^}]+)\\}$/;\n\n/** Is this token an alias of another? */\nexport function isAlias(value: string): boolean {\n  return ALIAS_RE.test(value);\n}\n\n/** Same as isTokenMatch but returns the matching pattern */\nexport function getTokenMatch(tokenId: string, globPatterns: string[]): string | undefined {\n  for (const pattern of globPatterns) {\n    if (wcmatch(pattern)(tokenId)) {\n      return pattern;\n    }\n  }\n}\n\n/** Make an alias */\nexport function makeAlias(input: string): string {\n  return input.replace(/^\\{?([^}]+)\\}?$/, '{$1}');\n}\n\n/** Parse an alias */\nexport function parseAlias(input: string): string {\n  // TODO: deprecate in future\n  if (input.includes('#')) {\n    throw new Error(\n      'Mode aliases (# character) are no longer supported as of v0.6.0. Alias the root token instead, and apply modes in plugins.',\n    );\n  }\n  const match = input.match(ALIAS_RE);\n  if (!match) {\n    return input;\n  }\n  return match[1] ?? match[0];\n}\n\n/** split a token ID into a local ID and group ID */\nexport function splitID(id: string): { local: string; group?: string } {\n  const lastSeparatorI = id.lastIndexOf('.');\n  if (lastSeparatorI === -1) {\n    return { local: id };\n  }\n  return {\n    local: id.substring(lastSeparatorI + 1),\n    group: id.substring(0, lastSeparatorI),\n  };\n}\n","export interface CustomTransformOptions {\n  /** Token $type */\n  $type: string;\n}\n\n/** Give a user pertinent feedback if they override a transform incorrectly */\nexport function validateCustomTransform(value: unknown, { $type }: CustomTransformOptions) {\n  if (value) {\n    if ((typeof value !== 'string' && typeof value !== 'object') || Array.isArray(value)) {\n      throw new Error(\n        `transform(): expected string or Object of strings, received ${Array.isArray(value) ? 'Array' : typeof value}`,\n      );\n    }\n    switch ($type) {\n      case 'typography': {\n        if (typeof value !== 'object') {\n          throw new Error('transform(): typography tokens must be an object of keys');\n        }\n        break;\n      }\n    }\n  }\n}\n"],"mappings":";;;;AAEA,MAAM,WAAW;;AAGjB,SAAgB,QAAQA,OAAwB;AAC9C,QAAO,SAAS,KAAK,MAAM;AAC5B;;AAGD,SAAgB,cAAcC,SAAiBC,cAA4C;AACzF,MAAK,MAAM,WAAW,aACpB,KAAI,QAAQ,QAAQ,CAAC,QAAQ,CAC3B,QAAO;AAGZ;;AAGD,SAAgB,UAAUC,OAAuB;AAC/C,QAAO,MAAM,QAAQ,mBAAmB,OAAO;AAChD;;AAGD,SAAgB,WAAWA,OAAuB;AAEhD,KAAI,MAAM,SAAS,IAAI,CACrB,OAAM,IAAI,MACR;CAGJ,MAAM,QAAQ,MAAM,MAAM,SAAS;AACnC,MAAK,MACH,QAAO;AAET,QAAO,MAAM,MAAM,MAAM;AAC1B;;AAGD,SAAgB,QAAQC,IAA+C;CACrE,MAAM,iBAAiB,GAAG,YAAY,IAAI;AAC1C,KAAI,mBAAmB,GACrB,QAAO,EAAE,OAAO,GAAI;AAEtB,QAAO;EACL,OAAO,GAAG,UAAU,iBAAiB,EAAE;EACvC,OAAO,GAAG,UAAU,GAAG,eAAe;CACvC;AACF;;;;;AC1CD,SAAgB,wBAAwBC,OAAgB,EAAE,OAA+B,EAAE;AACzF,KAAI,OAAO;AACT,aAAY,UAAU,mBAAmB,UAAU,YAAa,MAAM,QAAQ,MAAM,CAClF,OAAM,IAAI,MACR,CAAC,4DAA4D,EAAE,MAAM,QAAQ,MAAM,GAAG,iBAAiB,OAAO;AAGlH,UAAQ,OAAR;GACE,KAAK,cAAc;AACjB,eAAW,UAAU,SACnB,OAAM,IAAI,MAAM;AAElB;GACD;EACF;CACF;AACF"}