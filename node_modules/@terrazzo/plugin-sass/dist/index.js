//#region ../plugin-css/dist/index.js
const parseNumber$1 = (color, len) => {
	if (typeof color !== "number") return;
	if (len === 3) return {
		mode: "rgb",
		r: (color >> 8 & 15 | color >> 4 & 240) / 255,
		g: (color >> 4 & 15 | color & 240) / 255,
		b: (color & 15 | color << 4 & 240) / 255
	};
	if (len === 4) return {
		mode: "rgb",
		r: (color >> 12 & 15 | color >> 8 & 240) / 255,
		g: (color >> 8 & 15 | color >> 4 & 240) / 255,
		b: (color >> 4 & 15 | color & 240) / 255,
		alpha: (color & 15 | color << 4 & 240) / 255
	};
	if (len === 6) return {
		mode: "rgb",
		r: (color >> 16 & 255) / 255,
		g: (color >> 8 & 255) / 255,
		b: (color & 255) / 255
	};
	if (len === 8) return {
		mode: "rgb",
		r: (color >> 24 & 255) / 255,
		g: (color >> 16 & 255) / 255,
		b: (color >> 8 & 255) / 255,
		alpha: (color & 255) / 255
	};
};
var parseNumber_default$1 = parseNumber$1;
var named_default$1 = {
	aliceblue: 15792383,
	antiquewhite: 16444375,
	aqua: 65535,
	aquamarine: 8388564,
	azure: 15794175,
	beige: 16119260,
	bisque: 16770244,
	black: 0,
	blanchedalmond: 16772045,
	blue: 255,
	blueviolet: 9055202,
	brown: 10824234,
	burlywood: 14596231,
	cadetblue: 6266528,
	chartreuse: 8388352,
	chocolate: 13789470,
	coral: 16744272,
	cornflowerblue: 6591981,
	cornsilk: 16775388,
	crimson: 14423100,
	cyan: 65535,
	darkblue: 139,
	darkcyan: 35723,
	darkgoldenrod: 12092939,
	darkgray: 11119017,
	darkgreen: 25600,
	darkgrey: 11119017,
	darkkhaki: 12433259,
	darkmagenta: 9109643,
	darkolivegreen: 5597999,
	darkorange: 16747520,
	darkorchid: 10040012,
	darkred: 9109504,
	darksalmon: 15308410,
	darkseagreen: 9419919,
	darkslateblue: 4734347,
	darkslategray: 3100495,
	darkslategrey: 3100495,
	darkturquoise: 52945,
	darkviolet: 9699539,
	deeppink: 16716947,
	deepskyblue: 49151,
	dimgray: 6908265,
	dimgrey: 6908265,
	dodgerblue: 2003199,
	firebrick: 11674146,
	floralwhite: 16775920,
	forestgreen: 2263842,
	fuchsia: 16711935,
	gainsboro: 14474460,
	ghostwhite: 16316671,
	gold: 16766720,
	goldenrod: 14329120,
	gray: 8421504,
	green: 32768,
	greenyellow: 11403055,
	grey: 8421504,
	honeydew: 15794160,
	hotpink: 16738740,
	indianred: 13458524,
	indigo: 4915330,
	ivory: 16777200,
	khaki: 15787660,
	lavender: 15132410,
	lavenderblush: 16773365,
	lawngreen: 8190976,
	lemonchiffon: 16775885,
	lightblue: 11393254,
	lightcoral: 15761536,
	lightcyan: 14745599,
	lightgoldenrodyellow: 16448210,
	lightgray: 13882323,
	lightgreen: 9498256,
	lightgrey: 13882323,
	lightpink: 16758465,
	lightsalmon: 16752762,
	lightseagreen: 2142890,
	lightskyblue: 8900346,
	lightslategray: 7833753,
	lightslategrey: 7833753,
	lightsteelblue: 11584734,
	lightyellow: 16777184,
	lime: 65280,
	limegreen: 3329330,
	linen: 16445670,
	magenta: 16711935,
	maroon: 8388608,
	mediumaquamarine: 6737322,
	mediumblue: 205,
	mediumorchid: 12211667,
	mediumpurple: 9662683,
	mediumseagreen: 3978097,
	mediumslateblue: 8087790,
	mediumspringgreen: 64154,
	mediumturquoise: 4772300,
	mediumvioletred: 13047173,
	midnightblue: 1644912,
	mintcream: 16121850,
	mistyrose: 16770273,
	moccasin: 16770229,
	navajowhite: 16768685,
	navy: 128,
	oldlace: 16643558,
	olive: 8421376,
	olivedrab: 7048739,
	orange: 16753920,
	orangered: 16729344,
	orchid: 14315734,
	palegoldenrod: 15657130,
	palegreen: 10025880,
	paleturquoise: 11529966,
	palevioletred: 14381203,
	papayawhip: 16773077,
	peachpuff: 16767673,
	peru: 13468991,
	pink: 16761035,
	plum: 14524637,
	powderblue: 11591910,
	purple: 8388736,
	rebeccapurple: 6697881,
	red: 16711680,
	rosybrown: 12357519,
	royalblue: 4286945,
	saddlebrown: 9127187,
	salmon: 16416882,
	sandybrown: 16032864,
	seagreen: 3050327,
	seashell: 16774638,
	sienna: 10506797,
	silver: 12632256,
	skyblue: 8900331,
	slateblue: 6970061,
	slategray: 7372944,
	slategrey: 7372944,
	snow: 16775930,
	springgreen: 65407,
	steelblue: 4620980,
	tan: 13808780,
	teal: 32896,
	thistle: 14204888,
	tomato: 16737095,
	turquoise: 4251856,
	violet: 15631086,
	wheat: 16113331,
	white: 16777215,
	whitesmoke: 16119285,
	yellow: 16776960,
	yellowgreen: 10145074
};
const parseNamed$1 = (color) => {
	return parseNumber_default$1(named_default$1[color.toLowerCase()], 6);
};
var parseNamed_default$1 = parseNamed$1;
const hex$1 = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
const parseHex$1 = (color) => {
	let match;
	return (match = color.match(hex$1)) ? parseNumber_default$1(parseInt(match[1], 16), match[1].length) : void 0;
};
var parseHex_default$1 = parseHex$1;
const num$1$1 = "([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)";
`${num$1$1}`;
const per$1 = `${num$1$1}%`;
`${num$1$1}`;
const num_per$1 = `(?:${num$1$1}%|${num$1$1})`;
const num_per_none$1 = `(?:${num$1$1}%|${num$1$1}|none)`;
const hue$1$1 = `(?:${num$1$1}(deg|grad|rad|turn)|${num$1$1})`;
`${num$1$1}${num$1$1}`;
const c$1 = `\\s*,\\s*`;
"" + num_per_none$1;
const rgb_num_old$1 = /* @__PURE__ */ new RegExp(`^rgba?\\(\\s*${num$1$1}${c$1}${num$1$1}${c$1}${num$1$1}\\s*(?:,\\s*${num_per$1}\\s*)?\\)$`);
const rgb_per_old$1 = /* @__PURE__ */ new RegExp(`^rgba?\\(\\s*${per$1}${c$1}${per$1}${c$1}${per$1}\\s*(?:,\\s*${num_per$1}\\s*)?\\)$`);
const parseRgbLegacy$1 = (color) => {
	let res = { mode: "rgb" };
	let match;
	if (match = color.match(rgb_num_old$1)) {
		if (match[1] !== void 0) res.r = match[1] / 255;
		if (match[2] !== void 0) res.g = match[2] / 255;
		if (match[3] !== void 0) res.b = match[3] / 255;
	} else if (match = color.match(rgb_per_old$1)) {
		if (match[1] !== void 0) res.r = match[1] / 100;
		if (match[2] !== void 0) res.g = match[2] / 100;
		if (match[3] !== void 0) res.b = match[3] / 100;
	} else return;
	if (match[4] !== void 0) res.alpha = Math.max(0, Math.min(1, match[4] / 100));
	else if (match[5] !== void 0) res.alpha = Math.max(0, Math.min(1, +match[5]));
	return res;
};
var parseRgbLegacy_default$1 = parseRgbLegacy$1;
const prepare$1 = (color, mode) => color === void 0 ? void 0 : typeof color !== "object" ? parse_default$1(color) : color.mode !== void 0 ? color : mode ? {
	...color,
	mode
} : void 0;
var _prepare_default$1 = prepare$1;
const converter$1 = (target_mode = "rgb") => (color) => (color = _prepare_default$1(color, target_mode)) !== void 0 ? color.mode === target_mode ? color : converters$1$1[color.mode][target_mode] ? converters$1$1[color.mode][target_mode](color) : target_mode === "rgb" ? converters$1$1[color.mode].rgb(color) : converters$1$1.rgb[target_mode](converters$1$1[color.mode].rgb(color)) : void 0;
var converter_default$1 = converter$1;
const converters$1$1 = {};
const modes$1 = {};
const parsers$1 = [];
const colorProfiles$1 = {};
const identity$1 = (v) => v;
const useMode$1 = (definition$28) => {
	converters$1$1[definition$28.mode] = {
		...converters$1$1[definition$28.mode],
		...definition$28.toMode
	};
	Object.keys(definition$28.fromMode || {}).forEach((k$3$1) => {
		if (!converters$1$1[k$3$1]) converters$1$1[k$3$1] = {};
		converters$1$1[k$3$1][definition$28.mode] = definition$28.fromMode[k$3$1];
	});
	if (!definition$28.ranges) definition$28.ranges = {};
	if (!definition$28.difference) definition$28.difference = {};
	definition$28.channels.forEach((channel) => {
		if (definition$28.ranges[channel] === void 0) definition$28.ranges[channel] = [0, 1];
		if (!definition$28.interpolate[channel]) throw new Error(`Missing interpolator for: ${channel}`);
		if (typeof definition$28.interpolate[channel] === "function") definition$28.interpolate[channel] = { use: definition$28.interpolate[channel] };
		if (!definition$28.interpolate[channel].fixup) definition$28.interpolate[channel].fixup = identity$1;
	});
	modes$1[definition$28.mode] = definition$28;
	(definition$28.parse || []).forEach((parser) => {
		useParser$1(parser, definition$28.mode);
	});
	return converter_default$1(definition$28.mode);
};
const getMode$1 = (mode) => modes$1[mode];
const useParser$1 = (parser, mode) => {
	if (typeof parser === "string") {
		if (!mode) throw new Error(`'mode' required when 'parser' is a string`);
		colorProfiles$1[parser] = mode;
	} else if (typeof parser === "function") {
		if (parsers$1.indexOf(parser) < 0) parsers$1.push(parser);
	}
};
const IdentStartCodePoint$1 = /[^\x00-\x7F]|[a-zA-Z_]/;
const IdentCodePoint$1 = /[^\x00-\x7F]|[-\w]/;
const Tok$1 = {
	Function: "function",
	Ident: "ident",
	Number: "number",
	Percentage: "percentage",
	ParenClose: ")",
	None: "none",
	Hue: "hue",
	Alpha: "alpha"
};
let _i$1 = 0;
function is_num$1(chars) {
	let ch = chars[_i$1];
	let ch1 = chars[_i$1 + 1];
	if (ch === "-" || ch === "+") return /\d/.test(ch1) || ch1 === "." && /\d/.test(chars[_i$1 + 2]);
	if (ch === ".") return /\d/.test(ch1);
	return /\d/.test(ch);
}
function is_ident$1(chars) {
	if (_i$1 >= chars.length) return false;
	let ch = chars[_i$1];
	if (IdentStartCodePoint$1.test(ch)) return true;
	if (ch === "-") {
		if (chars.length - _i$1 < 2) return false;
		let ch1 = chars[_i$1 + 1];
		if (ch1 === "-" || IdentStartCodePoint$1.test(ch1)) return true;
		return false;
	}
	return false;
}
const huenits$1 = {
	deg: 1,
	rad: 180 / Math.PI,
	grad: 9 / 10,
	turn: 360
};
function num$2(chars) {
	let value = "";
	if (chars[_i$1] === "-" || chars[_i$1] === "+") value += chars[_i$1++];
	value += digits$1(chars);
	if (chars[_i$1] === "." && /\d/.test(chars[_i$1 + 1])) value += chars[_i$1++] + digits$1(chars);
	if (chars[_i$1] === "e" || chars[_i$1] === "E") {
		if ((chars[_i$1 + 1] === "-" || chars[_i$1 + 1] === "+") && /\d/.test(chars[_i$1 + 2])) value += chars[_i$1++] + chars[_i$1++] + digits$1(chars);
		else if (/\d/.test(chars[_i$1 + 1])) value += chars[_i$1++] + digits$1(chars);
	}
	if (is_ident$1(chars)) {
		let id = ident$1(chars);
		if (id === "deg" || id === "rad" || id === "turn" || id === "grad") return {
			type: Tok$1.Hue,
			value: value * huenits$1[id]
		};
		return;
	}
	if (chars[_i$1] === "%") {
		_i$1++;
		return {
			type: Tok$1.Percentage,
			value: +value
		};
	}
	return {
		type: Tok$1.Number,
		value: +value
	};
}
function digits$1(chars) {
	let v = "";
	while (/\d/.test(chars[_i$1])) v += chars[_i$1++];
	return v;
}
function ident$1(chars) {
	let v = "";
	while (_i$1 < chars.length && IdentCodePoint$1.test(chars[_i$1])) v += chars[_i$1++];
	return v;
}
function identlike$1(chars) {
	let v = ident$1(chars);
	if (chars[_i$1] === "(") {
		_i$1++;
		return {
			type: Tok$1.Function,
			value: v
		};
	}
	if (v === "none") return {
		type: Tok$1.None,
		value: void 0
	};
	return {
		type: Tok$1.Ident,
		value: v
	};
}
function tokenize$1(str = "") {
	let chars = str.trim();
	let tokens = [];
	let ch;
	_i$1 = 0;
	while (_i$1 < chars.length) {
		ch = chars[_i$1++];
		if (ch === "\n" || ch === "	" || ch === " ") {
			while (_i$1 < chars.length && (chars[_i$1] === "\n" || chars[_i$1] === "	" || chars[_i$1] === " ")) _i$1++;
			continue;
		}
		if (ch === ",") return;
		if (ch === ")") {
			tokens.push({ type: Tok$1.ParenClose });
			continue;
		}
		if (ch === "+") {
			_i$1--;
			if (is_num$1(chars)) {
				tokens.push(num$2(chars));
				continue;
			}
			return;
		}
		if (ch === "-") {
			_i$1--;
			if (is_num$1(chars)) {
				tokens.push(num$2(chars));
				continue;
			}
			if (is_ident$1(chars)) {
				tokens.push({
					type: Tok$1.Ident,
					value: ident$1(chars)
				});
				continue;
			}
			return;
		}
		if (ch === ".") {
			_i$1--;
			if (is_num$1(chars)) {
				tokens.push(num$2(chars));
				continue;
			}
			return;
		}
		if (ch === "/") {
			while (_i$1 < chars.length && (chars[_i$1] === "\n" || chars[_i$1] === "	" || chars[_i$1] === " ")) _i$1++;
			let alpha;
			if (is_num$1(chars)) {
				alpha = num$2(chars);
				if (alpha.type !== Tok$1.Hue) {
					tokens.push({
						type: Tok$1.Alpha,
						value: alpha
					});
					continue;
				}
			}
			if (is_ident$1(chars)) {
				if (ident$1(chars) === "none") {
					tokens.push({
						type: Tok$1.Alpha,
						value: {
							type: Tok$1.None,
							value: void 0
						}
					});
					continue;
				}
			}
			return;
		}
		if (/\d/.test(ch)) {
			_i$1--;
			tokens.push(num$2(chars));
			continue;
		}
		if (IdentStartCodePoint$1.test(ch)) {
			_i$1--;
			tokens.push(identlike$1(chars));
			continue;
		}
		return;
	}
	return tokens;
}
function parseColorSyntax$1(tokens) {
	tokens._i = 0;
	let token = tokens[tokens._i++];
	if (!token || token.type !== Tok$1.Function || token.value !== "color") return;
	token = tokens[tokens._i++];
	if (token.type !== Tok$1.Ident) return;
	const mode = colorProfiles$1[token.value];
	if (!mode) return;
	const res = { mode };
	const coords = consumeCoords$1(tokens, false);
	if (!coords) return;
	const channels = getMode$1(mode).channels;
	for (let ii = 0, c$1$1, ch; ii < channels.length; ii++) {
		c$1$1 = coords[ii];
		ch = channels[ii];
		if (c$1$1.type !== Tok$1.None) {
			res[ch] = c$1$1.type === Tok$1.Number ? c$1$1.value : c$1$1.value / 100;
			if (ch === "alpha") res[ch] = Math.max(0, Math.min(1, res[ch]));
		}
	}
	return res;
}
function consumeCoords$1(tokens, includeHue) {
	const coords = [];
	let token;
	while (tokens._i < tokens.length) {
		token = tokens[tokens._i++];
		if (token.type === Tok$1.None || token.type === Tok$1.Number || token.type === Tok$1.Alpha || token.type === Tok$1.Percentage || includeHue && token.type === Tok$1.Hue) {
			coords.push(token);
			continue;
		}
		if (token.type === Tok$1.ParenClose) {
			if (tokens._i < tokens.length) return;
			continue;
		}
		return;
	}
	if (coords.length < 3 || coords.length > 4) return;
	if (coords.length === 4) {
		if (coords[3].type !== Tok$1.Alpha) return;
		coords[3] = coords[3].value;
	}
	if (coords.length === 3) coords.push({
		type: Tok$1.None,
		value: void 0
	});
	return coords.every((c$1$1) => c$1$1.type !== Tok$1.Alpha) ? coords : void 0;
}
function parseModernSyntax$1(tokens, includeHue) {
	tokens._i = 0;
	let token = tokens[tokens._i++];
	if (!token || token.type !== Tok$1.Function) return;
	let coords = consumeCoords$1(tokens, includeHue);
	if (!coords) return;
	coords.unshift(token.value);
	return coords;
}
const parse$1 = (color) => {
	if (typeof color !== "string") return;
	const tokens = tokenize$1(color);
	const parsed = tokens ? parseModernSyntax$1(tokens, true) : void 0;
	let result = void 0;
	let i = 0;
	let len = parsers$1.length;
	while (i < len) if ((result = parsers$1[i++](color, parsed)) !== void 0) return result;
	return tokens ? parseColorSyntax$1(tokens) : void 0;
};
var parse_default$1 = parse$1;
function parseRgb$1(color, parsed) {
	if (!parsed || parsed[0] !== "rgb" && parsed[0] !== "rgba") return;
	const res = { mode: "rgb" };
	const [, r$1$1, g, b, alpha] = parsed;
	if (r$1$1.type === Tok$1.Hue || g.type === Tok$1.Hue || b.type === Tok$1.Hue) return;
	if (r$1$1.type !== Tok$1.None) res.r = r$1$1.type === Tok$1.Number ? r$1$1.value / 255 : r$1$1.value / 100;
	if (g.type !== Tok$1.None) res.g = g.type === Tok$1.Number ? g.value / 255 : g.value / 100;
	if (b.type !== Tok$1.None) res.b = b.type === Tok$1.Number ? b.value / 255 : b.value / 100;
	if (alpha.type !== Tok$1.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok$1.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseRgb_default$1 = parseRgb$1;
const parseTransparent$1 = (c$1$1) => c$1$1 === "transparent" ? {
	mode: "rgb",
	r: 0,
	g: 0,
	b: 0,
	alpha: 0
} : void 0;
var parseTransparent_default$1 = parseTransparent$1;
const lerp$1 = (a, b, t) => a + t * (b - a);
const get_classes$1 = (arr) => {
	let classes = [];
	for (let i = 0; i < arr.length - 1; i++) {
		let a = arr[i];
		let b = arr[i + 1];
		if (a === void 0 && b === void 0) classes.push(void 0);
		else if (a !== void 0 && b !== void 0) classes.push([a, b]);
		else classes.push(a !== void 0 ? [a, a] : [b, b]);
	}
	return classes;
};
const interpolatorPiecewise$1 = (interpolator) => (arr) => {
	let classes = get_classes$1(arr);
	return (t) => {
		let cls = t * classes.length;
		let idx = t >= 1 ? classes.length - 1 : Math.max(Math.floor(cls), 0);
		let pair = classes[idx];
		return pair === void 0 ? void 0 : interpolator(pair[0], pair[1], cls - idx);
	};
};
const interpolatorLinear$1 = interpolatorPiecewise$1(lerp$1);
const fixupAlpha$1 = (arr) => {
	let some_defined = false;
	let res = arr.map((v) => {
		if (v !== void 0) {
			some_defined = true;
			return v;
		}
		return 1;
	});
	return some_defined ? res : arr;
};
var definition_default$12$1 = {
	mode: "rgb",
	channels: [
		"r",
		"g",
		"b",
		"alpha"
	],
	parse: [
		parseRgb_default$1,
		parseHex_default$1,
		parseRgbLegacy_default$1,
		parseNamed_default$1,
		parseTransparent_default$1,
		"srgb"
	],
	serialize: "srgb",
	interpolate: {
		r: interpolatorLinear$1,
		g: interpolatorLinear$1,
		b: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	},
	gamut: true,
	white: {
		r: 1,
		g: 1,
		b: 1
	},
	black: {
		r: 0,
		g: 0,
		b: 0
	}
};
const linearize$2$1 = (v = 0) => Math.pow(Math.abs(v), 563 / 256) * Math.sign(v);
const convertA98ToXyz65$1 = (a98$2) => {
	let r$1$1 = linearize$2$1(a98$2.r);
	let g = linearize$2$1(a98$2.g);
	let b = linearize$2$1(a98$2.b);
	let res = {
		mode: "xyz65",
		x: .5766690429101305 * r$1$1 + .1855582379065463 * g + .1882286462349947 * b,
		y: .297344975250536 * r$1$1 + .6273635662554661 * g + .0752914584939979 * b,
		z: .0270313613864123 * r$1$1 + .0706888525358272 * g + .9913375368376386 * b
	};
	if (a98$2.alpha !== void 0) res.alpha = a98$2.alpha;
	return res;
};
var convertA98ToXyz65_default$1 = convertA98ToXyz65$1;
const gamma$2$1 = (v) => Math.pow(Math.abs(v), 256 / 563) * Math.sign(v);
const convertXyz65ToA98$1 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "a98",
		r: gamma$2$1(x * 2.0415879038107465 - y * .5650069742788597 - .3447313507783297 * z),
		g: gamma$2$1(x * -.9692436362808798 + y * 1.8759675015077206 + .0415550574071756 * z),
		b: gamma$2$1(x * .0134442806320312 - y * .1183623922310184 + 1.0151749943912058 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToA98_default$1 = convertXyz65ToA98$1;
const fn$3$1 = (c$1$1 = 0) => {
	const abs$1$1 = Math.abs(c$1$1);
	if (abs$1$1 <= .04045) return c$1$1 / 12.92;
	return (Math.sign(c$1$1) || 1) * Math.pow((abs$1$1 + .055) / 1.055, 2.4);
};
const convertRgbToLrgb$1 = ({ r: r$1$1, g, b, alpha }) => {
	let res = {
		mode: "lrgb",
		r: fn$3$1(r$1$1),
		g: fn$3$1(g),
		b: fn$3$1(b)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToLrgb_default$1 = convertRgbToLrgb$1;
const convertRgbToXyz65$1 = (rgb$4) => {
	let { r: r$1$1, g, b, alpha } = convertRgbToLrgb_default$1(rgb$4);
	let res = {
		mode: "xyz65",
		x: .4123907992659593 * r$1$1 + .357584339383878 * g + .1804807884018343 * b,
		y: .2126390058715102 * r$1$1 + .715168678767756 * g + .0721923153607337 * b,
		z: .0193308187155918 * r$1$1 + .119194779794626 * g + .9505321522496607 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyz65_default$1 = convertRgbToXyz65$1;
const fn$2$1 = (c$1$1 = 0) => {
	const abs$1$1 = Math.abs(c$1$1);
	if (abs$1$1 > .0031308) return (Math.sign(c$1$1) || 1) * (1.055 * Math.pow(abs$1$1, 1 / 2.4) - .055);
	return c$1$1 * 12.92;
};
const convertLrgbToRgb$1 = ({ r: r$1$1, g, b, alpha }, mode = "rgb") => {
	let res = {
		mode,
		r: fn$2$1(r$1$1),
		g: fn$2$1(g),
		b: fn$2$1(b)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLrgbToRgb_default$1 = convertLrgbToRgb$1;
const convertXyz65ToRgb$1 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default$1({
		r: x * 3.2409699419045226 - y * 1.537383177570094 - .4986107602930034 * z,
		g: x * -.9692436362808796 + y * 1.8759675015077204 + .0415550574071756 * z,
		b: x * .0556300796969936 - y * .2039769588889765 + 1.0569715142428784 * z
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToRgb_default$1 = convertXyz65ToRgb$1;
var definition_default$28 = {
	...definition_default$12$1,
	mode: "a98",
	parse: ["a98-rgb"],
	serialize: "a98-rgb",
	fromMode: {
		rgb: (color) => convertXyz65ToA98_default$1(convertRgbToXyz65_default$1(color)),
		xyz65: convertXyz65ToA98_default$1
	},
	toMode: {
		rgb: (color) => convertXyz65ToRgb_default$1(convertA98ToXyz65_default$1(color)),
		xyz65: convertA98ToXyz65_default$1
	}
};
const normalizeHue$1 = (hue$2$1) => (hue$2$1 = hue$2$1 % 360) < 0 ? hue$2$1 + 360 : hue$2$1;
var normalizeHue_default$1 = normalizeHue$1;
function convertHslToRgb$1({ h, s, l, alpha }) {
	h = normalizeHue_default$1(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (l === void 0) l = 0;
	let m1 = l + s * (l < .5 ? l : 1 - l);
	let m2 = m1 - (m1 - l) * 2 * Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: m1,
				g: m2,
				b: 2 * l - m1
			};
			break;
		case 1:
			res = {
				r: m2,
				g: m1,
				b: 2 * l - m1
			};
			break;
		case 2:
			res = {
				r: 2 * l - m1,
				g: m1,
				b: m2
			};
			break;
		case 3:
			res = {
				r: 2 * l - m1,
				g: m2,
				b: m1
			};
			break;
		case 4:
			res = {
				r: m2,
				g: 2 * l - m1,
				b: m1
			};
			break;
		case 5:
			res = {
				r: m1,
				g: 2 * l - m1,
				b: m2
			};
			break;
		default: res = {
			r: 2 * l - m1,
			g: 2 * l - m1,
			b: 2 * l - m1
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}
function convertRgbToHsl$1({ r: r$1$1, g, b, alpha }) {
	if (r$1$1 === void 0) r$1$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$1$1 = Math.max(r$1$1, g, b), m = Math.min(r$1$1, g, b);
	let res = {
		mode: "hsl",
		s: M$1$1 === m ? 0 : (M$1$1 - m) / (1 - Math.abs(M$1$1 + m - 1)),
		l: .5 * (M$1$1 + m)
	};
	if (M$1$1 - m !== 0) res.h = (M$1$1 === r$1$1 ? (g - b) / (M$1$1 - m) + (g < b) * 6 : M$1$1 === g ? (b - r$1$1) / (M$1$1 - m) + 2 : (r$1$1 - g) / (M$1$1 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}
const hueToDeg$1 = (val, unit) => {
	switch (unit) {
		case "deg": return +val;
		case "rad": return val / Math.PI * 180;
		case "grad": return val / 10 * 9;
		case "turn": return val * 360;
	}
};
var hue_default$1 = hueToDeg$1;
const hsl_old$1 = /* @__PURE__ */ new RegExp(`^hsla?\\(\\s*${hue$1$1}${c$1}${per$1}${c$1}${per$1}\\s*(?:,\\s*${num_per$1}\\s*)?\\)$`);
const parseHslLegacy$1 = (color) => {
	let match = color.match(hsl_old$1);
	if (!match) return;
	let res = { mode: "hsl" };
	if (match[3] !== void 0) res.h = +match[3];
	else if (match[1] !== void 0 && match[2] !== void 0) res.h = hue_default$1(match[1], match[2]);
	if (match[4] !== void 0) res.s = Math.min(Math.max(0, match[4] / 100), 1);
	if (match[5] !== void 0) res.l = Math.min(Math.max(0, match[5] / 100), 1);
	if (match[6] !== void 0) res.alpha = Math.max(0, Math.min(1, match[6] / 100));
	else if (match[7] !== void 0) res.alpha = Math.max(0, Math.min(1, +match[7]));
	return res;
};
var parseHslLegacy_default$1 = parseHslLegacy$1;
function parseHsl$1(color, parsed) {
	if (!parsed || parsed[0] !== "hsl" && parsed[0] !== "hsla") return;
	const res = { mode: "hsl" };
	const [, h, s, l, alpha] = parsed;
	if (h.type !== Tok$1.None) {
		if (h.type === Tok$1.Percentage) return;
		res.h = h.value;
	}
	if (s.type !== Tok$1.None) {
		if (s.type === Tok$1.Hue) return;
		res.s = s.value / 100;
	}
	if (l.type !== Tok$1.None) {
		if (l.type === Tok$1.Hue) return;
		res.l = l.value / 100;
	}
	if (alpha.type !== Tok$1.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok$1.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseHsl_default$1 = parseHsl$1;
const hue$2 = (hues, fn$4$1) => {
	return hues.map((hue$2$1, idx, arr) => {
		if (hue$2$1 === void 0) return hue$2$1;
		let normalized = normalizeHue_default$1(hue$2$1);
		if (idx === 0 || hues[idx - 1] === void 0) return normalized;
		return fn$4$1(normalized - normalizeHue_default$1(arr[idx - 1]));
	}).reduce((acc, curr) => {
		if (!acc.length || curr === void 0 || acc[acc.length - 1] === void 0) {
			acc.push(curr);
			return acc;
		}
		acc.push(curr + acc[acc.length - 1]);
		return acc;
	}, []);
};
const fixupHueShorter$1 = (arr) => hue$2(arr, (d) => Math.abs(d) <= 180 ? d : d - 360 * Math.sign(d));
const differenceHueSaturation$1 = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0 || !std.s || !smp.s) return 0;
	let std_h = normalizeHue_default$1(std.h);
	let smp_h = normalizeHue_default$1(smp.h);
	let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
	return 2 * Math.sqrt(std.s * smp.s) * dH;
};
const differenceHueNaive$1 = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0) return 0;
	let std_h = normalizeHue_default$1(std.h);
	let smp_h = normalizeHue_default$1(smp.h);
	if (Math.abs(smp_h - std_h) > 180) return std_h - (smp_h - 360 * Math.sign(smp_h - std_h));
	return smp_h - std_h;
};
const differenceHueChroma$1 = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0 || !std.c || !smp.c) return 0;
	let std_h = normalizeHue_default$1(std.h);
	let smp_h = normalizeHue_default$1(smp.h);
	let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
	return 2 * Math.sqrt(std.c * smp.c) * dH;
};
const averageAngle$1 = (val) => {
	let sum = val.reduce((sum$1, val$1) => {
		if (val$1 !== void 0) {
			let rad = val$1 * Math.PI / 180;
			sum$1.sin += Math.sin(rad);
			sum$1.cos += Math.cos(rad);
		}
		return sum$1;
	}, {
		sin: 0,
		cos: 0
	});
	let angle = Math.atan2(sum.sin, sum.cos) * 180 / Math.PI;
	return angle < 0 ? 360 + angle : angle;
};
var definition_default$1$1 = {
	mode: "hsl",
	toMode: { rgb: convertHslToRgb$1 },
	fromMode: { rgb: convertRgbToHsl$1 },
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	parse: [parseHsl_default$1, parseHslLegacy_default$1],
	serialize: (c$1$1) => `hsl(${c$1$1.h !== void 0 ? c$1$1.h : "none"} ${c$1$1.s !== void 0 ? c$1$1.s * 100 + "%" : "none"} ${c$1$1.l !== void 0 ? c$1$1.l * 100 + "%" : "none"}${c$1$1.alpha < 1 ? ` / ${c$1$1.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear$1,
			fixup: fixupHueShorter$1
		},
		s: interpolatorLinear$1,
		l: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	},
	difference: { h: differenceHueSaturation$1 },
	average: { h: averageAngle$1 }
};
function convertHsvToRgb$1({ h, s, v, alpha }) {
	h = normalizeHue_default$1(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (v === void 0) v = 0;
	let f$2$1 = Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: v,
				g: v * (1 - s * f$2$1),
				b: v * (1 - s)
			};
			break;
		case 1:
			res = {
				r: v * (1 - s * f$2$1),
				g: v,
				b: v * (1 - s)
			};
			break;
		case 2:
			res = {
				r: v * (1 - s),
				g: v,
				b: v * (1 - s * f$2$1)
			};
			break;
		case 3:
			res = {
				r: v * (1 - s),
				g: v * (1 - s * f$2$1),
				b: v
			};
			break;
		case 4:
			res = {
				r: v * (1 - s * f$2$1),
				g: v * (1 - s),
				b: v
			};
			break;
		case 5:
			res = {
				r: v,
				g: v * (1 - s),
				b: v * (1 - s * f$2$1)
			};
			break;
		default: res = {
			r: v * (1 - s),
			g: v * (1 - s),
			b: v * (1 - s)
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}
function convertRgbToHsv$1({ r: r$1$1, g, b, alpha }) {
	if (r$1$1 === void 0) r$1$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$1$1 = Math.max(r$1$1, g, b), m = Math.min(r$1$1, g, b);
	let res = {
		mode: "hsv",
		s: M$1$1 === 0 ? 0 : 1 - m / M$1$1,
		v: M$1$1
	};
	if (M$1$1 - m !== 0) res.h = (M$1$1 === r$1$1 ? (g - b) / (M$1$1 - m) + (g < b) * 6 : M$1$1 === g ? (b - r$1$1) / (M$1$1 - m) + 2 : (r$1$1 - g) / (M$1$1 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}
var definition_default$19$1 = {
	mode: "hsv",
	toMode: { rgb: convertHsvToRgb$1 },
	parse: ["--hsv"],
	serialize: "--hsv",
	fromMode: { rgb: convertRgbToHsv$1 },
	channels: [
		"h",
		"s",
		"v",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	interpolate: {
		h: {
			use: interpolatorLinear$1,
			fixup: fixupHueShorter$1
		},
		s: interpolatorLinear$1,
		v: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	},
	difference: { h: differenceHueSaturation$1 },
	average: { h: averageAngle$1 }
};
function convertHwbToRgb$1({ h, w, b, alpha }) {
	if (w === void 0) w = 0;
	if (b === void 0) b = 0;
	if (w + b > 1) {
		let s = w + b;
		w /= s;
		b /= s;
	}
	return convertHsvToRgb$1({
		h,
		s: b === 1 ? 1 : 1 - w / (1 - b),
		v: 1 - b,
		alpha
	});
}
function convertRgbToHwb$1(rgba) {
	let hsv$2 = convertRgbToHsv$1(rgba);
	if (hsv$2 === void 0) return void 0;
	let s = hsv$2.s !== void 0 ? hsv$2.s : 0;
	let v = hsv$2.v !== void 0 ? hsv$2.v : 0;
	let res = {
		mode: "hwb",
		w: (1 - s) * v,
		b: 1 - v
	};
	if (hsv$2.h !== void 0) res.h = hsv$2.h;
	if (hsv$2.alpha !== void 0) res.alpha = hsv$2.alpha;
	return res;
}
function ParseHwb$1(color, parsed) {
	if (!parsed || parsed[0] !== "hwb") return;
	const res = { mode: "hwb" };
	const [, h, w, b, alpha] = parsed;
	if (h.type !== Tok$1.None) {
		if (h.type === Tok$1.Percentage) return;
		res.h = h.value;
	}
	if (w.type !== Tok$1.None) {
		if (w.type === Tok$1.Hue) return;
		res.w = w.value / 100;
	}
	if (b.type !== Tok$1.None) {
		if (b.type === Tok$1.Hue) return;
		res.b = b.value / 100;
	}
	if (alpha.type !== Tok$1.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok$1.Number ? alpha.value : alpha.value / 100));
	return res;
}
var definition_default$2$1 = {
	mode: "hwb",
	toMode: { rgb: convertHwbToRgb$1 },
	fromMode: { rgb: convertRgbToHwb$1 },
	channels: [
		"h",
		"w",
		"b",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	parse: [ParseHwb$1],
	serialize: (c$1$1) => `hwb(${c$1$1.h !== void 0 ? c$1$1.h : "none"} ${c$1$1.w !== void 0 ? c$1$1.w * 100 + "%" : "none"} ${c$1$1.b !== void 0 ? c$1$1.b * 100 + "%" : "none"}${c$1$1.alpha < 1 ? ` / ${c$1$1.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear$1,
			fixup: fixupHueShorter$1
		},
		w: interpolatorLinear$1,
		b: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	},
	difference: { h: differenceHueNaive$1 },
	average: { h: averageAngle$1 }
};
const k$3 = Math.pow(29, 3) / Math.pow(3, 3);
const e$3 = Math.pow(6, 3) / Math.pow(29, 3);
const D50$1 = {
	X: .3457 / .3585,
	Y: 1,
	Z: .2958 / .3585
};
const D65$1 = {
	X: .3127 / .329,
	Y: 1,
	Z: .3583 / .329
};
Math.pow(29, 3) / Math.pow(3, 3);
Math.pow(6, 3) / Math.pow(29, 3);
let fn$1$1 = (v) => Math.pow(v, 3) > e$3 ? Math.pow(v, 3) : (116 * v - 16) / k$3;
const convertLabToXyz50$1 = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let fy = (l + 16) / 116;
	let fx = a / 500 + fy;
	let fz = fy - b / 200;
	let res = {
		mode: "xyz50",
		x: fn$1$1(fx) * D50$1.X,
		y: fn$1$1(fy) * D50$1.Y,
		z: fn$1$1(fz) * D50$1.Z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLabToXyz50_default$1 = convertLabToXyz50$1;
const convertXyz50ToRgb$1 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default$1({
		r: x * 3.1341359569958707 - y * 1.6173863321612538 - .4906619460083532 * z,
		g: x * -.978795502912089 + y * 1.916254567259524 + .03344273116131949 * z,
		b: x * .07195537988411677 - y * .2289768264158322 + 1.405386058324125 * z
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToRgb_default$1 = convertXyz50ToRgb$1;
const convertLabToRgb$1 = (lab$2) => convertXyz50ToRgb_default$1(convertLabToXyz50_default$1(lab$2));
var convertLabToRgb_default$1 = convertLabToRgb$1;
const convertRgbToXyz50$1 = (rgb$4) => {
	let { r: r$1$1, g, b, alpha } = convertRgbToLrgb_default$1(rgb$4);
	let res = {
		mode: "xyz50",
		x: .436065742824811 * r$1$1 + .3851514688337912 * g + .14307845442264197 * b,
		y: .22249319175623702 * r$1$1 + .7168870538238823 * g + .06061979053616537 * b,
		z: .013923904500943465 * r$1$1 + .09708128566574634 * g + .7140993584005155 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyz50_default$1 = convertRgbToXyz50$1;
const f$1$1 = (value) => value > e$3 ? Math.cbrt(value) : (k$3 * value + 16) / 116;
const convertXyz50ToLab$1 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let f0 = f$1$1(x / D50$1.X);
	let f1 = f$1$1(y / D50$1.Y);
	let f2 = f$1$1(z / D50$1.Z);
	let res = {
		mode: "lab",
		l: 116 * f1 - 16,
		a: 500 * (f0 - f1),
		b: 200 * (f1 - f2)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToLab_default$1 = convertXyz50ToLab$1;
const convertRgbToLab$1 = (rgb$4) => {
	let res = convertXyz50ToLab_default$1(convertRgbToXyz50_default$1(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToLab_default$1 = convertRgbToLab$1;
function parseLab$1(color, parsed) {
	if (!parsed || parsed[0] !== "lab") return;
	const res = { mode: "lab" };
	const [, l, a, b, alpha] = parsed;
	if (l.type === Tok$1.Hue || a.type === Tok$1.Hue || b.type === Tok$1.Hue) return;
	if (l.type !== Tok$1.None) res.l = Math.min(Math.max(0, l.value), 100);
	if (a.type !== Tok$1.None) res.a = a.type === Tok$1.Number ? a.value : a.value * 125 / 100;
	if (b.type !== Tok$1.None) res.b = b.type === Tok$1.Number ? b.value : b.value * 125 / 100;
	if (alpha.type !== Tok$1.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok$1.Number ? alpha.value : alpha.value / 100));
	return res;
}
var definition_default$3$1 = {
	mode: "lab",
	toMode: {
		xyz50: convertLabToXyz50_default$1,
		rgb: convertLabToRgb_default$1
	},
	fromMode: {
		xyz50: convertXyz50ToLab_default$1,
		rgb: convertRgbToLab_default$1
	},
	channels: [
		"l",
		"a",
		"b",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		a: [-125, 125],
		b: [-125, 125]
	},
	parse: [parseLab$1],
	serialize: (c$1$1) => `lab(${c$1$1.l !== void 0 ? c$1$1.l : "none"} ${c$1$1.a !== void 0 ? c$1$1.a : "none"} ${c$1$1.b !== void 0 ? c$1$1.b : "none"}${c$1$1.alpha < 1 ? ` / ${c$1$1.alpha}` : ""})`,
	interpolate: {
		l: interpolatorLinear$1,
		a: interpolatorLinear$1,
		b: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	}
};
const k$1$1 = Math.pow(29, 3) / Math.pow(3, 3);
const e$1$1 = Math.pow(6, 3) / Math.pow(29, 3);
let fn$4 = (v) => Math.pow(v, 3) > e$1$1 ? Math.pow(v, 3) : (116 * v - 16) / k$1$1;
const convertLab65ToXyz65$1 = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let fy = (l + 16) / 116;
	let fx = a / 500 + fy;
	let fz = fy - b / 200;
	let res = {
		mode: "xyz65",
		x: fn$4(fx) * D65$1.X,
		y: fn$4(fy) * D65$1.Y,
		z: fn$4(fz) * D65$1.Z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLab65ToXyz65_default$1 = convertLab65ToXyz65$1;
const convertLab65ToRgb$1 = (lab$2) => convertXyz65ToRgb_default$1(convertLab65ToXyz65_default$1(lab$2));
var convertLab65ToRgb_default$1 = convertLab65ToRgb$1;
const f$2 = (value) => value > e$1$1 ? Math.cbrt(value) : (k$1$1 * value + 16) / 116;
const convertXyz65ToLab65$1 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let f0 = f$2(x / D65$1.X);
	let f1 = f$2(y / D65$1.Y);
	let f2 = f$2(z / D65$1.Z);
	let res = {
		mode: "lab65",
		l: 116 * f1 - 16,
		a: 500 * (f0 - f1),
		b: 200 * (f1 - f2)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToLab65_default$1 = convertXyz65ToLab65$1;
const convertRgbToLab65$1 = (rgb$4) => {
	let res = convertXyz65ToLab65_default$1(convertRgbToXyz65_default$1(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToLab65_default$1 = convertRgbToLab65$1;
var definition_default$4$1 = {
	...definition_default$3$1,
	mode: "lab65",
	parse: ["--lab-d65"],
	serialize: "--lab-d65",
	toMode: {
		xyz65: convertLab65ToXyz65_default$1,
		rgb: convertLab65ToRgb_default$1
	},
	fromMode: {
		xyz65: convertXyz65ToLab65_default$1,
		rgb: convertRgbToLab65_default$1
	},
	ranges: {
		l: [0, 100],
		a: [-125, 125],
		b: [-125, 125]
	}
};
const convertLabToLch$1 = ({ l, a, b, alpha }, mode = "lch") => {
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let c$1$1 = Math.sqrt(a * a + b * b);
	let res = {
		mode,
		l,
		c: c$1$1
	};
	if (c$1$1) res.h = normalizeHue_default$1(Math.atan2(b, a) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLabToLch_default$1 = convertLabToLch$1;
const convertLchToLab$1 = ({ l, c: c$1$1, h, alpha }, mode = "lab") => {
	if (h === void 0) h = 0;
	let res = {
		mode,
		l,
		a: c$1$1 ? c$1$1 * Math.cos(h / 180 * Math.PI) : 0,
		b: c$1$1 ? c$1$1 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLchToLab_default$1 = convertLchToLab$1;
function parseLch$1(color, parsed) {
	if (!parsed || parsed[0] !== "lch") return;
	const res = { mode: "lch" };
	const [, l, c$1$1, h, alpha] = parsed;
	if (l.type !== Tok$1.None) {
		if (l.type === Tok$1.Hue) return;
		res.l = Math.min(Math.max(0, l.value), 100);
	}
	if (c$1$1.type !== Tok$1.None) res.c = Math.max(0, c$1$1.type === Tok$1.Number ? c$1$1.value : c$1$1.value * 150 / 100);
	if (h.type !== Tok$1.None) {
		if (h.type === Tok$1.Percentage) return;
		res.h = h.value;
	}
	if (alpha.type !== Tok$1.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok$1.Number ? alpha.value : alpha.value / 100));
	return res;
}
var definition_default$5$1 = {
	mode: "lch",
	toMode: {
		lab: convertLchToLab_default$1,
		rgb: (c$1$1) => convertLabToRgb_default$1(convertLchToLab_default$1(c$1$1))
	},
	fromMode: {
		rgb: (c$1$1) => convertLabToLch_default$1(convertRgbToLab_default$1(c$1$1)),
		lab: convertLabToLch_default$1
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		c: [0, 150],
		h: [0, 360]
	},
	parse: [parseLch$1],
	serialize: (c$1$1) => `lch(${c$1$1.l !== void 0 ? c$1$1.l : "none"} ${c$1$1.c !== void 0 ? c$1$1.c : "none"} ${c$1$1.h !== void 0 ? c$1$1.h : "none"}${c$1$1.alpha < 1 ? ` / ${c$1$1.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear$1,
			fixup: fixupHueShorter$1
		},
		c: interpolatorLinear$1,
		l: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	},
	difference: { h: differenceHueChroma$1 },
	average: { h: averageAngle$1 }
};
var definition_default$23$1 = {
	...definition_default$5$1,
	mode: "lch65",
	parse: ["--lch-d65"],
	serialize: "--lch-d65",
	toMode: {
		lab65: (c$1$1) => convertLchToLab_default$1(c$1$1, "lab65"),
		rgb: (c$1$1) => convertLab65ToRgb_default$1(convertLchToLab_default$1(c$1$1, "lab65"))
	},
	fromMode: {
		rgb: (c$1$1) => convertLabToLch_default$1(convertRgbToLab65_default$1(c$1$1), "lch65"),
		lab65: (c$1$1) => convertLabToLch_default$1(c$1$1, "lch65")
	},
	ranges: {
		l: [0, 100],
		c: [0, 150],
		h: [0, 360]
	}
};
var definition_default$6$1 = {
	...definition_default$12$1,
	mode: "lrgb",
	toMode: { rgb: convertLrgbToRgb_default$1 },
	fromMode: { rgb: convertRgbToLrgb_default$1 },
	parse: ["srgb-linear"],
	serialize: "srgb-linear"
};
const convertOklabToLrgb$1 = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let L = Math.pow(l + .3963377773761749 * a + .2158037573099136 * b, 3);
	let M$1$1 = Math.pow(l - .1055613458156586 * a - .0638541728258133 * b, 3);
	let S = Math.pow(l - .0894841775298119 * a - 1.2914855480194092 * b, 3);
	let res = {
		mode: "lrgb",
		r: 4.076741636075957 * L - 3.3077115392580616 * M$1$1 + .2309699031821044 * S,
		g: -1.2684379732850317 * L + 2.6097573492876887 * M$1$1 - .3413193760026573 * S,
		b: -.0041960761386756 * L - .7034186179359362 * M$1$1 + 1.7076146940746117 * S
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertOklabToLrgb_default$1 = convertOklabToLrgb$1;
const convertLrgbToOklab$1 = ({ r: r$1$1, g, b, alpha }) => {
	if (r$1$1 === void 0) r$1$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let L = Math.cbrt(.412221469470763 * r$1$1 + .5363325372617348 * g + .0514459932675022 * b);
	let M$1$1 = Math.cbrt(.2119034958178252 * r$1$1 + .6806995506452344 * g + .1073969535369406 * b);
	let S = Math.cbrt(.0883024591900564 * r$1$1 + .2817188391361215 * g + .6299787016738222 * b);
	let res = {
		mode: "oklab",
		l: .210454268309314 * L + .7936177747023054 * M$1$1 - .0040720430116193 * S,
		a: 1.9779985324311684 * L - 2.42859224204858 * M$1$1 + .450593709617411 * S,
		b: .0259040424655478 * L + .7827717124575296 * M$1$1 - .8086757549230774 * S
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLrgbToOklab_default$1 = convertLrgbToOklab$1;
const convertRgbToOklab$1 = (rgb$4) => {
	let res = convertLrgbToOklab_default$1(convertRgbToLrgb_default$1(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToOklab_default$1 = convertRgbToOklab$1;
const convertOklabToRgb$1 = (c$1$1) => convertLrgbToRgb_default$1(convertOklabToLrgb_default$1(c$1$1));
var convertOklabToRgb_default$1 = convertOklabToRgb$1;
function parseOklab$1(color, parsed) {
	if (!parsed || parsed[0] !== "oklab") return;
	const res = { mode: "oklab" };
	const [, l, a, b, alpha] = parsed;
	if (l.type === Tok$1.Hue || a.type === Tok$1.Hue || b.type === Tok$1.Hue) return;
	if (l.type !== Tok$1.None) res.l = Math.min(Math.max(0, l.type === Tok$1.Number ? l.value : l.value / 100), 1);
	if (a.type !== Tok$1.None) res.a = a.type === Tok$1.Number ? a.value : a.value * .4 / 100;
	if (b.type !== Tok$1.None) res.b = b.type === Tok$1.Number ? b.value : b.value * .4 / 100;
	if (alpha.type !== Tok$1.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok$1.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseOklab_default$1 = parseOklab$1;
var definition_default$7$1 = {
	...definition_default$3$1,
	mode: "oklab",
	toMode: {
		lrgb: convertOklabToLrgb_default$1,
		rgb: convertOklabToRgb_default$1
	},
	fromMode: {
		lrgb: convertLrgbToOklab_default$1,
		rgb: convertRgbToOklab_default$1
	},
	ranges: {
		l: [0, 1],
		a: [-.4, .4],
		b: [-.4, .4]
	},
	parse: [parseOklab_default$1],
	serialize: (c$1$1) => `oklab(${c$1$1.l !== void 0 ? c$1$1.l : "none"} ${c$1$1.a !== void 0 ? c$1$1.a : "none"} ${c$1$1.b !== void 0 ? c$1$1.b : "none"}${c$1$1.alpha < 1 ? ` / ${c$1$1.alpha}` : ""})`
};
function parseOklch$1(color, parsed) {
	if (!parsed || parsed[0] !== "oklch") return;
	const res = { mode: "oklch" };
	const [, l, c$1$1, h, alpha] = parsed;
	if (l.type !== Tok$1.None) {
		if (l.type === Tok$1.Hue) return;
		res.l = Math.min(Math.max(0, l.type === Tok$1.Number ? l.value : l.value / 100), 1);
	}
	if (c$1$1.type !== Tok$1.None) res.c = Math.max(0, c$1$1.type === Tok$1.Number ? c$1$1.value : c$1$1.value * .4 / 100);
	if (h.type !== Tok$1.None) {
		if (h.type === Tok$1.Percentage) return;
		res.h = h.value;
	}
	if (alpha.type !== Tok$1.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok$1.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseOklch_default$1 = parseOklch$1;
var definition_default$8$1 = {
	...definition_default$5$1,
	mode: "oklch",
	toMode: {
		oklab: (c$1$1) => convertLchToLab_default$1(c$1$1, "oklab"),
		rgb: (c$1$1) => convertOklabToRgb_default$1(convertLchToLab_default$1(c$1$1, "oklab"))
	},
	fromMode: {
		rgb: (c$1$1) => convertLabToLch_default$1(convertRgbToOklab_default$1(c$1$1), "oklch"),
		oklab: (c$1$1) => convertLabToLch_default$1(c$1$1, "oklch")
	},
	parse: [parseOklch_default$1],
	serialize: (c$1$1) => `oklch(${c$1$1.l !== void 0 ? c$1$1.l : "none"} ${c$1$1.c !== void 0 ? c$1$1.c : "none"} ${c$1$1.h !== void 0 ? c$1$1.h : "none"}${c$1$1.alpha < 1 ? ` / ${c$1$1.alpha}` : ""})`,
	ranges: {
		l: [0, 1],
		c: [0, .4],
		h: [0, 360]
	}
};
const convertP3ToXyz65$1 = (rgb$4) => {
	let { r: r$1$1, g, b, alpha } = convertRgbToLrgb_default$1(rgb$4);
	let res = {
		mode: "xyz65",
		x: .486570948648216 * r$1$1 + .265667693169093 * g + .1982172852343625 * b,
		y: .2289745640697487 * r$1$1 + .6917385218365062 * g + .079286914093745 * b,
		z: 0 * r$1$1 + .0451133818589026 * g + 1.043944368900976 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertP3ToXyz65_default$1 = convertP3ToXyz65$1;
const convertXyz65ToP3$1 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default$1({
		r: x * 2.4934969119414263 - y * .9313836179191242 - .402710784450717 * z,
		g: x * -.8294889695615749 + y * 1.7626640603183465 + .0236246858419436 * z,
		b: x * .0358458302437845 - y * .0761723892680418 + .9568845240076871 * z
	}, "p3");
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToP3_default$1 = convertXyz65ToP3$1;
var definition_default$9$1 = {
	...definition_default$12$1,
	mode: "p3",
	parse: ["display-p3"],
	serialize: "display-p3",
	fromMode: {
		rgb: (color) => convertXyz65ToP3_default$1(convertRgbToXyz65_default$1(color)),
		xyz65: convertXyz65ToP3_default$1
	},
	toMode: {
		rgb: (color) => convertXyz65ToRgb_default$1(convertP3ToXyz65_default$1(color)),
		xyz65: convertP3ToXyz65_default$1
	}
};
const gamma$1$1 = (v) => {
	let abs$1$1 = Math.abs(v);
	if (abs$1$1 >= 1 / 512) return Math.sign(v) * Math.pow(abs$1$1, 1 / 1.8);
	return 16 * v;
};
const convertXyz50ToProphoto$1 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "prophoto",
		r: gamma$1$1(x * 1.3457868816471585 - y * .2555720873797946 - .0511018649755453 * z),
		g: gamma$1$1(x * -.5446307051249019 + y * 1.5082477428451466 + .0205274474364214 * z),
		b: gamma$1$1(x * 0 + y * 0 + 1.2119675456389452 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToProphoto_default$1 = convertXyz50ToProphoto$1;
const linearize$1$1 = (v = 0) => {
	let abs$1$1 = Math.abs(v);
	if (abs$1$1 >= 16 / 512) return Math.sign(v) * Math.pow(abs$1$1, 1.8);
	return v / 16;
};
const convertProphotoToXyz50$1 = (prophoto$2) => {
	let r$1$1 = linearize$1$1(prophoto$2.r);
	let g = linearize$1$1(prophoto$2.g);
	let b = linearize$1$1(prophoto$2.b);
	let res = {
		mode: "xyz50",
		x: .7977666449006423 * r$1$1 + .1351812974005331 * g + .0313477341283922 * b,
		y: .2880748288194013 * r$1$1 + .7118352342418731 * g + 899369387256e-16 * b,
		z: 0 * r$1$1 + 0 * g + .8251046025104602 * b
	};
	if (prophoto$2.alpha !== void 0) res.alpha = prophoto$2.alpha;
	return res;
};
var convertProphotoToXyz50_default$1 = convertProphotoToXyz50$1;
var definition_default$10$1 = {
	...definition_default$12$1,
	mode: "prophoto",
	parse: ["prophoto-rgb"],
	serialize: "prophoto-rgb",
	fromMode: {
		xyz50: convertXyz50ToProphoto_default$1,
		rgb: (color) => convertXyz50ToProphoto_default$1(convertRgbToXyz50_default$1(color))
	},
	toMode: {
		xyz50: convertProphotoToXyz50_default$1,
		rgb: (color) => convertXyz50ToRgb_default$1(convertProphotoToXyz50_default$1(color))
	}
};
const α$1$1 = 1.09929682680944;
const β$1$1 = .018053968510807;
const gamma$3 = (v) => {
	const abs$1$1 = Math.abs(v);
	if (abs$1$1 > β$1$1) return (Math.sign(v) || 1) * (α$1$1 * Math.pow(abs$1$1, .45) - (α$1$1 - 1));
	return 4.5 * v;
};
const convertXyz65ToRec2020$1 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "rec2020",
		r: gamma$3(x * 1.7166511879712683 - y * .3556707837763925 - .2533662813736599 * z),
		g: gamma$3(x * -.6666843518324893 + y * 1.6164812366349395 + .0157685458139111 * z),
		b: gamma$3(x * .0176398574453108 - y * .0427706132578085 + .9421031212354739 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToRec2020_default$1 = convertXyz65ToRec2020$1;
const α$2 = 1.09929682680944;
const β$2 = .018053968510807;
const linearize$3 = (v = 0) => {
	let abs$1$1 = Math.abs(v);
	if (abs$1$1 < β$2 * 4.5) return v / 4.5;
	return (Math.sign(v) || 1) * Math.pow((abs$1$1 + α$2 - 1) / α$2, 1 / .45);
};
const convertRec2020ToXyz65$1 = (rec2020$2) => {
	let r$1$1 = linearize$3(rec2020$2.r);
	let g = linearize$3(rec2020$2.g);
	let b = linearize$3(rec2020$2.b);
	let res = {
		mode: "xyz65",
		x: .6369580483012911 * r$1$1 + .1446169035862083 * g + .1688809751641721 * b,
		y: .262700212011267 * r$1$1 + .6779980715188708 * g + .059301716469862 * b,
		z: 0 * r$1$1 + .0280726930490874 * g + 1.0609850577107909 * b
	};
	if (rec2020$2.alpha !== void 0) res.alpha = rec2020$2.alpha;
	return res;
};
var convertRec2020ToXyz65_default$1 = convertRec2020ToXyz65$1;
var definition_default$11$1 = {
	...definition_default$12$1,
	mode: "rec2020",
	fromMode: {
		xyz65: convertXyz65ToRec2020_default$1,
		rgb: (color) => convertXyz65ToRec2020_default$1(convertRgbToXyz65_default$1(color))
	},
	toMode: {
		xyz65: convertRec2020ToXyz65_default$1,
		rgb: (color) => convertXyz65ToRgb_default$1(convertRec2020ToXyz65_default$1(color))
	},
	parse: ["rec2020"],
	serialize: "rec2020"
};
var definition_default$13$1 = {
	mode: "xyz50",
	parse: ["xyz-d50"],
	serialize: "xyz-d50",
	toMode: {
		rgb: convertXyz50ToRgb_default$1,
		lab: convertXyz50ToLab_default$1
	},
	fromMode: {
		rgb: convertRgbToXyz50_default$1,
		lab: convertLabToXyz50_default$1
	},
	channels: [
		"x",
		"y",
		"z",
		"alpha"
	],
	ranges: {
		x: [0, .964],
		y: [0, .999],
		z: [0, .825]
	},
	interpolate: {
		x: interpolatorLinear$1,
		y: interpolatorLinear$1,
		z: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	}
};
const convertXyz65ToXyz50$1 = (xyz65$2) => {
	let { x, y, z, alpha } = xyz65$2;
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "xyz50",
		x: 1.0479298208405488 * x + .0229467933410191 * y - .0501922295431356 * z,
		y: .0296278156881593 * x + .990434484573249 * y - .0170738250293851 * z,
		z: -.0092430581525912 * x + .0150551448965779 * y + .7518742899580008 * z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToXyz50_default$1 = convertXyz65ToXyz50$1;
const convertXyz50ToXyz65$1 = (xyz50$2) => {
	let { x, y, z, alpha } = xyz50$2;
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "xyz65",
		x: .9554734527042182 * x - .0230985368742614 * y + .0632593086610217 * z,
		y: -.0283697069632081 * x + 1.0099954580058226 * y + .021041398966943 * z,
		z: .0123140016883199 * x - .0205076964334779 * y + 1.3303659366080753 * z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var definition_default$14$1 = {
	mode: "xyz65",
	toMode: {
		rgb: convertXyz65ToRgb_default$1,
		xyz50: convertXyz65ToXyz50_default$1
	},
	fromMode: {
		rgb: convertRgbToXyz65_default$1,
		xyz50: convertXyz50ToXyz65$1
	},
	ranges: {
		x: [0, .95],
		y: [0, 1],
		z: [0, 1.088]
	},
	channels: [
		"x",
		"y",
		"z",
		"alpha"
	],
	parse: ["xyz", "xyz-d65"],
	serialize: "xyz-d65",
	interpolate: {
		x: interpolatorLinear$1,
		y: interpolatorLinear$1,
		z: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	}
};
useMode$1(definition_default$28);
useMode$1(definition_default$1$1);
useMode$1(definition_default$19$1);
useMode$1(definition_default$2$1);
useMode$1(definition_default$3$1);
useMode$1(definition_default$4$1);
useMode$1(definition_default$5$1);
useMode$1(definition_default$23$1);
useMode$1(definition_default$6$1);
useMode$1(definition_default$7$1);
useMode$1(definition_default$8$1);
useMode$1(definition_default$9$1);
useMode$1(definition_default$10$1);
useMode$1(definition_default$11$1);
useMode$1(definition_default$12$1);
useMode$1(definition_default$13$1);
useMode$1(definition_default$14$1);
const M$1 = [
	-.14861,
	1.78277,
	-.29227,
	-.90649,
	1.97294,
	0
];
const degToRad$1 = Math.PI / 180;
const radToDeg$1 = 180 / Math.PI;
let DE$1 = M$1[3] * M$1[4];
let BE$1 = M$1[1] * M$1[4];
let BCAD$1 = M$1[1] * M$1[2] - M$1[0] * M$1[3];
const convertRgbToCubehelix$1 = ({ r: r$1$1, g, b, alpha }) => {
	if (r$1$1 === void 0) r$1$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let l = (BCAD$1 * b + r$1$1 * DE$1 - g * BE$1) / (BCAD$1 + DE$1 - BE$1);
	let x = b - l;
	let y = (M$1[4] * (g - l) - M$1[2] * x) / M$1[3];
	let res = {
		mode: "cubehelix",
		l,
		s: l === 0 || l === 1 ? void 0 : Math.sqrt(x * x + y * y) / (M$1[4] * l * (1 - l))
	};
	if (res.s) res.h = Math.atan2(y, x) * radToDeg$1 - 120;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToCubehelix_default$1 = convertRgbToCubehelix$1;
const convertCubehelixToRgb$1 = ({ h, s, l, alpha }) => {
	let res = { mode: "rgb" };
	h = (h === void 0 ? 0 : h + 120) * degToRad$1;
	if (l === void 0) l = 0;
	let amp = s === void 0 ? 0 : s * l * (1 - l);
	let cosh = Math.cos(h);
	let sinh = Math.sin(h);
	res.r = l + amp * (M$1[0] * cosh + M$1[1] * sinh);
	res.g = l + amp * (M$1[2] * cosh + M$1[3] * sinh);
	res.b = l + amp * (M$1[4] * cosh + M$1[5] * sinh);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var definition_default$15$1 = {
	mode: "cubehelix",
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	parse: ["--cubehelix"],
	serialize: "--cubehelix",
	ranges: {
		h: [0, 360],
		s: [0, 4.614],
		l: [0, 1]
	},
	fromMode: { rgb: convertRgbToCubehelix_default$1 },
	toMode: { rgb: convertCubehelixToRgb$1 },
	interpolate: {
		h: {
			use: interpolatorLinear$1,
			fixup: fixupHueShorter$1
		},
		s: interpolatorLinear$1,
		l: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	},
	difference: { h: differenceHueSaturation$1 },
	average: { h: averageAngle$1 }
};
const kE$1 = 1;
const kCH$1 = 1;
const θ$1 = 26 / 180 * Math.PI;
const cosθ$1 = Math.cos(θ$1);
const sinθ$1 = Math.sin(θ$1);
const factor$1 = 100 / Math.log(139 / 100);
const convertDlchToLab65$1 = ({ l, c: c$1$1, h, alpha }) => {
	if (l === void 0) l = 0;
	if (c$1$1 === void 0) c$1$1 = 0;
	if (h === void 0) h = 0;
	let res = {
		mode: "lab65",
		l: (Math.exp(l * kE$1 / factor$1) - 1) / .0039
	};
	let G = (Math.exp(.0435 * c$1$1 * kCH$1 * kE$1) - 1) / .075;
	let e$3$1 = G * Math.cos(h / 180 * Math.PI - θ$1);
	let f$2$1 = G * Math.sin(h / 180 * Math.PI - θ$1);
	res.a = e$3$1 * cosθ$1 - f$2$1 / .83 * sinθ$1;
	res.b = e$3$1 * sinθ$1 + f$2$1 / .83 * cosθ$1;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertDlchToLab65_default$1 = convertDlchToLab65$1;
const convertLab65ToDlch$1 = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let e$3$1 = a * cosθ$1 + b * sinθ$1;
	let f$2$1 = .83 * (b * cosθ$1 - a * sinθ$1);
	let G = Math.sqrt(e$3$1 * e$3$1 + f$2$1 * f$2$1);
	let res = {
		mode: "dlch",
		l: factor$1 / kE$1 * Math.log(1 + .0039 * l),
		c: Math.log(1 + .075 * G) / (.0435 * kCH$1 * kE$1)
	};
	if (res.c) res.h = normalizeHue_default$1((Math.atan2(f$2$1, e$3$1) + θ$1) / Math.PI * 180);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLab65ToDlch_default$1 = convertLab65ToDlch$1;
const convertDlabToLab65$1 = (c$1$1) => convertDlchToLab65_default$1(convertLabToLch_default$1(c$1$1, "dlch"));
const convertLab65ToDlab$1 = (c$1$1) => convertLchToLab_default$1(convertLab65ToDlch_default$1(c$1$1), "dlab");
var definition_default$16$1 = {
	mode: "dlab",
	parse: ["--din99o-lab"],
	serialize: "--din99o-lab",
	toMode: {
		lab65: convertDlabToLab65$1,
		rgb: (c$1$1) => convertLab65ToRgb_default$1(convertDlabToLab65$1(c$1$1))
	},
	fromMode: {
		lab65: convertLab65ToDlab$1,
		rgb: (c$1$1) => convertLab65ToDlab$1(convertRgbToLab65_default$1(c$1$1))
	},
	channels: [
		"l",
		"a",
		"b",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		a: [-40.09, 45.501],
		b: [-40.469, 44.344]
	},
	interpolate: {
		l: interpolatorLinear$1,
		a: interpolatorLinear$1,
		b: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	}
};
var definition_default$17$1 = {
	mode: "dlch",
	parse: ["--din99o-lch"],
	serialize: "--din99o-lch",
	toMode: {
		lab65: convertDlchToLab65_default$1,
		dlab: (c$1$1) => convertLchToLab_default$1(c$1$1, "dlab"),
		rgb: (c$1$1) => convertLab65ToRgb_default$1(convertDlchToLab65_default$1(c$1$1))
	},
	fromMode: {
		lab65: convertLab65ToDlch_default$1,
		dlab: (c$1$1) => convertLabToLch_default$1(c$1$1, "dlch"),
		rgb: (c$1$1) => convertLab65ToDlch_default$1(convertRgbToLab65_default$1(c$1$1))
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		c: [0, 51.484],
		h: [0, 360]
	},
	interpolate: {
		l: interpolatorLinear$1,
		c: interpolatorLinear$1,
		h: {
			use: interpolatorLinear$1,
			fixup: fixupHueShorter$1
		},
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	},
	difference: { h: differenceHueChroma$1 },
	average: { h: averageAngle$1 }
};
function convertHsiToRgb$1({ h, s, i, alpha }) {
	h = normalizeHue_default$1(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (i === void 0) i = 0;
	let f$2$1 = Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: i * (1 + s * (3 / (2 - f$2$1) - 1)),
				g: i * (1 + s * (3 * (1 - f$2$1) / (2 - f$2$1) - 1)),
				b: i * (1 - s)
			};
			break;
		case 1:
			res = {
				r: i * (1 + s * (3 * (1 - f$2$1) / (2 - f$2$1) - 1)),
				g: i * (1 + s * (3 / (2 - f$2$1) - 1)),
				b: i * (1 - s)
			};
			break;
		case 2:
			res = {
				r: i * (1 - s),
				g: i * (1 + s * (3 / (2 - f$2$1) - 1)),
				b: i * (1 + s * (3 * (1 - f$2$1) / (2 - f$2$1) - 1))
			};
			break;
		case 3:
			res = {
				r: i * (1 - s),
				g: i * (1 + s * (3 * (1 - f$2$1) / (2 - f$2$1) - 1)),
				b: i * (1 + s * (3 / (2 - f$2$1) - 1))
			};
			break;
		case 4:
			res = {
				r: i * (1 + s * (3 * (1 - f$2$1) / (2 - f$2$1) - 1)),
				g: i * (1 - s),
				b: i * (1 + s * (3 / (2 - f$2$1) - 1))
			};
			break;
		case 5:
			res = {
				r: i * (1 + s * (3 / (2 - f$2$1) - 1)),
				g: i * (1 - s),
				b: i * (1 + s * (3 * (1 - f$2$1) / (2 - f$2$1) - 1))
			};
			break;
		default: res = {
			r: i * (1 - s),
			g: i * (1 - s),
			b: i * (1 - s)
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}
function convertRgbToHsi$1({ r: r$1$1, g, b, alpha }) {
	if (r$1$1 === void 0) r$1$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$1$1 = Math.max(r$1$1, g, b), m = Math.min(r$1$1, g, b);
	let res = {
		mode: "hsi",
		s: r$1$1 + g + b === 0 ? 0 : 1 - 3 * m / (r$1$1 + g + b),
		i: (r$1$1 + g + b) / 3
	};
	if (M$1$1 - m !== 0) res.h = (M$1$1 === r$1$1 ? (g - b) / (M$1$1 - m) + (g < b) * 6 : M$1$1 === g ? (b - r$1$1) / (M$1$1 - m) + 2 : (r$1$1 - g) / (M$1$1 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}
var definition_default$18$1 = {
	mode: "hsi",
	toMode: { rgb: convertHsiToRgb$1 },
	parse: ["--hsi"],
	serialize: "--hsi",
	fromMode: { rgb: convertRgbToHsi$1 },
	channels: [
		"h",
		"s",
		"i",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	interpolate: {
		h: {
			use: interpolatorLinear$1,
			fixup: fixupHueShorter$1
		},
		s: interpolatorLinear$1,
		i: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	},
	difference: { h: differenceHueSaturation$1 },
	average: { h: averageAngle$1 }
};
const YW$1 = 203;
const M1$1 = .1593017578125;
const M2$1 = 78.84375;
const C1$1 = .8359375;
const C2$1 = 18.8515625;
const C3$1 = 18.6875;
function transferPqDecode$1(v) {
	if (v < 0) return 0;
	const c$1$1 = Math.pow(v, 1 / M2$1);
	return 1e4 * Math.pow(Math.max(0, c$1$1 - C1$1) / (C2$1 - C3$1 * c$1$1), 1 / M1$1);
}
function transferPqEncode$1(v) {
	if (v < 0) return 0;
	const c$1$1 = Math.pow(v / 1e4, M1$1);
	return Math.pow((C1$1 + C2$1 * c$1$1) / (1 + C3$1 * c$1$1), M2$1);
}
const toRel$1 = (c$1$1) => Math.max(c$1$1 / YW$1, 0);
const convertItpToXyz65$1 = ({ i, t, p: p$2$1, alpha }) => {
	if (i === void 0) i = 0;
	if (t === void 0) t = 0;
	if (p$2$1 === void 0) p$2$1 = 0;
	const l = transferPqDecode$1(i + .008609037037932761 * t + .11102962500302593 * p$2$1);
	const m = transferPqDecode$1(i - .00860903703793275 * t - .11102962500302599 * p$2$1);
	const s = transferPqDecode$1(i + .5600313357106791 * t - .32062717498731885 * p$2$1);
	const res = {
		mode: "xyz65",
		x: toRel$1(2.070152218389422 * l - 1.3263473389671556 * m + .2066510476294051 * s),
		y: toRel$1(.3647385209748074 * l + .680566024947227 * m - .0453045459220346 * s),
		z: toRel$1(-.049747207535812 * l - .0492609666966138 * m + 1.1880659249923042 * s)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertItpToXyz65_default$1 = convertItpToXyz65$1;
const toAbs$1 = (c$1$1 = 0) => Math.max(c$1$1 * YW$1, 0);
const convertXyz65ToItp$1 = ({ x, y, z, alpha }) => {
	const absX = toAbs$1(x);
	const absY = toAbs$1(y);
	const absZ = toAbs$1(z);
	const l = transferPqEncode$1(.3592832590121217 * absX + .6976051147779502 * absY - .0358915932320289 * absZ);
	const m = transferPqEncode$1(-.1920808463704995 * absX + 1.1004767970374323 * absY + .0753748658519118 * absZ);
	const s = transferPqEncode$1(.0070797844607477 * absX + .0748396662186366 * absY + .8433265453898765 * absZ);
	const i = .5 * l + .5 * m;
	const t = 1.61376953125 * l - 3.323486328125 * m + 1.709716796875 * s;
	const p$2$1 = 4.378173828125 * l - 4.24560546875 * m - .132568359375 * s;
	const res = {
		mode: "itp",
		i,
		t,
		p: p$2$1
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToItp_default$1 = convertXyz65ToItp$1;
var definition_default$20$1 = {
	mode: "itp",
	channels: [
		"i",
		"t",
		"p",
		"alpha"
	],
	parse: ["--ictcp"],
	serialize: "--ictcp",
	toMode: {
		xyz65: convertItpToXyz65_default$1,
		rgb: (color) => convertXyz65ToRgb_default$1(convertItpToXyz65_default$1(color))
	},
	fromMode: {
		xyz65: convertXyz65ToItp_default$1,
		rgb: (color) => convertXyz65ToItp_default$1(convertRgbToXyz65_default$1(color))
	},
	ranges: {
		i: [0, .581],
		t: [-.369, .272],
		p: [-.164, .331]
	},
	interpolate: {
		i: interpolatorLinear$1,
		t: interpolatorLinear$1,
		p: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	}
};
const p$1$1 = 134.03437499999998;
const d0$1$1 = 16295499532821565e-27;
const jabPqEncode$1 = (v) => {
	if (v < 0) return 0;
	let vn$2$1 = Math.pow(v / 1e4, M1$1);
	return Math.pow((C1$1 + C2$1 * vn$2$1) / (1 + C3$1 * vn$2$1), p$1$1);
};
const abs$1 = (v = 0) => Math.max(v * 203, 0);
const convertXyz65ToJab$1 = ({ x, y, z, alpha }) => {
	x = abs$1(x);
	y = abs$1(y);
	z = abs$1(z);
	let xp = 1.15 * x - .15 * z;
	let yp = .66 * y + .34 * x;
	let l = jabPqEncode$1(.41478972 * xp + .579999 * yp + .014648 * z);
	let m = jabPqEncode$1(-.20151 * xp + 1.120649 * yp + .0531008 * z);
	let s = jabPqEncode$1(-.0166008 * xp + .2648 * yp + .6684799 * z);
	let i = (l + m) / 2;
	let res = {
		mode: "jab",
		j: .44 * i / (1 - .56 * i) - d0$1$1,
		a: 3.524 * l - 4.066708 * m + .542708 * s,
		b: .199076 * l + 1.096799 * m - 1.295875 * s
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToJab_default$1 = convertXyz65ToJab$1;
const p$2 = 134.03437499999998;
const d0$2 = 16295499532821565e-27;
const jabPqDecode$1 = (v) => {
	if (v < 0) return 0;
	let vp = Math.pow(v, 1 / p$2);
	return 1e4 * Math.pow((C1$1 - vp) / (C3$1 * vp - C2$1), 1 / M1$1);
};
const rel$1 = (v) => v / 203;
const convertJabToXyz65$1 = ({ j, a, b, alpha }) => {
	if (j === void 0) j = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let i = (j + d0$2) / (.44 + .56 * (j + d0$2));
	let l = jabPqDecode$1(i + .13860504 * a + .058047316 * b);
	let m = jabPqDecode$1(i - .13860504 * a - .058047316 * b);
	let s = jabPqDecode$1(i - .096019242 * a - .8118919 * b);
	let res = {
		mode: "xyz65",
		x: rel$1(1.661373024652174 * l - .914523081304348 * m + .23136208173913045 * s),
		y: rel$1(-.3250758611844533 * l + 1.571847026732543 * m - .21825383453227928 * s),
		z: rel$1(-.090982811 * l - .31272829 * m + 1.5227666 * s)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJabToXyz65_default$1 = convertJabToXyz65$1;
const convertRgbToJab$1 = (rgb$4) => {
	let res = convertXyz65ToJab_default$1(convertRgbToXyz65_default$1(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToJab_default$1 = convertRgbToJab$1;
const convertJabToRgb$1 = (color) => convertXyz65ToRgb_default$1(convertJabToXyz65_default$1(color));
var convertJabToRgb_default$1 = convertJabToRgb$1;
var definition_default$21$1 = {
	mode: "jab",
	channels: [
		"j",
		"a",
		"b",
		"alpha"
	],
	parse: ["--jzazbz"],
	serialize: "--jzazbz",
	fromMode: {
		rgb: convertRgbToJab_default$1,
		xyz65: convertXyz65ToJab_default$1
	},
	toMode: {
		rgb: convertJabToRgb_default$1,
		xyz65: convertJabToXyz65_default$1
	},
	ranges: {
		j: [0, .222],
		a: [-.109, .129],
		b: [-.185, .134]
	},
	interpolate: {
		j: interpolatorLinear$1,
		a: interpolatorLinear$1,
		b: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	}
};
const convertJabToJch$1 = ({ j, a, b, alpha }) => {
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let c$1$1 = Math.sqrt(a * a + b * b);
	let res = {
		mode: "jch",
		j,
		c: c$1$1
	};
	if (c$1$1) res.h = normalizeHue_default$1(Math.atan2(b, a) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJabToJch_default$1 = convertJabToJch$1;
const convertJchToJab$1 = ({ j, c: c$1$1, h, alpha }) => {
	if (h === void 0) h = 0;
	let res = {
		mode: "jab",
		j,
		a: c$1$1 ? c$1$1 * Math.cos(h / 180 * Math.PI) : 0,
		b: c$1$1 ? c$1$1 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJchToJab_default$1 = convertJchToJab$1;
var definition_default$22$1 = {
	mode: "jch",
	parse: ["--jzczhz"],
	serialize: "--jzczhz",
	toMode: {
		jab: convertJchToJab_default$1,
		rgb: (c$1$1) => convertJabToRgb_default$1(convertJchToJab_default$1(c$1$1))
	},
	fromMode: {
		rgb: (c$1$1) => convertJabToJch_default$1(convertRgbToJab_default$1(c$1$1)),
		jab: convertJabToJch_default$1
	},
	channels: [
		"j",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		j: [0, .221],
		c: [0, .19],
		h: [0, 360]
	},
	interpolate: {
		h: {
			use: interpolatorLinear$1,
			fixup: fixupHueShorter$1
		},
		c: interpolatorLinear$1,
		j: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	},
	difference: { h: differenceHueChroma$1 },
	average: { h: averageAngle$1 }
};
const convertLuvToLchuv$1 = ({ l, u, v, alpha }) => {
	if (u === void 0) u = 0;
	if (v === void 0) v = 0;
	let c$1$1 = Math.sqrt(u * u + v * v);
	let res = {
		mode: "lchuv",
		l,
		c: c$1$1
	};
	if (c$1$1) res.h = normalizeHue_default$1(Math.atan2(v, u) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLuvToLchuv_default$1 = convertLuvToLchuv$1;
const convertLchuvToLuv$1 = ({ l, c: c$1$1, h, alpha }) => {
	if (h === void 0) h = 0;
	let res = {
		mode: "luv",
		l,
		u: c$1$1 ? c$1$1 * Math.cos(h / 180 * Math.PI) : 0,
		v: c$1$1 ? c$1$1 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLchuvToLuv_default$1 = convertLchuvToLuv$1;
const u_fn$1$1 = (x, y, z) => 4 * x / (x + 15 * y + 3 * z);
const v_fn$1$1 = (x, y, z) => 9 * y / (x + 15 * y + 3 * z);
const un$1$1 = u_fn$1$1(D50$1.X, D50$1.Y, D50$1.Z);
const vn$1$1 = v_fn$1$1(D50$1.X, D50$1.Y, D50$1.Z);
const l_fn$1 = (value) => value <= e$3 ? k$3 * value : 116 * Math.cbrt(value) - 16;
const convertXyz50ToLuv$1 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let l = l_fn$1(y / D50$1.Y);
	let u = u_fn$1$1(x, y, z);
	let v = v_fn$1$1(x, y, z);
	if (!isFinite(u) || !isFinite(v)) l = u = v = 0;
	else {
		u = 13 * l * (u - un$1$1);
		v = 13 * l * (v - vn$1$1);
	}
	let res = {
		mode: "luv",
		l,
		u,
		v
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToLuv_default$1 = convertXyz50ToLuv$1;
const u_fn$2 = (x, y, z) => 4 * x / (x + 15 * y + 3 * z);
const v_fn$2 = (x, y, z) => 9 * y / (x + 15 * y + 3 * z);
const un$2 = u_fn$2(D50$1.X, D50$1.Y, D50$1.Z);
const vn$2 = v_fn$2(D50$1.X, D50$1.Y, D50$1.Z);
const convertLuvToXyz50$1 = ({ l, u, v, alpha }) => {
	if (l === void 0) l = 0;
	if (l === 0) return {
		mode: "xyz50",
		x: 0,
		y: 0,
		z: 0
	};
	if (u === void 0) u = 0;
	if (v === void 0) v = 0;
	let up = u / (13 * l) + un$2;
	let vp = v / (13 * l) + vn$2;
	let y = D50$1.Y * (l <= 8 ? l / k$3 : Math.pow((l + 16) / 116, 3));
	let x = y * (9 * up) / (4 * vp);
	let z = y * (12 - 3 * up - 20 * vp) / (4 * vp);
	let res = {
		mode: "xyz50",
		x,
		y,
		z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLuvToXyz50_default$1 = convertLuvToXyz50$1;
const convertRgbToLchuv$1 = (rgb$4) => convertLuvToLchuv_default$1(convertXyz50ToLuv_default$1(convertRgbToXyz50_default$1(rgb$4)));
const convertLchuvToRgb$1 = (lchuv$1) => convertXyz50ToRgb_default$1(convertLuvToXyz50_default$1(convertLchuvToLuv_default$1(lchuv$1)));
var definition_default$24$1 = {
	mode: "lchuv",
	toMode: {
		luv: convertLchuvToLuv_default$1,
		rgb: convertLchuvToRgb$1
	},
	fromMode: {
		rgb: convertRgbToLchuv$1,
		luv: convertLuvToLchuv_default$1
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	parse: ["--lchuv"],
	serialize: "--lchuv",
	ranges: {
		l: [0, 100],
		c: [0, 176.956],
		h: [0, 360]
	},
	interpolate: {
		h: {
			use: interpolatorLinear$1,
			fixup: fixupHueShorter$1
		},
		c: interpolatorLinear$1,
		l: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	},
	difference: { h: differenceHueChroma$1 },
	average: { h: averageAngle$1 }
};
var definition_default$25$1 = {
	mode: "luv",
	toMode: {
		xyz50: convertLuvToXyz50_default$1,
		rgb: (luv$1) => convertXyz50ToRgb_default$1(convertLuvToXyz50_default$1(luv$1))
	},
	fromMode: {
		xyz50: convertXyz50ToLuv_default$1,
		rgb: (rgb$4) => convertXyz50ToLuv_default$1(convertRgbToXyz50_default$1(rgb$4))
	},
	channels: [
		"l",
		"u",
		"v",
		"alpha"
	],
	parse: ["--luv"],
	serialize: "--luv",
	ranges: {
		l: [0, 100],
		u: [-84.936, 175.042],
		v: [-125.882, 87.243]
	},
	interpolate: {
		l: interpolatorLinear$1,
		u: interpolatorLinear$1,
		v: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	}
};
function toe$1(x) {
	const k_1 = .206;
	const k_2 = .03;
	const k_3 = (1 + k_1) / (1 + k_2);
	return .5 * (k_3 * x - k_1 + Math.sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4 * k_2 * k_3 * x));
}
function toe_inv$1(x) {
	const k_1 = .206;
	const k_2 = .03;
	const k_3 = (1 + k_1) / (1 + k_2);
	return (x * x + k_1 * x) / (k_3 * (x + k_2));
}
function compute_max_saturation$1(a, b) {
	let k0, k1, k2, k3, k4, wl, wm, ws;
	if (-1.88170328 * a - .80936493 * b > 1) {
		k0 = 1.19086277;
		k1 = 1.76576728;
		k2 = .59662641;
		k3 = .75515197;
		k4 = .56771245;
		wl = 4.0767416621;
		wm = -3.3077115913;
		ws = .2309699292;
	} else if (1.81444104 * a - 1.19445276 * b > 1) {
		k0 = .73956515;
		k1 = -.45954404;
		k2 = .08285427;
		k3 = .1254107;
		k4 = .14503204;
		wl = -1.2684380046;
		wm = 2.6097574011;
		ws = -.3413193965;
	} else {
		k0 = 1.35733652;
		k1 = -.00915799;
		k2 = -1.1513021;
		k3 = -.50559606;
		k4 = .00692167;
		wl = -.0041960863;
		wm = -.7034186147;
		ws = 1.707614701;
	}
	let S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;
	let k_l = .3963377774 * a + .2158037573 * b;
	let k_m = -.1055613458 * a - .0638541728 * b;
	let k_s = -.0894841775 * a - 1.291485548 * b;
	{
		let l_ = 1 + S * k_l;
		let m_ = 1 + S * k_m;
		let s_ = 1 + S * k_s;
		let l = l_ * l_ * l_;
		let m = m_ * m_ * m_;
		let s = s_ * s_ * s_;
		let l_dS = 3 * k_l * l_ * l_;
		let m_dS = 3 * k_m * m_ * m_;
		let s_dS = 3 * k_s * s_ * s_;
		let l_dS2 = 6 * k_l * k_l * l_;
		let m_dS2 = 6 * k_m * k_m * m_;
		let s_dS2 = 6 * k_s * k_s * s_;
		let f$2$1 = wl * l + wm * m + ws * s;
		let f1 = wl * l_dS + wm * m_dS + ws * s_dS;
		let f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;
		S = S - f$2$1 * f1 / (f1 * f1 - .5 * f$2$1 * f2);
	}
	return S;
}
function find_cusp$1(a, b) {
	let S_cusp = compute_max_saturation$1(a, b);
	let rgb$4 = convertOklabToLrgb_default$1({
		l: 1,
		a: S_cusp * a,
		b: S_cusp * b
	});
	let L_cusp = Math.cbrt(1 / Math.max(rgb$4.r, rgb$4.g, rgb$4.b));
	let C_cusp = L_cusp * S_cusp;
	return [L_cusp, C_cusp];
}
function find_gamut_intersection$1(a, b, L1, C1$1$1, L0, cusp = null) {
	if (!cusp) cusp = find_cusp$1(a, b);
	let t;
	if ((L1 - L0) * cusp[1] - (cusp[0] - L0) * C1$1$1 <= 0) t = cusp[1] * L0 / (C1$1$1 * cusp[0] + cusp[1] * (L0 - L1));
	else {
		t = cusp[1] * (L0 - 1) / (C1$1$1 * (cusp[0] - 1) + cusp[1] * (L0 - L1));
		{
			let dL = L1 - L0;
			let dC = C1$1$1;
			let k_l = .3963377774 * a + .2158037573 * b;
			let k_m = -.1055613458 * a - .0638541728 * b;
			let k_s = -.0894841775 * a - 1.291485548 * b;
			let l_dt = dL + dC * k_l;
			let m_dt = dL + dC * k_m;
			let s_dt = dL + dC * k_s;
			{
				let L = L0 * (1 - t) + t * L1;
				let C = t * C1$1$1;
				let l_ = L + C * k_l;
				let m_ = L + C * k_m;
				let s_ = L + C * k_s;
				let l = l_ * l_ * l_;
				let m = m_ * m_ * m_;
				let s = s_ * s_ * s_;
				let ldt = 3 * l_dt * l_ * l_;
				let mdt = 3 * m_dt * m_ * m_;
				let sdt = 3 * s_dt * s_ * s_;
				let ldt2 = 6 * l_dt * l_dt * l_;
				let mdt2 = 6 * m_dt * m_dt * m_;
				let sdt2 = 6 * s_dt * s_dt * s_;
				let r$1$1 = 4.0767416621 * l - 3.3077115913 * m + .2309699292 * s - 1;
				let r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + .2309699292 * sdt;
				let r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + .2309699292 * sdt2;
				let u_r = r1 / (r1 * r1 - .5 * r$1$1 * r2);
				let t_r = -r$1$1 * u_r;
				let g = -1.2684380046 * l + 2.6097574011 * m - .3413193965 * s - 1;
				let g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - .3413193965 * sdt;
				let g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - .3413193965 * sdt2;
				let u_g = g1 / (g1 * g1 - .5 * g * g2);
				let t_g = -g * u_g;
				let b$1 = -.0041960863 * l - .7034186147 * m + 1.707614701 * s - 1;
				let b1 = -.0041960863 * ldt - .7034186147 * mdt + 1.707614701 * sdt;
				let b2 = -.0041960863 * ldt2 - .7034186147 * mdt2 + 1.707614701 * sdt2;
				let u_b = b1 / (b1 * b1 - .5 * b$1 * b2);
				let t_b = -b$1 * u_b;
				t_r = u_r >= 0 ? t_r : 1e6;
				t_g = u_g >= 0 ? t_g : 1e6;
				t_b = u_b >= 0 ? t_b : 1e6;
				t += Math.min(t_r, Math.min(t_g, t_b));
			}
		}
	}
	return t;
}
function get_ST_max$1(a_, b_, cusp = null) {
	if (!cusp) cusp = find_cusp$1(a_, b_);
	let L = cusp[0];
	let C = cusp[1];
	return [C / L, C / (1 - L)];
}
function get_Cs$1(L, a_, b_) {
	let cusp = find_cusp$1(a_, b_);
	let C_max = find_gamut_intersection$1(a_, b_, L, 1, L, cusp);
	let ST_max = get_ST_max$1(a_, b_, cusp);
	let S_mid = .11516993 + 1 / (7.4477897 + 4.1590124 * b_ + a_ * (-2.19557347 + 1.75198401 * b_ + a_ * (-2.13704948 - 10.02301043 * b_ + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_))));
	let T_mid = .11239642 + 1 / (1.6132032 - .68124379 * b_ + a_ * (.40370612 + .90148123 * b_ + a_ * (-.27087943 + .6122399 * b_ + a_ * (.00299215 - .45399568 * b_ - .14661872 * a_))));
	let k$3$1 = C_max / Math.min(L * ST_max[0], (1 - L) * ST_max[1]);
	let C_a = L * S_mid;
	let C_b = (1 - L) * T_mid;
	let C_mid = .9 * k$3$1 * Math.sqrt(Math.sqrt(1 / (1 / (C_a * C_a * C_a * C_a) + 1 / (C_b * C_b * C_b * C_b))));
	C_a = L * .4;
	C_b = (1 - L) * .8;
	return [
		Math.sqrt(1 / (1 / (C_a * C_a) + 1 / (C_b * C_b))),
		C_mid,
		C_max
	];
}
function convertOklabToOkhsl$1(lab$2) {
	const l = lab$2.l !== void 0 ? lab$2.l : 0;
	const a = lab$2.a !== void 0 ? lab$2.a : 0;
	const b = lab$2.b !== void 0 ? lab$2.b : 0;
	const ret = {
		mode: "okhsl",
		l: toe$1(l)
	};
	if (lab$2.alpha !== void 0) ret.alpha = lab$2.alpha;
	let c$1$1 = Math.sqrt(a * a + b * b);
	if (!c$1$1) {
		ret.s = 0;
		return ret;
	}
	let [C_0, C_mid, C_max] = get_Cs$1(l, a / c$1$1, b / c$1$1);
	let s;
	if (c$1$1 < C_mid) {
		let k_0 = 0;
		let k_1 = .8 * C_0;
		let k_2 = 1 - k_1 / C_mid;
		s = (c$1$1 - k_0) / (k_1 + k_2 * (c$1$1 - k_0)) * .8;
	} else {
		let k_0 = C_mid;
		let k_1 = .2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
		let k_2 = 1 - k_1 / (C_max - C_mid);
		s = .8 + .2 * ((c$1$1 - k_0) / (k_1 + k_2 * (c$1$1 - k_0)));
	}
	if (s) {
		ret.s = s;
		ret.h = normalizeHue_default$1(Math.atan2(b, a) * 180 / Math.PI);
	}
	return ret;
}
function convertOkhslToOklab$1(hsl$3) {
	let h = hsl$3.h !== void 0 ? hsl$3.h : 0;
	let s = hsl$3.s !== void 0 ? hsl$3.s : 0;
	let l = hsl$3.l !== void 0 ? hsl$3.l : 0;
	const ret = {
		mode: "oklab",
		l: toe_inv$1(l)
	};
	if (hsl$3.alpha !== void 0) ret.alpha = hsl$3.alpha;
	if (!s || l === 1) {
		ret.a = ret.b = 0;
		return ret;
	}
	let a_ = Math.cos(h / 180 * Math.PI);
	let b_ = Math.sin(h / 180 * Math.PI);
	let [C_0, C_mid, C_max] = get_Cs$1(ret.l, a_, b_);
	let t, k_0, k_1, k_2;
	if (s < .8) {
		t = 1.25 * s;
		k_0 = 0;
		k_1 = .8 * C_0;
		k_2 = 1 - k_1 / C_mid;
	} else {
		t = 5 * (s - .8);
		k_0 = C_mid;
		k_1 = .2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
		k_2 = 1 - k_1 / (C_max - C_mid);
	}
	let C = k_0 + t * k_1 / (1 - k_2 * t);
	ret.a = C * a_;
	ret.b = C * b_;
	return ret;
}
var modeOkhsl_default$1 = {
	...definition_default$1$1,
	mode: "okhsl",
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	parse: ["--okhsl"],
	serialize: "--okhsl",
	fromMode: {
		oklab: convertOklabToOkhsl$1,
		rgb: (c$1$1) => convertOklabToOkhsl$1(convertRgbToOklab_default$1(c$1$1))
	},
	toMode: {
		oklab: convertOkhslToOklab$1,
		rgb: (c$1$1) => convertOklabToRgb_default$1(convertOkhslToOklab$1(c$1$1))
	}
};
function convertOklabToOkhsv$1(lab$2) {
	let l = lab$2.l !== void 0 ? lab$2.l : 0;
	let a = lab$2.a !== void 0 ? lab$2.a : 0;
	let b = lab$2.b !== void 0 ? lab$2.b : 0;
	let c$1$1 = Math.sqrt(a * a + b * b);
	let a_ = c$1$1 ? a / c$1$1 : 1;
	let b_ = c$1$1 ? b / c$1$1 : 1;
	let [S_max, T] = get_ST_max$1(a_, b_);
	let S_0 = .5;
	let k$3$1 = 1 - S_0 / S_max;
	let t = T / (c$1$1 + l * T);
	let L_v = t * l;
	let C_v = t * c$1$1;
	let L_vt = toe_inv$1(L_v);
	let C_vt = C_v * L_vt / L_v;
	let rgb_scale = convertOklabToLrgb_default$1({
		l: L_vt,
		a: a_ * C_vt,
		b: b_ * C_vt
	});
	let scale_L = Math.cbrt(1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0));
	l = l / scale_L;
	c$1$1 = c$1$1 / scale_L * toe$1(l) / l;
	l = toe$1(l);
	const ret = {
		mode: "okhsv",
		s: c$1$1 ? (S_0 + T) * C_v / (T * S_0 + T * k$3$1 * C_v) : 0,
		v: l ? l / L_v : 0
	};
	if (ret.s) ret.h = normalizeHue_default$1(Math.atan2(b, a) * 180 / Math.PI);
	if (lab$2.alpha !== void 0) ret.alpha = lab$2.alpha;
	return ret;
}
function convertOkhsvToOklab$1(hsv$2) {
	const ret = { mode: "oklab" };
	if (hsv$2.alpha !== void 0) ret.alpha = hsv$2.alpha;
	const h = hsv$2.h !== void 0 ? hsv$2.h : 0;
	const s = hsv$2.s !== void 0 ? hsv$2.s : 0;
	const v = hsv$2.v !== void 0 ? hsv$2.v : 0;
	const a_ = Math.cos(h / 180 * Math.PI);
	const b_ = Math.sin(h / 180 * Math.PI);
	const [S_max, T] = get_ST_max$1(a_, b_);
	const S_0 = .5;
	const k$3$1 = 1 - S_0 / S_max;
	const L_v = 1 - s * S_0 / (S_0 + T - T * k$3$1 * s);
	const C_v = s * T * S_0 / (S_0 + T - T * k$3$1 * s);
	const L_vt = toe_inv$1(L_v);
	const C_vt = C_v * L_vt / L_v;
	const rgb_scale = convertOklabToLrgb_default$1({
		l: L_vt,
		a: a_ * C_vt,
		b: b_ * C_vt
	});
	const scale_L = Math.cbrt(1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0));
	const L_new = toe_inv$1(v * L_v);
	const C = C_v * L_new / L_v;
	ret.l = L_new * scale_L;
	ret.a = C * a_ * scale_L;
	ret.b = C * b_ * scale_L;
	return ret;
}
var modeOkhsv_default$1 = {
	...definition_default$19$1,
	mode: "okhsv",
	channels: [
		"h",
		"s",
		"v",
		"alpha"
	],
	parse: ["--okhsv"],
	serialize: "--okhsv",
	fromMode: {
		oklab: convertOklabToOkhsv$1,
		rgb: (c$1$1) => convertOklabToOkhsv$1(convertRgbToOklab_default$1(c$1$1))
	},
	toMode: {
		oklab: convertOkhsvToOklab$1,
		rgb: (c$1$1) => convertOklabToRgb_default$1(convertOkhsvToOklab$1(c$1$1))
	}
};
const bias$1 = .0037930732552754493;
const bias_cbrt$1 = Math.cbrt(bias$1);
const transfer$1$1 = (v) => Math.cbrt(v) - bias_cbrt$1;
const convertRgbToXyb$1 = (color) => {
	const { r: r$1$1, g, b, alpha } = convertRgbToLrgb_default$1(color);
	const l = transfer$1$1(.3 * r$1$1 + .622 * g + .078 * b + bias$1);
	const m = transfer$1$1(.23 * r$1$1 + .692 * g + .078 * b + bias$1);
	const s = transfer$1$1(.2434226892454782 * r$1$1 + .2047674442449682 * g + .5518098665095535 * b + bias$1);
	const res = {
		mode: "xyb",
		x: (l - m) / 2,
		y: (l + m) / 2,
		b: s - (l + m) / 2
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyb_default$1 = convertRgbToXyb$1;
const transfer$2 = (v) => Math.pow(v + bias_cbrt$1, 3);
const convertXybToRgb$1 = ({ x, y, b, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (b === void 0) b = 0;
	const l = transfer$2(x + y) - bias$1;
	const m = transfer$2(y - x) - bias$1;
	const s = transfer$2(b + y) - bias$1;
	const res = convertLrgbToRgb_default$1({
		r: 11.031566904639861 * l - 9.866943908131562 * m - .16462299650829934 * s,
		g: -3.2541473810744237 * l + 4.418770377582723 * m - .16462299650829934 * s,
		b: -3.6588512867136815 * l + 2.7129230459360922 * m + 1.9459282407775895 * s
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var definition_default$26$1 = {
	mode: "xyb",
	channels: [
		"x",
		"y",
		"b",
		"alpha"
	],
	parse: ["--xyb"],
	serialize: "--xyb",
	toMode: { rgb: convertXybToRgb$1 },
	fromMode: { rgb: convertRgbToXyb_default$1 },
	ranges: {
		x: [-.0154, .0281],
		y: [0, .8453],
		b: [-.2778, .388]
	},
	interpolate: {
		x: interpolatorLinear$1,
		y: interpolatorLinear$1,
		b: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	}
};
const convertRgbToYiq$1 = ({ r: r$1$1, g, b, alpha }) => {
	if (r$1$1 === void 0) r$1$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	const res = {
		mode: "yiq",
		y: .29889531 * r$1$1 + .58662247 * g + .11448223 * b,
		i: .59597799 * r$1$1 - .2741761 * g - .32180189 * b,
		q: .21147017 * r$1$1 - .52261711 * g + .31114694 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToYiq_default$1 = convertRgbToYiq$1;
const convertYiqToRgb$1 = ({ y, i, q, alpha }) => {
	if (y === void 0) y = 0;
	if (i === void 0) i = 0;
	if (q === void 0) q = 0;
	const res = {
		mode: "rgb",
		r: y + .95608445 * i + .6208885 * q,
		g: y - .27137664 * i - .6486059 * q,
		b: y - 1.10561724 * i + 1.70250126 * q
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var definition_default$27$1 = {
	mode: "yiq",
	toMode: { rgb: convertYiqToRgb$1 },
	fromMode: { rgb: convertRgbToYiq_default$1 },
	channels: [
		"y",
		"i",
		"q",
		"alpha"
	],
	parse: ["--yiq"],
	serialize: "--yiq",
	ranges: {
		i: [-.595, .595],
		q: [-.522, .522]
	},
	interpolate: {
		y: interpolatorLinear$1,
		i: interpolatorLinear$1,
		q: interpolatorLinear$1,
		alpha: {
			use: interpolatorLinear$1,
			fixup: fixupAlpha$1
		}
	}
};
const r$1 = (value, precision) => Math.round(value * (precision = Math.pow(10, precision))) / precision;
const round$1 = (precision = 4) => (value) => typeof value === "number" ? r$1(value, precision) : value;
var round_default$1 = round$1;
round_default$1(2);
const rgb$2 = converter_default$1("rgb");
converter_default$1("hsl");
const rgb$1$1 = converter_default$1("rgb");
useMode$1(definition_default$28);
useMode$1(definition_default$15$1);
useMode$1(definition_default$16$1);
useMode$1(definition_default$17$1);
useMode$1(definition_default$18$1);
useMode$1(definition_default$1$1);
useMode$1(definition_default$19$1);
useMode$1(definition_default$2$1);
useMode$1(definition_default$20$1);
useMode$1(definition_default$21$1);
useMode$1(definition_default$22$1);
useMode$1(definition_default$3$1);
useMode$1(definition_default$4$1);
useMode$1(definition_default$5$1);
useMode$1(definition_default$23$1);
useMode$1(definition_default$24$1);
useMode$1(definition_default$6$1);
useMode$1(definition_default$25$1);
useMode$1(modeOkhsl_default$1);
useMode$1(modeOkhsv_default$1);
useMode$1(definition_default$7$1);
useMode$1(definition_default$8$1);
useMode$1(definition_default$9$1);
useMode$1(definition_default$10$1);
useMode$1(definition_default$11$1);
useMode$1(definition_default$12$1);
useMode$1(definition_default$26$1);
useMode$1(definition_default$13$1);
useMode$1(definition_default$14$1);
useMode$1(definition_default$27$1);
const converters$2 = {
	a98: useMode$1(definition_default$28),
	hsl: useMode$1(definition_default$1$1),
	hwb: useMode$1(definition_default$2$1),
	lab: useMode$1(definition_default$3$1),
	lab65: useMode$1(definition_default$4$1),
	lch: useMode$1(definition_default$5$1),
	lrgb: useMode$1(definition_default$6$1),
	oklab: useMode$1(definition_default$7$1),
	oklch: useMode$1(definition_default$8$1),
	okhsv: useMode$1(modeOkhsv_default$1),
	p3: useMode$1(definition_default$9$1),
	prophoto: useMode$1(definition_default$10$1),
	rec2020: useMode$1(definition_default$11$1),
	rgb: useMode$1(definition_default$12$1),
	xyz50: useMode$1(definition_default$13$1),
	xyz65: useMode$1(definition_default$14$1)
};
const DEPTH_ROUNDING$1 = {
	24: round_default$1(4),
	30: round_default$1(4),
	36: round_default$1(5),
	48: round_default$1(6)
};
const FORMAT_ID = "css";

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseNumber.js
const parseNumber = (color, len) => {
	if (typeof color !== "number") return;
	if (len === 3) return {
		mode: "rgb",
		r: (color >> 8 & 15 | color >> 4 & 240) / 255,
		g: (color >> 4 & 15 | color & 240) / 255,
		b: (color & 15 | color << 4 & 240) / 255
	};
	if (len === 4) return {
		mode: "rgb",
		r: (color >> 12 & 15 | color >> 8 & 240) / 255,
		g: (color >> 8 & 15 | color >> 4 & 240) / 255,
		b: (color >> 4 & 15 | color & 240) / 255,
		alpha: (color & 15 | color << 4 & 240) / 255
	};
	if (len === 6) return {
		mode: "rgb",
		r: (color >> 16 & 255) / 255,
		g: (color >> 8 & 255) / 255,
		b: (color & 255) / 255
	};
	if (len === 8) return {
		mode: "rgb",
		r: (color >> 24 & 255) / 255,
		g: (color >> 16 & 255) / 255,
		b: (color >> 8 & 255) / 255,
		alpha: (color & 255) / 255
	};
};
var parseNumber_default = parseNumber;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/colors/named.js
const named = {
	aliceblue: 15792383,
	antiquewhite: 16444375,
	aqua: 65535,
	aquamarine: 8388564,
	azure: 15794175,
	beige: 16119260,
	bisque: 16770244,
	black: 0,
	blanchedalmond: 16772045,
	blue: 255,
	blueviolet: 9055202,
	brown: 10824234,
	burlywood: 14596231,
	cadetblue: 6266528,
	chartreuse: 8388352,
	chocolate: 13789470,
	coral: 16744272,
	cornflowerblue: 6591981,
	cornsilk: 16775388,
	crimson: 14423100,
	cyan: 65535,
	darkblue: 139,
	darkcyan: 35723,
	darkgoldenrod: 12092939,
	darkgray: 11119017,
	darkgreen: 25600,
	darkgrey: 11119017,
	darkkhaki: 12433259,
	darkmagenta: 9109643,
	darkolivegreen: 5597999,
	darkorange: 16747520,
	darkorchid: 10040012,
	darkred: 9109504,
	darksalmon: 15308410,
	darkseagreen: 9419919,
	darkslateblue: 4734347,
	darkslategray: 3100495,
	darkslategrey: 3100495,
	darkturquoise: 52945,
	darkviolet: 9699539,
	deeppink: 16716947,
	deepskyblue: 49151,
	dimgray: 6908265,
	dimgrey: 6908265,
	dodgerblue: 2003199,
	firebrick: 11674146,
	floralwhite: 16775920,
	forestgreen: 2263842,
	fuchsia: 16711935,
	gainsboro: 14474460,
	ghostwhite: 16316671,
	gold: 16766720,
	goldenrod: 14329120,
	gray: 8421504,
	green: 32768,
	greenyellow: 11403055,
	grey: 8421504,
	honeydew: 15794160,
	hotpink: 16738740,
	indianred: 13458524,
	indigo: 4915330,
	ivory: 16777200,
	khaki: 15787660,
	lavender: 15132410,
	lavenderblush: 16773365,
	lawngreen: 8190976,
	lemonchiffon: 16775885,
	lightblue: 11393254,
	lightcoral: 15761536,
	lightcyan: 14745599,
	lightgoldenrodyellow: 16448210,
	lightgray: 13882323,
	lightgreen: 9498256,
	lightgrey: 13882323,
	lightpink: 16758465,
	lightsalmon: 16752762,
	lightseagreen: 2142890,
	lightskyblue: 8900346,
	lightslategray: 7833753,
	lightslategrey: 7833753,
	lightsteelblue: 11584734,
	lightyellow: 16777184,
	lime: 65280,
	limegreen: 3329330,
	linen: 16445670,
	magenta: 16711935,
	maroon: 8388608,
	mediumaquamarine: 6737322,
	mediumblue: 205,
	mediumorchid: 12211667,
	mediumpurple: 9662683,
	mediumseagreen: 3978097,
	mediumslateblue: 8087790,
	mediumspringgreen: 64154,
	mediumturquoise: 4772300,
	mediumvioletred: 13047173,
	midnightblue: 1644912,
	mintcream: 16121850,
	mistyrose: 16770273,
	moccasin: 16770229,
	navajowhite: 16768685,
	navy: 128,
	oldlace: 16643558,
	olive: 8421376,
	olivedrab: 7048739,
	orange: 16753920,
	orangered: 16729344,
	orchid: 14315734,
	palegoldenrod: 15657130,
	palegreen: 10025880,
	paleturquoise: 11529966,
	palevioletred: 14381203,
	papayawhip: 16773077,
	peachpuff: 16767673,
	peru: 13468991,
	pink: 16761035,
	plum: 14524637,
	powderblue: 11591910,
	purple: 8388736,
	rebeccapurple: 6697881,
	red: 16711680,
	rosybrown: 12357519,
	royalblue: 4286945,
	saddlebrown: 9127187,
	salmon: 16416882,
	sandybrown: 16032864,
	seagreen: 3050327,
	seashell: 16774638,
	sienna: 10506797,
	silver: 12632256,
	skyblue: 8900331,
	slateblue: 6970061,
	slategray: 7372944,
	slategrey: 7372944,
	snow: 16775930,
	springgreen: 65407,
	steelblue: 4620980,
	tan: 13808780,
	teal: 32896,
	thistle: 14204888,
	tomato: 16737095,
	turquoise: 4251856,
	violet: 15631086,
	wheat: 16113331,
	white: 16777215,
	whitesmoke: 16119285,
	yellow: 16776960,
	yellowgreen: 10145074
};
var named_default = named;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseNamed.js
const parseNamed = (color) => {
	return parseNumber_default(named_default[color.toLowerCase()], 6);
};
var parseNamed_default = parseNamed;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseHex.js
const hex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
const parseHex = (color) => {
	let match;
	return (match = color.match(hex)) ? parseNumber_default(parseInt(match[1], 16), match[1].length) : void 0;
};
var parseHex_default = parseHex;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/util/regex.js
const num$1 = "([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)";
const num_none = `(?:${num$1}|none)`;
const per = `${num$1}%`;
const per_none = `(?:${num$1}%|none)`;
const num_per = `(?:${num$1}%|${num$1})`;
const num_per_none = `(?:${num$1}%|${num$1}|none)`;
const hue$1 = `(?:${num$1}(deg|grad|rad|turn)|${num$1})`;
const hue_none = `(?:${num$1}(deg|grad|rad|turn)|${num$1}|none)`;
const c = `\\s*,\\s*`;
const rx_num_per_none = /* @__PURE__ */ new RegExp("^" + num_per_none + "$");

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseRgbLegacy.js
const rgb_num_old = /* @__PURE__ */ new RegExp(`^rgba?\\(\\s*${num$1}${c}${num$1}${c}${num$1}\\s*(?:,\\s*${num_per}\\s*)?\\)$`);
const rgb_per_old = /* @__PURE__ */ new RegExp(`^rgba?\\(\\s*${per}${c}${per}${c}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`);
const parseRgbLegacy = (color) => {
	let res = { mode: "rgb" };
	let match;
	if (match = color.match(rgb_num_old)) {
		if (match[1] !== void 0) res.r = match[1] / 255;
		if (match[2] !== void 0) res.g = match[2] / 255;
		if (match[3] !== void 0) res.b = match[3] / 255;
	} else if (match = color.match(rgb_per_old)) {
		if (match[1] !== void 0) res.r = match[1] / 100;
		if (match[2] !== void 0) res.g = match[2] / 100;
		if (match[3] !== void 0) res.b = match[3] / 100;
	} else return;
	if (match[4] !== void 0) res.alpha = Math.max(0, Math.min(1, match[4] / 100));
	else if (match[5] !== void 0) res.alpha = Math.max(0, Math.min(1, +match[5]));
	return res;
};
var parseRgbLegacy_default = parseRgbLegacy;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/_prepare.js
const prepare = (color, mode) => color === void 0 ? void 0 : typeof color !== "object" ? parse_default(color) : color.mode !== void 0 ? color : mode ? {
	...color,
	mode
} : void 0;
var _prepare_default = prepare;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/converter.js
const converter = (target_mode = "rgb") => (color) => (color = _prepare_default(color, target_mode)) !== void 0 ? color.mode === target_mode ? color : converters$1[color.mode][target_mode] ? converters$1[color.mode][target_mode](color) : target_mode === "rgb" ? converters$1[color.mode].rgb(color) : converters$1.rgb[target_mode](converters$1[color.mode].rgb(color)) : void 0;
var converter_default = converter;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/modes.js
const converters$1 = {};
const modes = {};
const parsers = [];
const colorProfiles = {};
const identity = (v) => v;
const useMode = (definition$28) => {
	converters$1[definition$28.mode] = {
		...converters$1[definition$28.mode],
		...definition$28.toMode
	};
	Object.keys(definition$28.fromMode || {}).forEach((k$4) => {
		if (!converters$1[k$4]) converters$1[k$4] = {};
		converters$1[k$4][definition$28.mode] = definition$28.fromMode[k$4];
	});
	if (!definition$28.ranges) definition$28.ranges = {};
	if (!definition$28.difference) definition$28.difference = {};
	definition$28.channels.forEach((channel) => {
		if (definition$28.ranges[channel] === void 0) definition$28.ranges[channel] = [0, 1];
		if (!definition$28.interpolate[channel]) throw new Error(`Missing interpolator for: ${channel}`);
		if (typeof definition$28.interpolate[channel] === "function") definition$28.interpolate[channel] = { use: definition$28.interpolate[channel] };
		if (!definition$28.interpolate[channel].fixup) definition$28.interpolate[channel].fixup = identity;
	});
	modes[definition$28.mode] = definition$28;
	(definition$28.parse || []).forEach((parser) => {
		useParser(parser, definition$28.mode);
	});
	return converter_default(definition$28.mode);
};
const getMode = (mode) => modes[mode];
const useParser = (parser, mode) => {
	if (typeof parser === "string") {
		if (!mode) throw new Error(`'mode' required when 'parser' is a string`);
		colorProfiles[parser] = mode;
	} else if (typeof parser === "function") {
		if (parsers.indexOf(parser) < 0) parsers.push(parser);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/parse.js
const IdentStartCodePoint = /[^\x00-\x7F]|[a-zA-Z_]/;
const IdentCodePoint = /[^\x00-\x7F]|[-\w]/;
const Tok = {
	Function: "function",
	Ident: "ident",
	Number: "number",
	Percentage: "percentage",
	ParenClose: ")",
	None: "none",
	Hue: "hue",
	Alpha: "alpha"
};
let _i = 0;
function is_num(chars) {
	let ch = chars[_i];
	let ch1 = chars[_i + 1];
	if (ch === "-" || ch === "+") return /\d/.test(ch1) || ch1 === "." && /\d/.test(chars[_i + 2]);
	if (ch === ".") return /\d/.test(ch1);
	return /\d/.test(ch);
}
function is_ident(chars) {
	if (_i >= chars.length) return false;
	let ch = chars[_i];
	if (IdentStartCodePoint.test(ch)) return true;
	if (ch === "-") {
		if (chars.length - _i < 2) return false;
		let ch1 = chars[_i + 1];
		if (ch1 === "-" || IdentStartCodePoint.test(ch1)) return true;
		return false;
	}
	return false;
}
const huenits = {
	deg: 1,
	rad: 180 / Math.PI,
	grad: 9 / 10,
	turn: 360
};
function num(chars) {
	let value = "";
	if (chars[_i] === "-" || chars[_i] === "+") value += chars[_i++];
	value += digits(chars);
	if (chars[_i] === "." && /\d/.test(chars[_i + 1])) value += chars[_i++] + digits(chars);
	if (chars[_i] === "e" || chars[_i] === "E") {
		if ((chars[_i + 1] === "-" || chars[_i + 1] === "+") && /\d/.test(chars[_i + 2])) value += chars[_i++] + chars[_i++] + digits(chars);
		else if (/\d/.test(chars[_i + 1])) value += chars[_i++] + digits(chars);
	}
	if (is_ident(chars)) {
		let id = ident(chars);
		if (id === "deg" || id === "rad" || id === "turn" || id === "grad") return {
			type: Tok.Hue,
			value: value * huenits[id]
		};
		return;
	}
	if (chars[_i] === "%") {
		_i++;
		return {
			type: Tok.Percentage,
			value: +value
		};
	}
	return {
		type: Tok.Number,
		value: +value
	};
}
function digits(chars) {
	let v = "";
	while (/\d/.test(chars[_i])) v += chars[_i++];
	return v;
}
function ident(chars) {
	let v = "";
	while (_i < chars.length && IdentCodePoint.test(chars[_i])) v += chars[_i++];
	return v;
}
function identlike(chars) {
	let v = ident(chars);
	if (chars[_i] === "(") {
		_i++;
		return {
			type: Tok.Function,
			value: v
		};
	}
	if (v === "none") return {
		type: Tok.None,
		value: void 0
	};
	return {
		type: Tok.Ident,
		value: v
	};
}
function tokenize(str = "") {
	let chars = str.trim();
	let tokens = [];
	let ch;
	_i = 0;
	while (_i < chars.length) {
		ch = chars[_i++];
		if (ch === "\n" || ch === "	" || ch === " ") {
			while (_i < chars.length && (chars[_i] === "\n" || chars[_i] === "	" || chars[_i] === " ")) _i++;
			continue;
		}
		if (ch === ",") return;
		if (ch === ")") {
			tokens.push({ type: Tok.ParenClose });
			continue;
		}
		if (ch === "+") {
			_i--;
			if (is_num(chars)) {
				tokens.push(num(chars));
				continue;
			}
			return;
		}
		if (ch === "-") {
			_i--;
			if (is_num(chars)) {
				tokens.push(num(chars));
				continue;
			}
			if (is_ident(chars)) {
				tokens.push({
					type: Tok.Ident,
					value: ident(chars)
				});
				continue;
			}
			return;
		}
		if (ch === ".") {
			_i--;
			if (is_num(chars)) {
				tokens.push(num(chars));
				continue;
			}
			return;
		}
		if (ch === "/") {
			while (_i < chars.length && (chars[_i] === "\n" || chars[_i] === "	" || chars[_i] === " ")) _i++;
			let alpha;
			if (is_num(chars)) {
				alpha = num(chars);
				if (alpha.type !== Tok.Hue) {
					tokens.push({
						type: Tok.Alpha,
						value: alpha
					});
					continue;
				}
			}
			if (is_ident(chars)) {
				if (ident(chars) === "none") {
					tokens.push({
						type: Tok.Alpha,
						value: {
							type: Tok.None,
							value: void 0
						}
					});
					continue;
				}
			}
			return;
		}
		if (/\d/.test(ch)) {
			_i--;
			tokens.push(num(chars));
			continue;
		}
		if (IdentStartCodePoint.test(ch)) {
			_i--;
			tokens.push(identlike(chars));
			continue;
		}
		return;
	}
	return tokens;
}
function parseColorSyntax(tokens) {
	tokens._i = 0;
	let token = tokens[tokens._i++];
	if (!token || token.type !== Tok.Function || token.value !== "color") return;
	token = tokens[tokens._i++];
	if (token.type !== Tok.Ident) return;
	const mode = colorProfiles[token.value];
	if (!mode) return;
	const res = { mode };
	const coords = consumeCoords(tokens, false);
	if (!coords) return;
	const channels = getMode(mode).channels;
	for (let ii = 0, c$2, ch; ii < channels.length; ii++) {
		c$2 = coords[ii];
		ch = channels[ii];
		if (c$2.type !== Tok.None) {
			res[ch] = c$2.type === Tok.Number ? c$2.value : c$2.value / 100;
			if (ch === "alpha") res[ch] = Math.max(0, Math.min(1, res[ch]));
		}
	}
	return res;
}
function consumeCoords(tokens, includeHue) {
	const coords = [];
	let token;
	while (tokens._i < tokens.length) {
		token = tokens[tokens._i++];
		if (token.type === Tok.None || token.type === Tok.Number || token.type === Tok.Alpha || token.type === Tok.Percentage || includeHue && token.type === Tok.Hue) {
			coords.push(token);
			continue;
		}
		if (token.type === Tok.ParenClose) {
			if (tokens._i < tokens.length) return;
			continue;
		}
		return;
	}
	if (coords.length < 3 || coords.length > 4) return;
	if (coords.length === 4) {
		if (coords[3].type !== Tok.Alpha) return;
		coords[3] = coords[3].value;
	}
	if (coords.length === 3) coords.push({
		type: Tok.None,
		value: void 0
	});
	return coords.every((c$2) => c$2.type !== Tok.Alpha) ? coords : void 0;
}
function parseModernSyntax(tokens, includeHue) {
	tokens._i = 0;
	let token = tokens[tokens._i++];
	if (!token || token.type !== Tok.Function) return;
	let coords = consumeCoords(tokens, includeHue);
	if (!coords) return;
	coords.unshift(token.value);
	return coords;
}
const parse = (color) => {
	if (typeof color !== "string") return;
	const tokens = tokenize(color);
	const parsed = tokens ? parseModernSyntax(tokens, true) : void 0;
	let result = void 0;
	let i = 0;
	let len = parsers.length;
	while (i < len) if ((result = parsers[i++](color, parsed)) !== void 0) return result;
	return tokens ? parseColorSyntax(tokens) : void 0;
};
var parse_default = parse;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseRgb.js
function parseRgb(color, parsed) {
	if (!parsed || parsed[0] !== "rgb" && parsed[0] !== "rgba") return;
	const res = { mode: "rgb" };
	const [, r$2, g, b, alpha] = parsed;
	if (r$2.type === Tok.Hue || g.type === Tok.Hue || b.type === Tok.Hue) return;
	if (r$2.type !== Tok.None) res.r = r$2.type === Tok.Number ? r$2.value / 255 : r$2.value / 100;
	if (g.type !== Tok.None) res.g = g.type === Tok.Number ? g.value / 255 : g.value / 100;
	if (b.type !== Tok.None) res.b = b.type === Tok.Number ? b.value / 255 : b.value / 100;
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseRgb_default = parseRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseTransparent.js
const parseTransparent = (c$2) => c$2 === "transparent" ? {
	mode: "rgb",
	r: 0,
	g: 0,
	b: 0,
	alpha: 0
} : void 0;
var parseTransparent_default = parseTransparent;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/interpolate/lerp.js
const lerp = (a, b, t) => a + t * (b - a);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/interpolate/piecewise.js
const get_classes = (arr) => {
	let classes = [];
	for (let i = 0; i < arr.length - 1; i++) {
		let a = arr[i];
		let b = arr[i + 1];
		if (a === void 0 && b === void 0) classes.push(void 0);
		else if (a !== void 0 && b !== void 0) classes.push([a, b]);
		else classes.push(a !== void 0 ? [a, a] : [b, b]);
	}
	return classes;
};
const interpolatorPiecewise = (interpolator) => (arr) => {
	let classes = get_classes(arr);
	return (t) => {
		let cls = t * classes.length;
		let idx = t >= 1 ? classes.length - 1 : Math.max(Math.floor(cls), 0);
		let pair = classes[idx];
		return pair === void 0 ? void 0 : interpolator(pair[0], pair[1], cls - idx);
	};
};

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/interpolate/linear.js
const interpolatorLinear = interpolatorPiecewise(lerp);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/fixup/alpha.js
const fixupAlpha = (arr) => {
	let some_defined = false;
	let res = arr.map((v) => {
		if (v !== void 0) {
			some_defined = true;
			return v;
		}
		return 1;
	});
	return some_defined ? res : arr;
};

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/definition.js
const definition$27 = {
	mode: "rgb",
	channels: [
		"r",
		"g",
		"b",
		"alpha"
	],
	parse: [
		parseRgb_default,
		parseHex_default,
		parseRgbLegacy_default,
		parseNamed_default,
		parseTransparent_default,
		"srgb"
	],
	serialize: "srgb",
	interpolate: {
		r: interpolatorLinear,
		g: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	gamut: true,
	white: {
		r: 1,
		g: 1,
		b: 1
	},
	black: {
		r: 0,
		g: 0,
		b: 0
	}
};
var definition_default$12 = definition$27;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/a98/convertA98ToXyz65.js
const linearize$2 = (v = 0) => Math.pow(Math.abs(v), 563 / 256) * Math.sign(v);
const convertA98ToXyz65 = (a98$2) => {
	let r$2 = linearize$2(a98$2.r);
	let g = linearize$2(a98$2.g);
	let b = linearize$2(a98$2.b);
	let res = {
		mode: "xyz65",
		x: .5766690429101305 * r$2 + .1855582379065463 * g + .1882286462349947 * b,
		y: .297344975250536 * r$2 + .6273635662554661 * g + .0752914584939979 * b,
		z: .0270313613864123 * r$2 + .0706888525358272 * g + .9913375368376386 * b
	};
	if (a98$2.alpha !== void 0) res.alpha = a98$2.alpha;
	return res;
};
var convertA98ToXyz65_default = convertA98ToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/a98/convertXyz65ToA98.js
const gamma$2 = (v) => Math.pow(Math.abs(v), 256 / 563) * Math.sign(v);
const convertXyz65ToA98 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "a98",
		r: gamma$2(x * 2.0415879038107465 - y * .5650069742788597 - .3447313507783297 * z),
		g: gamma$2(x * -.9692436362808798 + y * 1.8759675015077206 + .0415550574071756 * z),
		b: gamma$2(x * .0134442806320312 - y * .1183623922310184 + 1.0151749943912058 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToA98_default = convertXyz65ToA98;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lrgb/convertRgbToLrgb.js
const fn$3 = (c$2 = 0) => {
	const abs$2 = Math.abs(c$2);
	if (abs$2 <= .04045) return c$2 / 12.92;
	return (Math.sign(c$2) || 1) * Math.pow((abs$2 + .055) / 1.055, 2.4);
};
const convertRgbToLrgb = ({ r: r$2, g, b, alpha }) => {
	let res = {
		mode: "lrgb",
		r: fn$3(r$2),
		g: fn$3(g),
		b: fn$3(b)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToLrgb_default = convertRgbToLrgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/convertRgbToXyz65.js
const convertRgbToXyz65 = (rgb$3) => {
	let { r: r$2, g, b, alpha } = convertRgbToLrgb_default(rgb$3);
	let res = {
		mode: "xyz65",
		x: .4123907992659593 * r$2 + .357584339383878 * g + .1804807884018343 * b,
		y: .2126390058715102 * r$2 + .715168678767756 * g + .0721923153607337 * b,
		z: .0193308187155918 * r$2 + .119194779794626 * g + .9505321522496607 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyz65_default = convertRgbToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lrgb/convertLrgbToRgb.js
const fn$2 = (c$2 = 0) => {
	const abs$2 = Math.abs(c$2);
	if (abs$2 > .0031308) return (Math.sign(c$2) || 1) * (1.055 * Math.pow(abs$2, 1 / 2.4) - .055);
	return c$2 * 12.92;
};
const convertLrgbToRgb = ({ r: r$2, g, b, alpha }, mode = "rgb") => {
	let res = {
		mode,
		r: fn$2(r$2),
		g: fn$2(g),
		b: fn$2(b)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLrgbToRgb_default = convertLrgbToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/convertXyz65ToRgb.js
const convertXyz65ToRgb = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default({
		r: x * 3.2409699419045226 - y * 1.537383177570094 - .4986107602930034 * z,
		g: x * -.9692436362808796 + y * 1.8759675015077204 + .0415550574071756 * z,
		b: x * .0556300796969936 - y * .2039769588889765 + 1.0569715142428784 * z
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToRgb_default = convertXyz65ToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/a98/definition.js
const definition$26 = {
	...definition_default$12,
	mode: "a98",
	parse: ["a98-rgb"],
	serialize: "a98-rgb",
	fromMode: {
		rgb: (color) => convertXyz65ToA98_default(convertRgbToXyz65_default(color)),
		xyz65: convertXyz65ToA98_default
	},
	toMode: {
		rgb: (color) => convertXyz65ToRgb_default(convertA98ToXyz65_default(color)),
		xyz65: convertA98ToXyz65_default
	}
};
var definition_default = definition$26;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/util/normalizeHue.js
const normalizeHue = (hue$3) => (hue$3 = hue$3 % 360) < 0 ? hue$3 + 360 : hue$3;
var normalizeHue_default = normalizeHue;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsl/convertHslToRgb.js
function convertHslToRgb({ h, s, l, alpha }) {
	h = normalizeHue_default(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (l === void 0) l = 0;
	let m1 = l + s * (l < .5 ? l : 1 - l);
	let m2 = m1 - (m1 - l) * 2 * Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: m1,
				g: m2,
				b: 2 * l - m1
			};
			break;
		case 1:
			res = {
				r: m2,
				g: m1,
				b: 2 * l - m1
			};
			break;
		case 2:
			res = {
				r: 2 * l - m1,
				g: m1,
				b: m2
			};
			break;
		case 3:
			res = {
				r: 2 * l - m1,
				g: m2,
				b: m1
			};
			break;
		case 4:
			res = {
				r: m2,
				g: 2 * l - m1,
				b: m1
			};
			break;
		case 5:
			res = {
				r: m1,
				g: 2 * l - m1,
				b: m2
			};
			break;
		default: res = {
			r: 2 * l - m1,
			g: 2 * l - m1,
			b: 2 * l - m1
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsl/convertRgbToHsl.js
function convertRgbToHsl({ r: r$2, g, b, alpha }) {
	if (r$2 === void 0) r$2 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$2 = Math.max(r$2, g, b), m = Math.min(r$2, g, b);
	let res = {
		mode: "hsl",
		s: M$2 === m ? 0 : (M$2 - m) / (1 - Math.abs(M$2 + m - 1)),
		l: .5 * (M$2 + m)
	};
	if (M$2 - m !== 0) res.h = (M$2 === r$2 ? (g - b) / (M$2 - m) + (g < b) * 6 : M$2 === g ? (b - r$2) / (M$2 - m) + 2 : (r$2 - g) / (M$2 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/util/hue.js
const hueToDeg = (val, unit) => {
	switch (unit) {
		case "deg": return +val;
		case "rad": return val / Math.PI * 180;
		case "grad": return val / 10 * 9;
		case "turn": return val * 360;
	}
};
var hue_default = hueToDeg;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsl/parseHslLegacy.js
const hsl_old = /* @__PURE__ */ new RegExp(`^hsla?\\(\\s*${hue$1}${c}${per}${c}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`);
const parseHslLegacy = (color) => {
	let match = color.match(hsl_old);
	if (!match) return;
	let res = { mode: "hsl" };
	if (match[3] !== void 0) res.h = +match[3];
	else if (match[1] !== void 0 && match[2] !== void 0) res.h = hue_default(match[1], match[2]);
	if (match[4] !== void 0) res.s = Math.min(Math.max(0, match[4] / 100), 1);
	if (match[5] !== void 0) res.l = Math.min(Math.max(0, match[5] / 100), 1);
	if (match[6] !== void 0) res.alpha = Math.max(0, Math.min(1, match[6] / 100));
	else if (match[7] !== void 0) res.alpha = Math.max(0, Math.min(1, +match[7]));
	return res;
};
var parseHslLegacy_default = parseHslLegacy;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsl/parseHsl.js
function parseHsl(color, parsed) {
	if (!parsed || parsed[0] !== "hsl" && parsed[0] !== "hsla") return;
	const res = { mode: "hsl" };
	const [, h, s, l, alpha] = parsed;
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (s.type !== Tok.None) {
		if (s.type === Tok.Hue) return;
		res.s = s.value / 100;
	}
	if (l.type !== Tok.None) {
		if (l.type === Tok.Hue) return;
		res.l = l.value / 100;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseHsl_default = parseHsl;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/fixup/hue.js
const hue = (hues, fn$5) => {
	return hues.map((hue$3, idx, arr) => {
		if (hue$3 === void 0) return hue$3;
		let normalized = normalizeHue_default(hue$3);
		if (idx === 0 || hues[idx - 1] === void 0) return normalized;
		return fn$5(normalized - normalizeHue_default(arr[idx - 1]));
	}).reduce((acc, curr) => {
		if (!acc.length || curr === void 0 || acc[acc.length - 1] === void 0) {
			acc.push(curr);
			return acc;
		}
		acc.push(curr + acc[acc.length - 1]);
		return acc;
	}, []);
};
const fixupHueShorter = (arr) => hue(arr, (d) => Math.abs(d) <= 180 ? d : d - 360 * Math.sign(d));

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/difference.js
const differenceHueSaturation = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0 || !std.s || !smp.s) return 0;
	let std_h = normalizeHue_default(std.h);
	let smp_h = normalizeHue_default(smp.h);
	let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
	return 2 * Math.sqrt(std.s * smp.s) * dH;
};
const differenceHueNaive = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0) return 0;
	let std_h = normalizeHue_default(std.h);
	let smp_h = normalizeHue_default(smp.h);
	if (Math.abs(smp_h - std_h) > 180) return std_h - (smp_h - 360 * Math.sign(smp_h - std_h));
	return smp_h - std_h;
};
const differenceHueChroma = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0 || !std.c || !smp.c) return 0;
	let std_h = normalizeHue_default(std.h);
	let smp_h = normalizeHue_default(smp.h);
	let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
	return 2 * Math.sqrt(std.c * smp.c) * dH;
};

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/average.js
const averageAngle = (val) => {
	let sum = val.reduce((sum$1, val$1) => {
		if (val$1 !== void 0) {
			let rad = val$1 * Math.PI / 180;
			sum$1.sin += Math.sin(rad);
			sum$1.cos += Math.cos(rad);
		}
		return sum$1;
	}, {
		sin: 0,
		cos: 0
	});
	let angle = Math.atan2(sum.sin, sum.cos) * 180 / Math.PI;
	return angle < 0 ? 360 + angle : angle;
};

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsl/definition.js
const definition$25 = {
	mode: "hsl",
	toMode: { rgb: convertHslToRgb },
	fromMode: { rgb: convertRgbToHsl },
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	parse: [parseHsl_default, parseHslLegacy_default],
	serialize: (c$2) => `hsl(${c$2.h !== void 0 ? c$2.h : "none"} ${c$2.s !== void 0 ? c$2.s * 100 + "%" : "none"} ${c$2.l !== void 0 ? c$2.l * 100 + "%" : "none"}${c$2.alpha < 1 ? ` / ${c$2.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$1 = definition$25;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsv/convertHsvToRgb.js
function convertHsvToRgb({ h, s, v, alpha }) {
	h = normalizeHue_default(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (v === void 0) v = 0;
	let f$3 = Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: v,
				g: v * (1 - s * f$3),
				b: v * (1 - s)
			};
			break;
		case 1:
			res = {
				r: v * (1 - s * f$3),
				g: v,
				b: v * (1 - s)
			};
			break;
		case 2:
			res = {
				r: v * (1 - s),
				g: v,
				b: v * (1 - s * f$3)
			};
			break;
		case 3:
			res = {
				r: v * (1 - s),
				g: v * (1 - s * f$3),
				b: v
			};
			break;
		case 4:
			res = {
				r: v * (1 - s * f$3),
				g: v * (1 - s),
				b: v
			};
			break;
		case 5:
			res = {
				r: v,
				g: v * (1 - s),
				b: v * (1 - s * f$3)
			};
			break;
		default: res = {
			r: v * (1 - s),
			g: v * (1 - s),
			b: v * (1 - s)
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsv/convertRgbToHsv.js
function convertRgbToHsv({ r: r$2, g, b, alpha }) {
	if (r$2 === void 0) r$2 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$2 = Math.max(r$2, g, b), m = Math.min(r$2, g, b);
	let res = {
		mode: "hsv",
		s: M$2 === 0 ? 0 : 1 - m / M$2,
		v: M$2
	};
	if (M$2 - m !== 0) res.h = (M$2 === r$2 ? (g - b) / (M$2 - m) + (g < b) * 6 : M$2 === g ? (b - r$2) / (M$2 - m) + 2 : (r$2 - g) / (M$2 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsv/definition.js
const definition$24 = {
	mode: "hsv",
	toMode: { rgb: convertHsvToRgb },
	parse: ["--hsv"],
	serialize: "--hsv",
	fromMode: { rgb: convertRgbToHsv },
	channels: [
		"h",
		"s",
		"v",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		v: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$19 = definition$24;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hwb/convertHwbToRgb.js
function convertHwbToRgb({ h, w, b, alpha }) {
	if (w === void 0) w = 0;
	if (b === void 0) b = 0;
	if (w + b > 1) {
		let s = w + b;
		w /= s;
		b /= s;
	}
	return convertHsvToRgb({
		h,
		s: b === 1 ? 1 : 1 - w / (1 - b),
		v: 1 - b,
		alpha
	});
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hwb/convertRgbToHwb.js
function convertRgbToHwb(rgba) {
	let hsv$2 = convertRgbToHsv(rgba);
	if (hsv$2 === void 0) return void 0;
	let s = hsv$2.s !== void 0 ? hsv$2.s : 0;
	let v = hsv$2.v !== void 0 ? hsv$2.v : 0;
	let res = {
		mode: "hwb",
		w: (1 - s) * v,
		b: 1 - v
	};
	if (hsv$2.h !== void 0) res.h = hsv$2.h;
	if (hsv$2.alpha !== void 0) res.alpha = hsv$2.alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hwb/parseHwb.js
function ParseHwb(color, parsed) {
	if (!parsed || parsed[0] !== "hwb") return;
	const res = { mode: "hwb" };
	const [, h, w, b, alpha] = parsed;
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (w.type !== Tok.None) {
		if (w.type === Tok.Hue) return;
		res.w = w.value / 100;
	}
	if (b.type !== Tok.None) {
		if (b.type === Tok.Hue) return;
		res.b = b.value / 100;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseHwb_default = ParseHwb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hwb/definition.js
const definition$23 = {
	mode: "hwb",
	toMode: { rgb: convertHwbToRgb },
	fromMode: { rgb: convertRgbToHwb },
	channels: [
		"h",
		"w",
		"b",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	parse: [parseHwb_default],
	serialize: (c$2) => `hwb(${c$2.h !== void 0 ? c$2.h : "none"} ${c$2.w !== void 0 ? c$2.w * 100 + "%" : "none"} ${c$2.b !== void 0 ? c$2.b * 100 + "%" : "none"}${c$2.alpha < 1 ? ` / ${c$2.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		w: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueNaive },
	average: { h: averageAngle }
};
var definition_default$2 = definition$23;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz50/constants.js
const k = Math.pow(29, 3) / Math.pow(3, 3);
const e = Math.pow(6, 3) / Math.pow(29, 3);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/constants.js
const D50 = {
	X: .3457 / .3585,
	Y: 1,
	Z: .2958 / .3585
};
const D65 = {
	X: .3127 / .329,
	Y: 1,
	Z: .3583 / .329
};
const k$2 = Math.pow(29, 3) / Math.pow(3, 3);
const e$2 = Math.pow(6, 3) / Math.pow(29, 3);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/convertLabToXyz50.js
let fn$1 = (v) => Math.pow(v, 3) > e ? Math.pow(v, 3) : (116 * v - 16) / k;
const convertLabToXyz50 = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let fy = (l + 16) / 116;
	let fx = a / 500 + fy;
	let fz = fy - b / 200;
	let res = {
		mode: "xyz50",
		x: fn$1(fx) * D50.X,
		y: fn$1(fy) * D50.Y,
		z: fn$1(fz) * D50.Z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLabToXyz50_default = convertLabToXyz50;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz50/convertXyz50ToRgb.js
const convertXyz50ToRgb = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default({
		r: x * 3.1341359569958707 - y * 1.6173863321612538 - .4906619460083532 * z,
		g: x * -.978795502912089 + y * 1.916254567259524 + .03344273116131949 * z,
		b: x * .07195537988411677 - y * .2289768264158322 + 1.405386058324125 * z
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToRgb_default = convertXyz50ToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/convertLabToRgb.js
const convertLabToRgb = (lab$2) => convertXyz50ToRgb_default(convertLabToXyz50_default(lab$2));
var convertLabToRgb_default = convertLabToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz50/convertRgbToXyz50.js
const convertRgbToXyz50 = (rgb$3) => {
	let { r: r$2, g, b, alpha } = convertRgbToLrgb_default(rgb$3);
	let res = {
		mode: "xyz50",
		x: .436065742824811 * r$2 + .3851514688337912 * g + .14307845442264197 * b,
		y: .22249319175623702 * r$2 + .7168870538238823 * g + .06061979053616537 * b,
		z: .013923904500943465 * r$2 + .09708128566574634 * g + .7140993584005155 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyz50_default = convertRgbToXyz50;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/convertXyz50ToLab.js
const f$1 = (value) => value > e ? Math.cbrt(value) : (k * value + 16) / 116;
const convertXyz50ToLab = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let f0 = f$1(x / D50.X);
	let f1 = f$1(y / D50.Y);
	let f2 = f$1(z / D50.Z);
	let res = {
		mode: "lab",
		l: 116 * f1 - 16,
		a: 500 * (f0 - f1),
		b: 200 * (f1 - f2)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToLab_default = convertXyz50ToLab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/convertRgbToLab.js
const convertRgbToLab = (rgb$3) => {
	let res = convertXyz50ToLab_default(convertRgbToXyz50_default(rgb$3));
	if (rgb$3.r === rgb$3.b && rgb$3.b === rgb$3.g) res.a = res.b = 0;
	return res;
};
var convertRgbToLab_default = convertRgbToLab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/parseLab.js
function parseLab(color, parsed) {
	if (!parsed || parsed[0] !== "lab") return;
	const res = { mode: "lab" };
	const [, l, a, b, alpha] = parsed;
	if (l.type === Tok.Hue || a.type === Tok.Hue || b.type === Tok.Hue) return;
	if (l.type !== Tok.None) res.l = Math.min(Math.max(0, l.value), 100);
	if (a.type !== Tok.None) res.a = a.type === Tok.Number ? a.value : a.value * 125 / 100;
	if (b.type !== Tok.None) res.b = b.type === Tok.Number ? b.value : b.value * 125 / 100;
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseLab_default = parseLab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/definition.js
const definition$22 = {
	mode: "lab",
	toMode: {
		xyz50: convertLabToXyz50_default,
		rgb: convertLabToRgb_default
	},
	fromMode: {
		xyz50: convertXyz50ToLab_default,
		rgb: convertRgbToLab_default
	},
	channels: [
		"l",
		"a",
		"b",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		a: [-125, 125],
		b: [-125, 125]
	},
	parse: [parseLab_default],
	serialize: (c$2) => `lab(${c$2.l !== void 0 ? c$2.l : "none"} ${c$2.a !== void 0 ? c$2.a : "none"} ${c$2.b !== void 0 ? c$2.b : "none"}${c$2.alpha < 1 ? ` / ${c$2.alpha}` : ""})`,
	interpolate: {
		l: interpolatorLinear,
		a: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$3 = definition$22;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/constants.js
const k$1 = Math.pow(29, 3) / Math.pow(3, 3);
const e$1 = Math.pow(6, 3) / Math.pow(29, 3);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab65/convertLab65ToXyz65.js
let fn = (v) => Math.pow(v, 3) > e$1 ? Math.pow(v, 3) : (116 * v - 16) / k$1;
const convertLab65ToXyz65 = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let fy = (l + 16) / 116;
	let fx = a / 500 + fy;
	let fz = fy - b / 200;
	let res = {
		mode: "xyz65",
		x: fn(fx) * D65.X,
		y: fn(fy) * D65.Y,
		z: fn(fz) * D65.Z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLab65ToXyz65_default = convertLab65ToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab65/convertLab65ToRgb.js
const convertLab65ToRgb = (lab$2) => convertXyz65ToRgb_default(convertLab65ToXyz65_default(lab$2));
var convertLab65ToRgb_default = convertLab65ToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab65/convertXyz65ToLab65.js
const f = (value) => value > e$1 ? Math.cbrt(value) : (k$1 * value + 16) / 116;
const convertXyz65ToLab65 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let f0 = f(x / D65.X);
	let f1 = f(y / D65.Y);
	let f2 = f(z / D65.Z);
	let res = {
		mode: "lab65",
		l: 116 * f1 - 16,
		a: 500 * (f0 - f1),
		b: 200 * (f1 - f2)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToLab65_default = convertXyz65ToLab65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab65/convertRgbToLab65.js
const convertRgbToLab65 = (rgb$3) => {
	let res = convertXyz65ToLab65_default(convertRgbToXyz65_default(rgb$3));
	if (rgb$3.r === rgb$3.b && rgb$3.b === rgb$3.g) res.a = res.b = 0;
	return res;
};
var convertRgbToLab65_default = convertRgbToLab65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab65/definition.js
const definition$21 = {
	...definition_default$3,
	mode: "lab65",
	parse: ["--lab-d65"],
	serialize: "--lab-d65",
	toMode: {
		xyz65: convertLab65ToXyz65_default,
		rgb: convertLab65ToRgb_default
	},
	fromMode: {
		xyz65: convertXyz65ToLab65_default,
		rgb: convertRgbToLab65_default
	},
	ranges: {
		l: [0, 100],
		a: [-125, 125],
		b: [-125, 125]
	}
};
var definition_default$4 = definition$21;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lch/convertLabToLch.js
const convertLabToLch = ({ l, a, b, alpha }, mode = "lch") => {
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let c$2 = Math.sqrt(a * a + b * b);
	let res = {
		mode,
		l,
		c: c$2
	};
	if (c$2) res.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLabToLch_default = convertLabToLch;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lch/convertLchToLab.js
const convertLchToLab = ({ l, c: c$2, h, alpha }, mode = "lab") => {
	if (h === void 0) h = 0;
	let res = {
		mode,
		l,
		a: c$2 ? c$2 * Math.cos(h / 180 * Math.PI) : 0,
		b: c$2 ? c$2 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLchToLab_default = convertLchToLab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lch/parseLch.js
function parseLch(color, parsed) {
	if (!parsed || parsed[0] !== "lch") return;
	const res = { mode: "lch" };
	const [, l, c$2, h, alpha] = parsed;
	if (l.type !== Tok.None) {
		if (l.type === Tok.Hue) return;
		res.l = Math.min(Math.max(0, l.value), 100);
	}
	if (c$2.type !== Tok.None) res.c = Math.max(0, c$2.type === Tok.Number ? c$2.value : c$2.value * 150 / 100);
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseLch_default = parseLch;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lch/definition.js
const definition$20 = {
	mode: "lch",
	toMode: {
		lab: convertLchToLab_default,
		rgb: (c$2) => convertLabToRgb_default(convertLchToLab_default(c$2))
	},
	fromMode: {
		rgb: (c$2) => convertLabToLch_default(convertRgbToLab_default(c$2)),
		lab: convertLabToLch_default
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		c: [0, 150],
		h: [0, 360]
	},
	parse: [parseLch_default],
	serialize: (c$2) => `lch(${c$2.l !== void 0 ? c$2.l : "none"} ${c$2.c !== void 0 ? c$2.c : "none"} ${c$2.h !== void 0 ? c$2.h : "none"}${c$2.alpha < 1 ? ` / ${c$2.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		c: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$5 = definition$20;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lch65/definition.js
const definition$19 = {
	...definition_default$5,
	mode: "lch65",
	parse: ["--lch-d65"],
	serialize: "--lch-d65",
	toMode: {
		lab65: (c$2) => convertLchToLab_default(c$2, "lab65"),
		rgb: (c$2) => convertLab65ToRgb_default(convertLchToLab_default(c$2, "lab65"))
	},
	fromMode: {
		rgb: (c$2) => convertLabToLch_default(convertRgbToLab65_default(c$2), "lch65"),
		lab65: (c$2) => convertLabToLch_default(c$2, "lch65")
	},
	ranges: {
		l: [0, 100],
		c: [0, 150],
		h: [0, 360]
	}
};
var definition_default$23 = definition$19;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lrgb/definition.js
const definition$18 = {
	...definition_default$12,
	mode: "lrgb",
	toMode: { rgb: convertLrgbToRgb_default },
	fromMode: { rgb: convertRgbToLrgb_default },
	parse: ["srgb-linear"],
	serialize: "srgb-linear"
};
var definition_default$6 = definition$18;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/convertOklabToLrgb.js
const convertOklabToLrgb = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let L = Math.pow(l + .3963377773761749 * a + .2158037573099136 * b, 3);
	let M$2 = Math.pow(l - .1055613458156586 * a - .0638541728258133 * b, 3);
	let S = Math.pow(l - .0894841775298119 * a - 1.2914855480194092 * b, 3);
	let res = {
		mode: "lrgb",
		r: 4.076741636075957 * L - 3.3077115392580616 * M$2 + .2309699031821044 * S,
		g: -1.2684379732850317 * L + 2.6097573492876887 * M$2 - .3413193760026573 * S,
		b: -.0041960761386756 * L - .7034186179359362 * M$2 + 1.7076146940746117 * S
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertOklabToLrgb_default = convertOklabToLrgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/convertLrgbToOklab.js
const convertLrgbToOklab = ({ r: r$2, g, b, alpha }) => {
	if (r$2 === void 0) r$2 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let L = Math.cbrt(.412221469470763 * r$2 + .5363325372617348 * g + .0514459932675022 * b);
	let M$2 = Math.cbrt(.2119034958178252 * r$2 + .6806995506452344 * g + .1073969535369406 * b);
	let S = Math.cbrt(.0883024591900564 * r$2 + .2817188391361215 * g + .6299787016738222 * b);
	let res = {
		mode: "oklab",
		l: .210454268309314 * L + .7936177747023054 * M$2 - .0040720430116193 * S,
		a: 1.9779985324311684 * L - 2.42859224204858 * M$2 + .450593709617411 * S,
		b: .0259040424655478 * L + .7827717124575296 * M$2 - .8086757549230774 * S
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLrgbToOklab_default = convertLrgbToOklab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/convertRgbToOklab.js
const convertRgbToOklab = (rgb$3) => {
	let res = convertLrgbToOklab_default(convertRgbToLrgb_default(rgb$3));
	if (rgb$3.r === rgb$3.b && rgb$3.b === rgb$3.g) res.a = res.b = 0;
	return res;
};
var convertRgbToOklab_default = convertRgbToOklab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/convertOklabToRgb.js
const convertOklabToRgb = (c$2) => convertLrgbToRgb_default(convertOklabToLrgb_default(c$2));
var convertOklabToRgb_default = convertOklabToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/parseOklab.js
function parseOklab(color, parsed) {
	if (!parsed || parsed[0] !== "oklab") return;
	const res = { mode: "oklab" };
	const [, l, a, b, alpha] = parsed;
	if (l.type === Tok.Hue || a.type === Tok.Hue || b.type === Tok.Hue) return;
	if (l.type !== Tok.None) res.l = Math.min(Math.max(0, l.type === Tok.Number ? l.value : l.value / 100), 1);
	if (a.type !== Tok.None) res.a = a.type === Tok.Number ? a.value : a.value * .4 / 100;
	if (b.type !== Tok.None) res.b = b.type === Tok.Number ? b.value : b.value * .4 / 100;
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseOklab_default = parseOklab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/definition.js
const definition$17 = {
	...definition_default$3,
	mode: "oklab",
	toMode: {
		lrgb: convertOklabToLrgb_default,
		rgb: convertOklabToRgb_default
	},
	fromMode: {
		lrgb: convertLrgbToOklab_default,
		rgb: convertRgbToOklab_default
	},
	ranges: {
		l: [0, 1],
		a: [-.4, .4],
		b: [-.4, .4]
	},
	parse: [parseOklab_default],
	serialize: (c$2) => `oklab(${c$2.l !== void 0 ? c$2.l : "none"} ${c$2.a !== void 0 ? c$2.a : "none"} ${c$2.b !== void 0 ? c$2.b : "none"}${c$2.alpha < 1 ? ` / ${c$2.alpha}` : ""})`
};
var definition_default$7 = definition$17;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklch/parseOklch.js
function parseOklch(color, parsed) {
	if (!parsed || parsed[0] !== "oklch") return;
	const res = { mode: "oklch" };
	const [, l, c$2, h, alpha] = parsed;
	if (l.type !== Tok.None) {
		if (l.type === Tok.Hue) return;
		res.l = Math.min(Math.max(0, l.type === Tok.Number ? l.value : l.value / 100), 1);
	}
	if (c$2.type !== Tok.None) res.c = Math.max(0, c$2.type === Tok.Number ? c$2.value : c$2.value * .4 / 100);
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseOklch_default = parseOklch;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklch/definition.js
const definition$16 = {
	...definition_default$5,
	mode: "oklch",
	toMode: {
		oklab: (c$2) => convertLchToLab_default(c$2, "oklab"),
		rgb: (c$2) => convertOklabToRgb_default(convertLchToLab_default(c$2, "oklab"))
	},
	fromMode: {
		rgb: (c$2) => convertLabToLch_default(convertRgbToOklab_default(c$2), "oklch"),
		oklab: (c$2) => convertLabToLch_default(c$2, "oklch")
	},
	parse: [parseOklch_default],
	serialize: (c$2) => `oklch(${c$2.l !== void 0 ? c$2.l : "none"} ${c$2.c !== void 0 ? c$2.c : "none"} ${c$2.h !== void 0 ? c$2.h : "none"}${c$2.alpha < 1 ? ` / ${c$2.alpha}` : ""})`,
	ranges: {
		l: [0, 1],
		c: [0, .4],
		h: [0, 360]
	}
};
var definition_default$8 = definition$16;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/p3/convertP3ToXyz65.js
const convertP3ToXyz65 = (rgb$3) => {
	let { r: r$2, g, b, alpha } = convertRgbToLrgb_default(rgb$3);
	let res = {
		mode: "xyz65",
		x: .486570948648216 * r$2 + .265667693169093 * g + .1982172852343625 * b,
		y: .2289745640697487 * r$2 + .6917385218365062 * g + .079286914093745 * b,
		z: 0 * r$2 + .0451133818589026 * g + 1.043944368900976 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertP3ToXyz65_default = convertP3ToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/p3/convertXyz65ToP3.js
const convertXyz65ToP3 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default({
		r: x * 2.4934969119414263 - y * .9313836179191242 - .402710784450717 * z,
		g: x * -.8294889695615749 + y * 1.7626640603183465 + .0236246858419436 * z,
		b: x * .0358458302437845 - y * .0761723892680418 + .9568845240076871 * z
	}, "p3");
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToP3_default = convertXyz65ToP3;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/p3/definition.js
const definition$15 = {
	...definition_default$12,
	mode: "p3",
	parse: ["display-p3"],
	serialize: "display-p3",
	fromMode: {
		rgb: (color) => convertXyz65ToP3_default(convertRgbToXyz65_default(color)),
		xyz65: convertXyz65ToP3_default
	},
	toMode: {
		rgb: (color) => convertXyz65ToRgb_default(convertP3ToXyz65_default(color)),
		xyz65: convertP3ToXyz65_default
	}
};
var definition_default$9 = definition$15;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/prophoto/convertXyz50ToProphoto.js
const gamma$1 = (v) => {
	let abs$2 = Math.abs(v);
	if (abs$2 >= 1 / 512) return Math.sign(v) * Math.pow(abs$2, 1 / 1.8);
	return 16 * v;
};
const convertXyz50ToProphoto = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "prophoto",
		r: gamma$1(x * 1.3457868816471585 - y * .2555720873797946 - .0511018649755453 * z),
		g: gamma$1(x * -.5446307051249019 + y * 1.5082477428451466 + .0205274474364214 * z),
		b: gamma$1(x * 0 + y * 0 + 1.2119675456389452 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToProphoto_default = convertXyz50ToProphoto;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/prophoto/convertProphotoToXyz50.js
const linearize$1 = (v = 0) => {
	let abs$2 = Math.abs(v);
	if (abs$2 >= 16 / 512) return Math.sign(v) * Math.pow(abs$2, 1.8);
	return v / 16;
};
const convertProphotoToXyz50 = (prophoto$2) => {
	let r$2 = linearize$1(prophoto$2.r);
	let g = linearize$1(prophoto$2.g);
	let b = linearize$1(prophoto$2.b);
	let res = {
		mode: "xyz50",
		x: .7977666449006423 * r$2 + .1351812974005331 * g + .0313477341283922 * b,
		y: .2880748288194013 * r$2 + .7118352342418731 * g + 899369387256e-16 * b,
		z: 0 * r$2 + 0 * g + .8251046025104602 * b
	};
	if (prophoto$2.alpha !== void 0) res.alpha = prophoto$2.alpha;
	return res;
};
var convertProphotoToXyz50_default = convertProphotoToXyz50;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/prophoto/definition.js
const definition$14 = {
	...definition_default$12,
	mode: "prophoto",
	parse: ["prophoto-rgb"],
	serialize: "prophoto-rgb",
	fromMode: {
		xyz50: convertXyz50ToProphoto_default,
		rgb: (color) => convertXyz50ToProphoto_default(convertRgbToXyz50_default(color))
	},
	toMode: {
		xyz50: convertProphotoToXyz50_default,
		rgb: (color) => convertXyz50ToRgb_default(convertProphotoToXyz50_default(color))
	}
};
var definition_default$10 = definition$14;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rec2020/convertXyz65ToRec2020.js
const α$1 = 1.09929682680944;
const β$1 = .018053968510807;
const gamma = (v) => {
	const abs$2 = Math.abs(v);
	if (abs$2 > β$1) return (Math.sign(v) || 1) * (α$1 * Math.pow(abs$2, .45) - (α$1 - 1));
	return 4.5 * v;
};
const convertXyz65ToRec2020 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "rec2020",
		r: gamma(x * 1.7166511879712683 - y * .3556707837763925 - .2533662813736599 * z),
		g: gamma(x * -.6666843518324893 + y * 1.6164812366349395 + .0157685458139111 * z),
		b: gamma(x * .0176398574453108 - y * .0427706132578085 + .9421031212354739 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToRec2020_default = convertXyz65ToRec2020;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rec2020/convertRec2020ToXyz65.js
const α = 1.09929682680944;
const β = .018053968510807;
const linearize = (v = 0) => {
	let abs$2 = Math.abs(v);
	if (abs$2 < β * 4.5) return v / 4.5;
	return (Math.sign(v) || 1) * Math.pow((abs$2 + α - 1) / α, 1 / .45);
};
const convertRec2020ToXyz65 = (rec2020$2) => {
	let r$2 = linearize(rec2020$2.r);
	let g = linearize(rec2020$2.g);
	let b = linearize(rec2020$2.b);
	let res = {
		mode: "xyz65",
		x: .6369580483012911 * r$2 + .1446169035862083 * g + .1688809751641721 * b,
		y: .262700212011267 * r$2 + .6779980715188708 * g + .059301716469862 * b,
		z: 0 * r$2 + .0280726930490874 * g + 1.0609850577107909 * b
	};
	if (rec2020$2.alpha !== void 0) res.alpha = rec2020$2.alpha;
	return res;
};
var convertRec2020ToXyz65_default = convertRec2020ToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rec2020/definition.js
const definition$13 = {
	...definition_default$12,
	mode: "rec2020",
	fromMode: {
		xyz65: convertXyz65ToRec2020_default,
		rgb: (color) => convertXyz65ToRec2020_default(convertRgbToXyz65_default(color))
	},
	toMode: {
		xyz65: convertRec2020ToXyz65_default,
		rgb: (color) => convertXyz65ToRgb_default(convertRec2020ToXyz65_default(color))
	},
	parse: ["rec2020"],
	serialize: "rec2020"
};
var definition_default$11 = definition$13;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz50/definition.js
const definition$12 = {
	mode: "xyz50",
	parse: ["xyz-d50"],
	serialize: "xyz-d50",
	toMode: {
		rgb: convertXyz50ToRgb_default,
		lab: convertXyz50ToLab_default
	},
	fromMode: {
		rgb: convertRgbToXyz50_default,
		lab: convertLabToXyz50_default
	},
	channels: [
		"x",
		"y",
		"z",
		"alpha"
	],
	ranges: {
		x: [0, .964],
		y: [0, .999],
		z: [0, .825]
	},
	interpolate: {
		x: interpolatorLinear,
		y: interpolatorLinear,
		z: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$13 = definition$12;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/convertXyz65ToXyz50.js
const convertXyz65ToXyz50 = (xyz65$2) => {
	let { x, y, z, alpha } = xyz65$2;
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "xyz50",
		x: 1.0479298208405488 * x + .0229467933410191 * y - .0501922295431356 * z,
		y: .0296278156881593 * x + .990434484573249 * y - .0170738250293851 * z,
		z: -.0092430581525912 * x + .0150551448965779 * y + .7518742899580008 * z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToXyz50_default = convertXyz65ToXyz50;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/convertXyz50ToXyz65.js
const convertXyz50ToXyz65 = (xyz50$2) => {
	let { x, y, z, alpha } = xyz50$2;
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "xyz65",
		x: .9554734527042182 * x - .0230985368742614 * y + .0632593086610217 * z,
		y: -.0283697069632081 * x + 1.0099954580058226 * y + .021041398966943 * z,
		z: .0123140016883199 * x - .0205076964334779 * y + 1.3303659366080753 * z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToXyz65_default = convertXyz50ToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/definition.js
const definition$11 = {
	mode: "xyz65",
	toMode: {
		rgb: convertXyz65ToRgb_default,
		xyz50: convertXyz65ToXyz50_default
	},
	fromMode: {
		rgb: convertRgbToXyz65_default,
		xyz50: convertXyz50ToXyz65_default
	},
	ranges: {
		x: [0, .95],
		y: [0, 1],
		z: [0, 1.088]
	},
	channels: [
		"x",
		"y",
		"z",
		"alpha"
	],
	parse: ["xyz", "xyz-d65"],
	serialize: "xyz-d65",
	interpolate: {
		x: interpolatorLinear,
		y: interpolatorLinear,
		z: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$14 = definition$11;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/bootstrap/css.js
const a98$1 = useMode(definition_default);
const hsl$1 = useMode(definition_default$1);
const hsv$1 = useMode(definition_default$19);
const hwb$1 = useMode(definition_default$2);
const lab$1 = useMode(definition_default$3);
const lab65$1 = useMode(definition_default$4);
const lch$1 = useMode(definition_default$5);
const lch65$1 = useMode(definition_default$23);
const lrgb$1 = useMode(definition_default$6);
const oklab$1 = useMode(definition_default$7);
const oklch$1 = useMode(definition_default$8);
const p3$1 = useMode(definition_default$9);
const prophoto$1 = useMode(definition_default$10);
const rec2020$1 = useMode(definition_default$11);
const rgb$1 = useMode(definition_default$12);
const xyz50$1 = useMode(definition_default$13);
const xyz65$1 = useMode(definition_default$14);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/cubehelix/constants.js
const M = [
	-.14861,
	1.78277,
	-.29227,
	-.90649,
	1.97294,
	0
];
const degToRad = Math.PI / 180;
const radToDeg = 180 / Math.PI;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/cubehelix/convertRgbToCubehelix.js
let DE = M[3] * M[4];
let BE = M[1] * M[4];
let BCAD = M[1] * M[2] - M[0] * M[3];
const convertRgbToCubehelix = ({ r: r$2, g, b, alpha }) => {
	if (r$2 === void 0) r$2 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let l = (BCAD * b + r$2 * DE - g * BE) / (BCAD + DE - BE);
	let x = b - l;
	let y = (M[4] * (g - l) - M[2] * x) / M[3];
	let res = {
		mode: "cubehelix",
		l,
		s: l === 0 || l === 1 ? void 0 : Math.sqrt(x * x + y * y) / (M[4] * l * (1 - l))
	};
	if (res.s) res.h = Math.atan2(y, x) * radToDeg - 120;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToCubehelix_default = convertRgbToCubehelix;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/cubehelix/convertCubehelixToRgb.js
const convertCubehelixToRgb = ({ h, s, l, alpha }) => {
	let res = { mode: "rgb" };
	h = (h === void 0 ? 0 : h + 120) * degToRad;
	if (l === void 0) l = 0;
	let amp = s === void 0 ? 0 : s * l * (1 - l);
	let cosh = Math.cos(h);
	let sinh = Math.sin(h);
	res.r = l + amp * (M[0] * cosh + M[1] * sinh);
	res.g = l + amp * (M[2] * cosh + M[3] * sinh);
	res.b = l + amp * (M[4] * cosh + M[5] * sinh);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertCubehelixToRgb_default = convertCubehelixToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/cubehelix/definition.js
const definition$10 = {
	mode: "cubehelix",
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	parse: ["--cubehelix"],
	serialize: "--cubehelix",
	ranges: {
		h: [0, 360],
		s: [0, 4.614],
		l: [0, 1]
	},
	fromMode: { rgb: convertRgbToCubehelix_default },
	toMode: { rgb: convertCubehelixToRgb_default },
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$15 = definition$10;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/dlch/constants.js
const kE = 1;
const kCH = 1;
const θ = 26 / 180 * Math.PI;
const cosθ = Math.cos(θ);
const sinθ = Math.sin(θ);
const factor = 100 / Math.log(139 / 100);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/dlch/convertDlchToLab65.js
const convertDlchToLab65 = ({ l, c: c$2, h, alpha }) => {
	if (l === void 0) l = 0;
	if (c$2 === void 0) c$2 = 0;
	if (h === void 0) h = 0;
	let res = {
		mode: "lab65",
		l: (Math.exp(l * kE / factor) - 1) / .0039
	};
	let G = (Math.exp(.0435 * c$2 * kCH * kE) - 1) / .075;
	let e$4 = G * Math.cos(h / 180 * Math.PI - θ);
	let f$3 = G * Math.sin(h / 180 * Math.PI - θ);
	res.a = e$4 * cosθ - f$3 / .83 * sinθ;
	res.b = e$4 * sinθ + f$3 / .83 * cosθ;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertDlchToLab65_default = convertDlchToLab65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/dlch/convertLab65ToDlch.js
const convertLab65ToDlch = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let e$4 = a * cosθ + b * sinθ;
	let f$3 = .83 * (b * cosθ - a * sinθ);
	let G = Math.sqrt(e$4 * e$4 + f$3 * f$3);
	let res = {
		mode: "dlch",
		l: factor / kE * Math.log(1 + .0039 * l),
		c: Math.log(1 + .075 * G) / (.0435 * kCH * kE)
	};
	if (res.c) res.h = normalizeHue_default((Math.atan2(f$3, e$4) + θ) / Math.PI * 180);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLab65ToDlch_default = convertLab65ToDlch;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/dlab/definition.js
const convertDlabToLab65 = (c$2) => convertDlchToLab65_default(convertLabToLch_default(c$2, "dlch"));
const convertLab65ToDlab = (c$2) => convertLchToLab_default(convertLab65ToDlch_default(c$2), "dlab");
const definition$9 = {
	mode: "dlab",
	parse: ["--din99o-lab"],
	serialize: "--din99o-lab",
	toMode: {
		lab65: convertDlabToLab65,
		rgb: (c$2) => convertLab65ToRgb_default(convertDlabToLab65(c$2))
	},
	fromMode: {
		lab65: convertLab65ToDlab,
		rgb: (c$2) => convertLab65ToDlab(convertRgbToLab65_default(c$2))
	},
	channels: [
		"l",
		"a",
		"b",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		a: [-40.09, 45.501],
		b: [-40.469, 44.344]
	},
	interpolate: {
		l: interpolatorLinear,
		a: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$16 = definition$9;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/dlch/definition.js
const definition$8 = {
	mode: "dlch",
	parse: ["--din99o-lch"],
	serialize: "--din99o-lch",
	toMode: {
		lab65: convertDlchToLab65_default,
		dlab: (c$2) => convertLchToLab_default(c$2, "dlab"),
		rgb: (c$2) => convertLab65ToRgb_default(convertDlchToLab65_default(c$2))
	},
	fromMode: {
		lab65: convertLab65ToDlch_default,
		dlab: (c$2) => convertLabToLch_default(c$2, "dlch"),
		rgb: (c$2) => convertLab65ToDlch_default(convertRgbToLab65_default(c$2))
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		c: [0, 51.484],
		h: [0, 360]
	},
	interpolate: {
		l: interpolatorLinear,
		c: interpolatorLinear,
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$17 = definition$8;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsi/convertHsiToRgb.js
function convertHsiToRgb({ h, s, i, alpha }) {
	h = normalizeHue_default(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (i === void 0) i = 0;
	let f$3 = Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: i * (1 + s * (3 / (2 - f$3) - 1)),
				g: i * (1 + s * (3 * (1 - f$3) / (2 - f$3) - 1)),
				b: i * (1 - s)
			};
			break;
		case 1:
			res = {
				r: i * (1 + s * (3 * (1 - f$3) / (2 - f$3) - 1)),
				g: i * (1 + s * (3 / (2 - f$3) - 1)),
				b: i * (1 - s)
			};
			break;
		case 2:
			res = {
				r: i * (1 - s),
				g: i * (1 + s * (3 / (2 - f$3) - 1)),
				b: i * (1 + s * (3 * (1 - f$3) / (2 - f$3) - 1))
			};
			break;
		case 3:
			res = {
				r: i * (1 - s),
				g: i * (1 + s * (3 * (1 - f$3) / (2 - f$3) - 1)),
				b: i * (1 + s * (3 / (2 - f$3) - 1))
			};
			break;
		case 4:
			res = {
				r: i * (1 + s * (3 * (1 - f$3) / (2 - f$3) - 1)),
				g: i * (1 - s),
				b: i * (1 + s * (3 / (2 - f$3) - 1))
			};
			break;
		case 5:
			res = {
				r: i * (1 + s * (3 / (2 - f$3) - 1)),
				g: i * (1 - s),
				b: i * (1 + s * (3 * (1 - f$3) / (2 - f$3) - 1))
			};
			break;
		default: res = {
			r: i * (1 - s),
			g: i * (1 - s),
			b: i * (1 - s)
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsi/convertRgbToHsi.js
function convertRgbToHsi({ r: r$2, g, b, alpha }) {
	if (r$2 === void 0) r$2 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$2 = Math.max(r$2, g, b), m = Math.min(r$2, g, b);
	let res = {
		mode: "hsi",
		s: r$2 + g + b === 0 ? 0 : 1 - 3 * m / (r$2 + g + b),
		i: (r$2 + g + b) / 3
	};
	if (M$2 - m !== 0) res.h = (M$2 === r$2 ? (g - b) / (M$2 - m) + (g < b) * 6 : M$2 === g ? (b - r$2) / (M$2 - m) + 2 : (r$2 - g) / (M$2 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsi/definition.js
const definition$7 = {
	mode: "hsi",
	toMode: { rgb: convertHsiToRgb },
	parse: ["--hsi"],
	serialize: "--hsi",
	fromMode: { rgb: convertRgbToHsi },
	channels: [
		"h",
		"s",
		"i",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		i: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$18 = definition$7;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hdr/constants.js
const YW = 203;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hdr/transfer.js
const M1 = .1593017578125;
const M2 = 78.84375;
const C1 = .8359375;
const C2 = 18.8515625;
const C3 = 18.6875;
function transferPqDecode(v) {
	if (v < 0) return 0;
	const c$2 = Math.pow(v, 1 / M2);
	return 1e4 * Math.pow(Math.max(0, c$2 - C1) / (C2 - C3 * c$2), 1 / M1);
}
function transferPqEncode(v) {
	if (v < 0) return 0;
	const c$2 = Math.pow(v / 1e4, M1);
	return Math.pow((C1 + C2 * c$2) / (1 + C3 * c$2), M2);
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/itp/convertItpToXyz65.js
const toRel = (c$2) => Math.max(c$2 / YW, 0);
const convertItpToXyz65 = ({ i, t, p: p$3, alpha }) => {
	if (i === void 0) i = 0;
	if (t === void 0) t = 0;
	if (p$3 === void 0) p$3 = 0;
	const l = transferPqDecode(i + .008609037037932761 * t + .11102962500302593 * p$3);
	const m = transferPqDecode(i - .00860903703793275 * t - .11102962500302599 * p$3);
	const s = transferPqDecode(i + .5600313357106791 * t - .32062717498731885 * p$3);
	const res = {
		mode: "xyz65",
		x: toRel(2.070152218389422 * l - 1.3263473389671556 * m + .2066510476294051 * s),
		y: toRel(.3647385209748074 * l + .680566024947227 * m - .0453045459220346 * s),
		z: toRel(-.049747207535812 * l - .0492609666966138 * m + 1.1880659249923042 * s)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertItpToXyz65_default = convertItpToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/itp/convertXyz65ToItp.js
const toAbs = (c$2 = 0) => Math.max(c$2 * YW, 0);
const convertXyz65ToItp = ({ x, y, z, alpha }) => {
	const absX = toAbs(x);
	const absY = toAbs(y);
	const absZ = toAbs(z);
	const l = transferPqEncode(.3592832590121217 * absX + .6976051147779502 * absY - .0358915932320289 * absZ);
	const m = transferPqEncode(-.1920808463704995 * absX + 1.1004767970374323 * absY + .0753748658519118 * absZ);
	const s = transferPqEncode(.0070797844607477 * absX + .0748396662186366 * absY + .8433265453898765 * absZ);
	const i = .5 * l + .5 * m;
	const t = 1.61376953125 * l - 3.323486328125 * m + 1.709716796875 * s;
	const p$3 = 4.378173828125 * l - 4.24560546875 * m - .132568359375 * s;
	const res = {
		mode: "itp",
		i,
		t,
		p: p$3
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToItp_default = convertXyz65ToItp;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/itp/definition.js
const definition$6 = {
	mode: "itp",
	channels: [
		"i",
		"t",
		"p",
		"alpha"
	],
	parse: ["--ictcp"],
	serialize: "--ictcp",
	toMode: {
		xyz65: convertItpToXyz65_default,
		rgb: (color) => convertXyz65ToRgb_default(convertItpToXyz65_default(color))
	},
	fromMode: {
		xyz65: convertXyz65ToItp_default,
		rgb: (color) => convertXyz65ToItp_default(convertRgbToXyz65_default(color))
	},
	ranges: {
		i: [0, .581],
		t: [-.369, .272],
		p: [-.164, .331]
	},
	interpolate: {
		i: interpolatorLinear,
		t: interpolatorLinear,
		p: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$20 = definition$6;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jab/convertXyz65ToJab.js
const p$1 = 134.03437499999998;
const d0$1 = 16295499532821565e-27;
const jabPqEncode = (v) => {
	if (v < 0) return 0;
	let vn$3 = Math.pow(v / 1e4, M1);
	return Math.pow((C1 + C2 * vn$3) / (1 + C3 * vn$3), p$1);
};
const abs = (v = 0) => Math.max(v * 203, 0);
const convertXyz65ToJab = ({ x, y, z, alpha }) => {
	x = abs(x);
	y = abs(y);
	z = abs(z);
	let xp = 1.15 * x - .15 * z;
	let yp = .66 * y + .34 * x;
	let l = jabPqEncode(.41478972 * xp + .579999 * yp + .014648 * z);
	let m = jabPqEncode(-.20151 * xp + 1.120649 * yp + .0531008 * z);
	let s = jabPqEncode(-.0166008 * xp + .2648 * yp + .6684799 * z);
	let i = (l + m) / 2;
	let res = {
		mode: "jab",
		j: .44 * i / (1 - .56 * i) - d0$1,
		a: 3.524 * l - 4.066708 * m + .542708 * s,
		b: .199076 * l + 1.096799 * m - 1.295875 * s
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToJab_default = convertXyz65ToJab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jab/convertJabToXyz65.js
const p = 134.03437499999998;
const d0 = 16295499532821565e-27;
const jabPqDecode = (v) => {
	if (v < 0) return 0;
	let vp = Math.pow(v, 1 / p);
	return 1e4 * Math.pow((C1 - vp) / (C3 * vp - C2), 1 / M1);
};
const rel = (v) => v / 203;
const convertJabToXyz65 = ({ j, a, b, alpha }) => {
	if (j === void 0) j = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let i = (j + d0) / (.44 + .56 * (j + d0));
	let l = jabPqDecode(i + .13860504 * a + .058047316 * b);
	let m = jabPqDecode(i - .13860504 * a - .058047316 * b);
	let s = jabPqDecode(i - .096019242 * a - .8118919 * b);
	let res = {
		mode: "xyz65",
		x: rel(1.661373024652174 * l - .914523081304348 * m + .23136208173913045 * s),
		y: rel(-.3250758611844533 * l + 1.571847026732543 * m - .21825383453227928 * s),
		z: rel(-.090982811 * l - .31272829 * m + 1.5227666 * s)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJabToXyz65_default = convertJabToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jab/convertRgbToJab.js
const convertRgbToJab = (rgb$3) => {
	let res = convertXyz65ToJab_default(convertRgbToXyz65_default(rgb$3));
	if (rgb$3.r === rgb$3.b && rgb$3.b === rgb$3.g) res.a = res.b = 0;
	return res;
};
var convertRgbToJab_default = convertRgbToJab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jab/convertJabToRgb.js
const convertJabToRgb = (color) => convertXyz65ToRgb_default(convertJabToXyz65_default(color));
var convertJabToRgb_default = convertJabToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jab/definition.js
const definition$5 = {
	mode: "jab",
	channels: [
		"j",
		"a",
		"b",
		"alpha"
	],
	parse: ["--jzazbz"],
	serialize: "--jzazbz",
	fromMode: {
		rgb: convertRgbToJab_default,
		xyz65: convertXyz65ToJab_default
	},
	toMode: {
		rgb: convertJabToRgb_default,
		xyz65: convertJabToXyz65_default
	},
	ranges: {
		j: [0, .222],
		a: [-.109, .129],
		b: [-.185, .134]
	},
	interpolate: {
		j: interpolatorLinear,
		a: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$21 = definition$5;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jch/convertJabToJch.js
const convertJabToJch = ({ j, a, b, alpha }) => {
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let c$2 = Math.sqrt(a * a + b * b);
	let res = {
		mode: "jch",
		j,
		c: c$2
	};
	if (c$2) res.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJabToJch_default = convertJabToJch;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jch/convertJchToJab.js
const convertJchToJab = ({ j, c: c$2, h, alpha }) => {
	if (h === void 0) h = 0;
	let res = {
		mode: "jab",
		j,
		a: c$2 ? c$2 * Math.cos(h / 180 * Math.PI) : 0,
		b: c$2 ? c$2 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJchToJab_default = convertJchToJab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jch/definition.js
const definition$4 = {
	mode: "jch",
	parse: ["--jzczhz"],
	serialize: "--jzczhz",
	toMode: {
		jab: convertJchToJab_default,
		rgb: (c$2) => convertJabToRgb_default(convertJchToJab_default(c$2))
	},
	fromMode: {
		rgb: (c$2) => convertJabToJch_default(convertRgbToJab_default(c$2)),
		jab: convertJabToJch_default
	},
	channels: [
		"j",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		j: [0, .221],
		c: [0, .19],
		h: [0, 360]
	},
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		c: interpolatorLinear,
		j: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$22 = definition$4;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lchuv/convertLuvToLchuv.js
const convertLuvToLchuv = ({ l, u, v, alpha }) => {
	if (u === void 0) u = 0;
	if (v === void 0) v = 0;
	let c$2 = Math.sqrt(u * u + v * v);
	let res = {
		mode: "lchuv",
		l,
		c: c$2
	};
	if (c$2) res.h = normalizeHue_default(Math.atan2(v, u) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLuvToLchuv_default = convertLuvToLchuv;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lchuv/convertLchuvToLuv.js
const convertLchuvToLuv = ({ l, c: c$2, h, alpha }) => {
	if (h === void 0) h = 0;
	let res = {
		mode: "luv",
		l,
		u: c$2 ? c$2 * Math.cos(h / 180 * Math.PI) : 0,
		v: c$2 ? c$2 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLchuvToLuv_default = convertLchuvToLuv;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/luv/convertXyz50ToLuv.js
const u_fn$1 = (x, y, z) => 4 * x / (x + 15 * y + 3 * z);
const v_fn$1 = (x, y, z) => 9 * y / (x + 15 * y + 3 * z);
const un$1 = u_fn$1(D50.X, D50.Y, D50.Z);
const vn$1 = v_fn$1(D50.X, D50.Y, D50.Z);
const l_fn = (value) => value <= e ? k * value : 116 * Math.cbrt(value) - 16;
const convertXyz50ToLuv = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let l = l_fn(y / D50.Y);
	let u = u_fn$1(x, y, z);
	let v = v_fn$1(x, y, z);
	if (!isFinite(u) || !isFinite(v)) l = u = v = 0;
	else {
		u = 13 * l * (u - un$1);
		v = 13 * l * (v - vn$1);
	}
	let res = {
		mode: "luv",
		l,
		u,
		v
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToLuv_default = convertXyz50ToLuv;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/luv/convertLuvToXyz50.js
const u_fn = (x, y, z) => 4 * x / (x + 15 * y + 3 * z);
const v_fn = (x, y, z) => 9 * y / (x + 15 * y + 3 * z);
const un = u_fn(D50.X, D50.Y, D50.Z);
const vn = v_fn(D50.X, D50.Y, D50.Z);
const convertLuvToXyz50 = ({ l, u, v, alpha }) => {
	if (l === void 0) l = 0;
	if (l === 0) return {
		mode: "xyz50",
		x: 0,
		y: 0,
		z: 0
	};
	if (u === void 0) u = 0;
	if (v === void 0) v = 0;
	let up = u / (13 * l) + un;
	let vp = v / (13 * l) + vn;
	let y = D50.Y * (l <= 8 ? l / k : Math.pow((l + 16) / 116, 3));
	let x = y * (9 * up) / (4 * vp);
	let z = y * (12 - 3 * up - 20 * vp) / (4 * vp);
	let res = {
		mode: "xyz50",
		x,
		y,
		z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLuvToXyz50_default = convertLuvToXyz50;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lchuv/definition.js
const convertRgbToLchuv = (rgb$3) => convertLuvToLchuv_default(convertXyz50ToLuv_default(convertRgbToXyz50_default(rgb$3)));
const convertLchuvToRgb = (lchuv$1) => convertXyz50ToRgb_default(convertLuvToXyz50_default(convertLchuvToLuv_default(lchuv$1)));
const definition$3 = {
	mode: "lchuv",
	toMode: {
		luv: convertLchuvToLuv_default,
		rgb: convertLchuvToRgb
	},
	fromMode: {
		rgb: convertRgbToLchuv,
		luv: convertLuvToLchuv_default
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	parse: ["--lchuv"],
	serialize: "--lchuv",
	ranges: {
		l: [0, 100],
		c: [0, 176.956],
		h: [0, 360]
	},
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		c: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$24 = definition$3;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/luv/definition.js
const definition$2 = {
	mode: "luv",
	toMode: {
		xyz50: convertLuvToXyz50_default,
		rgb: (luv$1) => convertXyz50ToRgb_default(convertLuvToXyz50_default(luv$1))
	},
	fromMode: {
		xyz50: convertXyz50ToLuv_default,
		rgb: (rgb$3) => convertXyz50ToLuv_default(convertRgbToXyz50_default(rgb$3))
	},
	channels: [
		"l",
		"u",
		"v",
		"alpha"
	],
	parse: ["--luv"],
	serialize: "--luv",
	ranges: {
		l: [0, 100],
		u: [-84.936, 175.042],
		v: [-125.882, 87.243]
	},
	interpolate: {
		l: interpolatorLinear,
		u: interpolatorLinear,
		v: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$25 = definition$2;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsl/helpers.js
function toe(x) {
	const k_1 = .206;
	const k_2 = .03;
	const k_3 = (1 + k_1) / (1 + k_2);
	return .5 * (k_3 * x - k_1 + Math.sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4 * k_2 * k_3 * x));
}
function toe_inv(x) {
	const k_1 = .206;
	const k_2 = .03;
	const k_3 = (1 + k_1) / (1 + k_2);
	return (x * x + k_1 * x) / (k_3 * (x + k_2));
}
function compute_max_saturation(a, b) {
	let k0, k1, k2, k3, k4, wl, wm, ws;
	if (-1.88170328 * a - .80936493 * b > 1) {
		k0 = 1.19086277;
		k1 = 1.76576728;
		k2 = .59662641;
		k3 = .75515197;
		k4 = .56771245;
		wl = 4.0767416621;
		wm = -3.3077115913;
		ws = .2309699292;
	} else if (1.81444104 * a - 1.19445276 * b > 1) {
		k0 = .73956515;
		k1 = -.45954404;
		k2 = .08285427;
		k3 = .1254107;
		k4 = .14503204;
		wl = -1.2684380046;
		wm = 2.6097574011;
		ws = -.3413193965;
	} else {
		k0 = 1.35733652;
		k1 = -.00915799;
		k2 = -1.1513021;
		k3 = -.50559606;
		k4 = .00692167;
		wl = -.0041960863;
		wm = -.7034186147;
		ws = 1.707614701;
	}
	let S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;
	let k_l = .3963377774 * a + .2158037573 * b;
	let k_m = -.1055613458 * a - .0638541728 * b;
	let k_s = -.0894841775 * a - 1.291485548 * b;
	{
		let l_ = 1 + S * k_l;
		let m_ = 1 + S * k_m;
		let s_ = 1 + S * k_s;
		let l = l_ * l_ * l_;
		let m = m_ * m_ * m_;
		let s = s_ * s_ * s_;
		let l_dS = 3 * k_l * l_ * l_;
		let m_dS = 3 * k_m * m_ * m_;
		let s_dS = 3 * k_s * s_ * s_;
		let l_dS2 = 6 * k_l * k_l * l_;
		let m_dS2 = 6 * k_m * k_m * m_;
		let s_dS2 = 6 * k_s * k_s * s_;
		let f$3 = wl * l + wm * m + ws * s;
		let f1 = wl * l_dS + wm * m_dS + ws * s_dS;
		let f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;
		S = S - f$3 * f1 / (f1 * f1 - .5 * f$3 * f2);
	}
	return S;
}
function find_cusp(a, b) {
	let S_cusp = compute_max_saturation(a, b);
	let rgb$3 = convertOklabToLrgb_default({
		l: 1,
		a: S_cusp * a,
		b: S_cusp * b
	});
	let L_cusp = Math.cbrt(1 / Math.max(rgb$3.r, rgb$3.g, rgb$3.b));
	let C_cusp = L_cusp * S_cusp;
	return [L_cusp, C_cusp];
}
function find_gamut_intersection(a, b, L1, C1$2, L0, cusp = null) {
	if (!cusp) cusp = find_cusp(a, b);
	let t;
	if ((L1 - L0) * cusp[1] - (cusp[0] - L0) * C1$2 <= 0) t = cusp[1] * L0 / (C1$2 * cusp[0] + cusp[1] * (L0 - L1));
	else {
		t = cusp[1] * (L0 - 1) / (C1$2 * (cusp[0] - 1) + cusp[1] * (L0 - L1));
		{
			let dL = L1 - L0;
			let dC = C1$2;
			let k_l = .3963377774 * a + .2158037573 * b;
			let k_m = -.1055613458 * a - .0638541728 * b;
			let k_s = -.0894841775 * a - 1.291485548 * b;
			let l_dt = dL + dC * k_l;
			let m_dt = dL + dC * k_m;
			let s_dt = dL + dC * k_s;
			{
				let L = L0 * (1 - t) + t * L1;
				let C = t * C1$2;
				let l_ = L + C * k_l;
				let m_ = L + C * k_m;
				let s_ = L + C * k_s;
				let l = l_ * l_ * l_;
				let m = m_ * m_ * m_;
				let s = s_ * s_ * s_;
				let ldt = 3 * l_dt * l_ * l_;
				let mdt = 3 * m_dt * m_ * m_;
				let sdt = 3 * s_dt * s_ * s_;
				let ldt2 = 6 * l_dt * l_dt * l_;
				let mdt2 = 6 * m_dt * m_dt * m_;
				let sdt2 = 6 * s_dt * s_dt * s_;
				let r$2 = 4.0767416621 * l - 3.3077115913 * m + .2309699292 * s - 1;
				let r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + .2309699292 * sdt;
				let r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + .2309699292 * sdt2;
				let u_r = r1 / (r1 * r1 - .5 * r$2 * r2);
				let t_r = -r$2 * u_r;
				let g = -1.2684380046 * l + 2.6097574011 * m - .3413193965 * s - 1;
				let g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - .3413193965 * sdt;
				let g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - .3413193965 * sdt2;
				let u_g = g1 / (g1 * g1 - .5 * g * g2);
				let t_g = -g * u_g;
				let b$1 = -.0041960863 * l - .7034186147 * m + 1.707614701 * s - 1;
				let b1 = -.0041960863 * ldt - .7034186147 * mdt + 1.707614701 * sdt;
				let b2 = -.0041960863 * ldt2 - .7034186147 * mdt2 + 1.707614701 * sdt2;
				let u_b = b1 / (b1 * b1 - .5 * b$1 * b2);
				let t_b = -b$1 * u_b;
				t_r = u_r >= 0 ? t_r : 1e6;
				t_g = u_g >= 0 ? t_g : 1e6;
				t_b = u_b >= 0 ? t_b : 1e6;
				t += Math.min(t_r, Math.min(t_g, t_b));
			}
		}
	}
	return t;
}
function get_ST_max(a_, b_, cusp = null) {
	if (!cusp) cusp = find_cusp(a_, b_);
	let L = cusp[0];
	let C = cusp[1];
	return [C / L, C / (1 - L)];
}
function get_Cs(L, a_, b_) {
	let cusp = find_cusp(a_, b_);
	let C_max = find_gamut_intersection(a_, b_, L, 1, L, cusp);
	let ST_max = get_ST_max(a_, b_, cusp);
	let S_mid = .11516993 + 1 / (7.4477897 + 4.1590124 * b_ + a_ * (-2.19557347 + 1.75198401 * b_ + a_ * (-2.13704948 - 10.02301043 * b_ + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_))));
	let T_mid = .11239642 + 1 / (1.6132032 - .68124379 * b_ + a_ * (.40370612 + .90148123 * b_ + a_ * (-.27087943 + .6122399 * b_ + a_ * (.00299215 - .45399568 * b_ - .14661872 * a_))));
	let k$4 = C_max / Math.min(L * ST_max[0], (1 - L) * ST_max[1]);
	let C_a = L * S_mid;
	let C_b = (1 - L) * T_mid;
	let C_mid = .9 * k$4 * Math.sqrt(Math.sqrt(1 / (1 / (C_a * C_a * C_a * C_a) + 1 / (C_b * C_b * C_b * C_b))));
	C_a = L * .4;
	C_b = (1 - L) * .8;
	return [
		Math.sqrt(1 / (1 / (C_a * C_a) + 1 / (C_b * C_b))),
		C_mid,
		C_max
	];
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsl/convertOklabToOkhsl.js
function convertOklabToOkhsl(lab$2) {
	const l = lab$2.l !== void 0 ? lab$2.l : 0;
	const a = lab$2.a !== void 0 ? lab$2.a : 0;
	const b = lab$2.b !== void 0 ? lab$2.b : 0;
	const ret = {
		mode: "okhsl",
		l: toe(l)
	};
	if (lab$2.alpha !== void 0) ret.alpha = lab$2.alpha;
	let c$2 = Math.sqrt(a * a + b * b);
	if (!c$2) {
		ret.s = 0;
		return ret;
	}
	let [C_0, C_mid, C_max] = get_Cs(l, a / c$2, b / c$2);
	let s;
	if (c$2 < C_mid) {
		let k_0 = 0;
		let k_1 = .8 * C_0;
		let k_2 = 1 - k_1 / C_mid;
		s = (c$2 - k_0) / (k_1 + k_2 * (c$2 - k_0)) * .8;
	} else {
		let k_0 = C_mid;
		let k_1 = .2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
		let k_2 = 1 - k_1 / (C_max - C_mid);
		s = .8 + .2 * ((c$2 - k_0) / (k_1 + k_2 * (c$2 - k_0)));
	}
	if (s) {
		ret.s = s;
		ret.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	}
	return ret;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsl/convertOkhslToOklab.js
function convertOkhslToOklab(hsl$2) {
	let h = hsl$2.h !== void 0 ? hsl$2.h : 0;
	let s = hsl$2.s !== void 0 ? hsl$2.s : 0;
	let l = hsl$2.l !== void 0 ? hsl$2.l : 0;
	const ret = {
		mode: "oklab",
		l: toe_inv(l)
	};
	if (hsl$2.alpha !== void 0) ret.alpha = hsl$2.alpha;
	if (!s || l === 1) {
		ret.a = ret.b = 0;
		return ret;
	}
	let a_ = Math.cos(h / 180 * Math.PI);
	let b_ = Math.sin(h / 180 * Math.PI);
	let [C_0, C_mid, C_max] = get_Cs(ret.l, a_, b_);
	let t, k_0, k_1, k_2;
	if (s < .8) {
		t = 1.25 * s;
		k_0 = 0;
		k_1 = .8 * C_0;
		k_2 = 1 - k_1 / C_mid;
	} else {
		t = 5 * (s - .8);
		k_0 = C_mid;
		k_1 = .2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
		k_2 = 1 - k_1 / (C_max - C_mid);
	}
	let C = k_0 + t * k_1 / (1 - k_2 * t);
	ret.a = C * a_;
	ret.b = C * b_;
	return ret;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsl/modeOkhsl.js
const modeOkhsl = {
	...definition_default$1,
	mode: "okhsl",
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	parse: ["--okhsl"],
	serialize: "--okhsl",
	fromMode: {
		oklab: convertOklabToOkhsl,
		rgb: (c$2) => convertOklabToOkhsl(convertRgbToOklab_default(c$2))
	},
	toMode: {
		oklab: convertOkhslToOklab,
		rgb: (c$2) => convertOklabToRgb_default(convertOkhslToOklab(c$2))
	}
};
var modeOkhsl_default = modeOkhsl;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsv/convertOklabToOkhsv.js
function convertOklabToOkhsv(lab$2) {
	let l = lab$2.l !== void 0 ? lab$2.l : 0;
	let a = lab$2.a !== void 0 ? lab$2.a : 0;
	let b = lab$2.b !== void 0 ? lab$2.b : 0;
	let c$2 = Math.sqrt(a * a + b * b);
	let a_ = c$2 ? a / c$2 : 1;
	let b_ = c$2 ? b / c$2 : 1;
	let [S_max, T] = get_ST_max(a_, b_);
	let S_0 = .5;
	let k$4 = 1 - S_0 / S_max;
	let t = T / (c$2 + l * T);
	let L_v = t * l;
	let C_v = t * c$2;
	let L_vt = toe_inv(L_v);
	let C_vt = C_v * L_vt / L_v;
	let rgb_scale = convertOklabToLrgb_default({
		l: L_vt,
		a: a_ * C_vt,
		b: b_ * C_vt
	});
	let scale_L = Math.cbrt(1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0));
	l = l / scale_L;
	c$2 = c$2 / scale_L * toe(l) / l;
	l = toe(l);
	const ret = {
		mode: "okhsv",
		s: c$2 ? (S_0 + T) * C_v / (T * S_0 + T * k$4 * C_v) : 0,
		v: l ? l / L_v : 0
	};
	if (ret.s) ret.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	if (lab$2.alpha !== void 0) ret.alpha = lab$2.alpha;
	return ret;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsv/convertOkhsvToOklab.js
function convertOkhsvToOklab(hsv$2) {
	const ret = { mode: "oklab" };
	if (hsv$2.alpha !== void 0) ret.alpha = hsv$2.alpha;
	const h = hsv$2.h !== void 0 ? hsv$2.h : 0;
	const s = hsv$2.s !== void 0 ? hsv$2.s : 0;
	const v = hsv$2.v !== void 0 ? hsv$2.v : 0;
	const a_ = Math.cos(h / 180 * Math.PI);
	const b_ = Math.sin(h / 180 * Math.PI);
	const [S_max, T] = get_ST_max(a_, b_);
	const S_0 = .5;
	const k$4 = 1 - S_0 / S_max;
	const L_v = 1 - s * S_0 / (S_0 + T - T * k$4 * s);
	const C_v = s * T * S_0 / (S_0 + T - T * k$4 * s);
	const L_vt = toe_inv(L_v);
	const C_vt = C_v * L_vt / L_v;
	const rgb_scale = convertOklabToLrgb_default({
		l: L_vt,
		a: a_ * C_vt,
		b: b_ * C_vt
	});
	const scale_L = Math.cbrt(1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0));
	const L_new = toe_inv(v * L_v);
	const C = C_v * L_new / L_v;
	ret.l = L_new * scale_L;
	ret.a = C * a_ * scale_L;
	ret.b = C * b_ * scale_L;
	return ret;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsv/modeOkhsv.js
const modeOkhsv = {
	...definition_default$19,
	mode: "okhsv",
	channels: [
		"h",
		"s",
		"v",
		"alpha"
	],
	parse: ["--okhsv"],
	serialize: "--okhsv",
	fromMode: {
		oklab: convertOklabToOkhsv,
		rgb: (c$2) => convertOklabToOkhsv(convertRgbToOklab_default(c$2))
	},
	toMode: {
		oklab: convertOkhsvToOklab,
		rgb: (c$2) => convertOklabToRgb_default(convertOkhsvToOklab(c$2))
	}
};
var modeOkhsv_default = modeOkhsv;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyb/constants.js
const bias = .0037930732552754493;
const bias_cbrt = Math.cbrt(bias);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyb/convertRgbToXyb.js
const transfer$1 = (v) => Math.cbrt(v) - bias_cbrt;
const convertRgbToXyb = (color) => {
	const { r: r$2, g, b, alpha } = convertRgbToLrgb_default(color);
	const l = transfer$1(.3 * r$2 + .622 * g + .078 * b + bias);
	const m = transfer$1(.23 * r$2 + .692 * g + .078 * b + bias);
	const s = transfer$1(.2434226892454782 * r$2 + .2047674442449682 * g + .5518098665095535 * b + bias);
	const res = {
		mode: "xyb",
		x: (l - m) / 2,
		y: (l + m) / 2,
		b: s - (l + m) / 2
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyb_default = convertRgbToXyb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyb/convertXybToRgb.js
const transfer = (v) => Math.pow(v + bias_cbrt, 3);
const convertXybToRgb = ({ x, y, b, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (b === void 0) b = 0;
	const l = transfer(x + y) - bias;
	const m = transfer(y - x) - bias;
	const s = transfer(b + y) - bias;
	const res = convertLrgbToRgb_default({
		r: 11.031566904639861 * l - 9.866943908131562 * m - .16462299650829934 * s,
		g: -3.2541473810744237 * l + 4.418770377582723 * m - .16462299650829934 * s,
		b: -3.6588512867136815 * l + 2.7129230459360922 * m + 1.9459282407775895 * s
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXybToRgb_default = convertXybToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyb/definition.js
const definition$1 = {
	mode: "xyb",
	channels: [
		"x",
		"y",
		"b",
		"alpha"
	],
	parse: ["--xyb"],
	serialize: "--xyb",
	toMode: { rgb: convertXybToRgb_default },
	fromMode: { rgb: convertRgbToXyb_default },
	ranges: {
		x: [-.0154, .0281],
		y: [0, .8453],
		b: [-.2778, .388]
	},
	interpolate: {
		x: interpolatorLinear,
		y: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$26 = definition$1;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/yiq/convertRgbToYiq.js
const convertRgbToYiq = ({ r: r$2, g, b, alpha }) => {
	if (r$2 === void 0) r$2 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	const res = {
		mode: "yiq",
		y: .29889531 * r$2 + .58662247 * g + .11448223 * b,
		i: .59597799 * r$2 - .2741761 * g - .32180189 * b,
		q: .21147017 * r$2 - .52261711 * g + .31114694 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToYiq_default = convertRgbToYiq;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/yiq/convertYiqToRgb.js
const convertYiqToRgb = ({ y, i, q, alpha }) => {
	if (y === void 0) y = 0;
	if (i === void 0) i = 0;
	if (q === void 0) q = 0;
	const res = {
		mode: "rgb",
		r: y + .95608445 * i + .6208885 * q,
		g: y - .27137664 * i - .6486059 * q,
		b: y - 1.10561724 * i + 1.70250126 * q
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertYiqToRgb_default = convertYiqToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/yiq/definition.js
const definition = {
	mode: "yiq",
	toMode: { rgb: convertYiqToRgb_default },
	fromMode: { rgb: convertRgbToYiq_default },
	channels: [
		"y",
		"i",
		"q",
		"alpha"
	],
	parse: ["--yiq"],
	serialize: "--yiq",
	ranges: {
		i: [-.595, .595],
		q: [-.522, .522]
	},
	interpolate: {
		y: interpolatorLinear,
		i: interpolatorLinear,
		q: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$27 = definition;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/round.js
const r = (value, precision) => Math.round(value * (precision = Math.pow(10, precision))) / precision;
const round = (precision = 4) => (value) => typeof value === "number" ? r(value, precision) : value;
var round_default = round;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/index.js
const a98 = useMode(definition_default);
const cubehelix = useMode(definition_default$15);
const dlab = useMode(definition_default$16);
const dlch = useMode(definition_default$17);
const hsi = useMode(definition_default$18);
const hsl = useMode(definition_default$1);
const hsv = useMode(definition_default$19);
const hwb = useMode(definition_default$2);
const itp = useMode(definition_default$20);
const jab = useMode(definition_default$21);
const jch = useMode(definition_default$22);
const lab = useMode(definition_default$3);
const lab65 = useMode(definition_default$4);
const lch = useMode(definition_default$5);
const lch65 = useMode(definition_default$23);
const lchuv = useMode(definition_default$24);
const lrgb = useMode(definition_default$6);
const luv = useMode(definition_default$25);
const okhsl = useMode(modeOkhsl_default);
const okhsv = useMode(modeOkhsv_default);
const oklab = useMode(definition_default$7);
const oklch = useMode(definition_default$8);
const p3 = useMode(definition_default$9);
const prophoto = useMode(definition_default$10);
const rec2020 = useMode(definition_default$11);
const rgb = useMode(definition_default$12);
const xyb = useMode(definition_default$26);
const xyz50 = useMode(definition_default$13);
const xyz65 = useMode(definition_default$14);
const yiq = useMode(definition_default$27);

//#endregion
//#region ../token-tools/dist/css.js
const CSS_VAR_RE = /(?:(\p{Uppercase_Letter}?[\p{Lowercase_Letter}\p{Number}]+|[\p{Uppercase_Letter}\p{Number}]+|[\u{80}-\u{10FFFF}\p{Number}]+)|.)/u;
/**
* Generate a valid CSS variable from any string
* Code by @dfrankland
*/
function makeCSSVar(name, { prefix, wrapVar = false } = {}) {
	if (typeof name !== "string") throw new Error(`makeCSSVar() Expected string, received ${name}`);
	let property = name.split(CSS_VAR_RE).filter(Boolean).join("-");
	if (prefix && !property.startsWith(`${prefix}-`)) property = `${prefix}-${property}`;
	const finalProperty = `--${property}`.toLocaleLowerCase();
	return wrapVar ? `var(${finalProperty})` : finalProperty;
}
const converters = {
	a98: useMode(definition_default),
	hsl: useMode(definition_default$1),
	hwb: useMode(definition_default$2),
	lab: useMode(definition_default$3),
	lab65: useMode(definition_default$4),
	lch: useMode(definition_default$5),
	lrgb: useMode(definition_default$6),
	oklab: useMode(definition_default$7),
	oklch: useMode(definition_default$8),
	okhsv: useMode(modeOkhsv_default),
	p3: useMode(definition_default$9),
	prophoto: useMode(definition_default$10),
	rec2020: useMode(definition_default$11),
	rgb: useMode(definition_default$12),
	xyz50: useMode(definition_default$13),
	xyz65: useMode(definition_default$14)
};
const DEPTH_ROUNDING = {
	24: round_default(4),
	30: round_default(4),
	36: round_default(5),
	48: round_default(6)
};

//#endregion
//#region ../../node_modules/.pnpm/wildcard-match@5.1.4/node_modules/wildcard-match/build/index.es.mjs
/**
* Escapes a character if it has a special meaning in regular expressions
* and returns the character as is if it doesn't
*/
function escapeRegExpChar(char) {
	if (char === "-" || char === "^" || char === "$" || char === "+" || char === "." || char === "(" || char === ")" || char === "|" || char === "[" || char === "]" || char === "{" || char === "}" || char === "*" || char === "?" || char === "\\") return "\\".concat(char);
	else return char;
}
/**
* Escapes all characters in a given string that have a special meaning in regular expressions
*/
function escapeRegExpString(str) {
	var result = "";
	for (var i = 0; i < str.length; i++) result += escapeRegExpChar(str[i]);
	return result;
}
/**
* Transforms one or more glob patterns into a RegExp pattern
*/
function transform(pattern, separator) {
	if (separator === void 0) separator = true;
	if (Array.isArray(pattern)) {
		var regExpPatterns = pattern.map(function(p$3) {
			return "^".concat(transform(p$3, separator), "$");
		});
		return "(?:".concat(regExpPatterns.join("|"), ")");
	}
	var separatorSplitter = "";
	var separatorMatcher = "";
	var wildcard = ".";
	if (separator === true) {
		separatorSplitter = "/";
		separatorMatcher = "[/\\\\]";
		wildcard = "[^/\\\\]";
	} else if (separator) {
		separatorSplitter = separator;
		separatorMatcher = escapeRegExpString(separatorSplitter);
		if (separatorMatcher.length > 1) {
			separatorMatcher = "(?:".concat(separatorMatcher, ")");
			wildcard = "((?!".concat(separatorMatcher, ").)");
		} else wildcard = "[^".concat(separatorMatcher, "]");
	}
	var requiredSeparator = separator ? "".concat(separatorMatcher, "+?") : "";
	var optionalSeparator = separator ? "".concat(separatorMatcher, "*?") : "";
	var segments = separator ? pattern.split(separatorSplitter) : [pattern];
	var result = "";
	for (var s = 0; s < segments.length; s++) {
		var segment = segments[s];
		var nextSegment = segments[s + 1];
		var currentSeparator = "";
		if (!segment && s > 0) continue;
		if (separator) if (s === segments.length - 1) currentSeparator = optionalSeparator;
		else if (nextSegment !== "**") currentSeparator = requiredSeparator;
		else currentSeparator = "";
		if (separator && segment === "**") {
			if (currentSeparator) {
				result += s === 0 ? "" : s === segments.length - 1 ? "(?:".concat(requiredSeparator, "|$)") : requiredSeparator;
				result += "(?:".concat(wildcard, "*?").concat(currentSeparator, ")*?");
			}
			continue;
		}
		for (var c$2 = 0; c$2 < segment.length; c$2++) {
			var char = segment[c$2];
			if (char === "\\") {
				if (c$2 < segment.length - 1) {
					result += escapeRegExpChar(segment[c$2 + 1]);
					c$2++;
				}
			} else if (char === "?") result += wildcard;
			else if (char === "*") result += "".concat(wildcard, "*?");
			else result += escapeRegExpChar(char);
		}
		result += currentSeparator;
	}
	return result;
}
function isMatch(regexp, sample) {
	if (typeof sample !== "string") throw new TypeError("Sample must be a string, but ".concat(typeof sample, " given"));
	return regexp.test(sample);
}
/**
* Compiles one or more glob patterns into a RegExp and returns an isMatch function.
* The isMatch function takes a sample string as its only argument and returns `true`
* if the string matches the pattern(s).
*
* ```js
* wildcardMatch('src/*.js')('src/index.js') //=> true
* ```
*
* ```js
* const isMatch = wildcardMatch('*.example.com', '.')
* isMatch('foo.example.com') //=> true
* isMatch('foo.bar.com') //=> false
* ```
*/
function wildcardMatch(pattern, options) {
	if (typeof pattern !== "string" && !Array.isArray(pattern)) throw new TypeError("The first argument must be a single pattern string or an array of patterns, but ".concat(typeof pattern, " given"));
	if (typeof options === "string" || typeof options === "boolean") options = { separator: options };
	if (arguments.length === 2 && !(typeof options === "undefined" || typeof options === "object" && options !== null && !Array.isArray(options))) throw new TypeError("The second argument must be an options object or a string/boolean separator, but ".concat(typeof options, " given"));
	options = options || {};
	if (options.separator === "\\") throw new Error("\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead");
	var regexpPattern = transform(pattern, options.separator);
	var regexp = new RegExp("^".concat(regexpPattern, "$"), options.flags);
	var fn$5 = isMatch.bind(null, regexp);
	fn$5.options = options;
	fn$5.pattern = pattern;
	fn$5.regexp = regexp;
	return fn$5;
}

//#endregion
//#region src/lib.ts
const FILE_HEADER = `////
/// Autogenerated by ⛋ Terrazzo. DO NOT EDIT!
////

@use "sass:list";
@use "sass:map";
@use "sass:meta";`;
const MIXIN_TOKEN = `@function token($tokenName) {
  @if map.has-key($__token-values, $tokenName) == false {
    @error 'No token named "#{$tokenName}"';
  }
  $_token: map.get($__token-values, $tokenName);
  @if meta.type-of($_token) == map and map.has-key($_token, "__tz-error") {
    @error map.get($_token, "__tz-error");
  }

  @return $_token;
}`;
const MIXIN_TYPOGRAPHY = `@mixin typography($tokenName, $modeName: ".") {
  @if map.has-key($__token-typography-mixins, $tokenName) == false {
    @error 'No typography mixin named "#{$tokenName}"';
  }
  $_mixin: map.get($__token-typography-mixins, $tokenName);
  $_properties: map.get($_mixin, ".");
  @if map.has-key($_mixin) {
    $_properties: map.get($_mixin);
  }
  @each $_property, $_value in $_properties {
    #{$_property}: #{$_value};
  }
}`;

//#endregion
//#region src/build.ts
function build({ getTransforms, options }) {
	const tokens = getTransforms({
		format: FORMAT_ID,
		id: "*",
		mode: "."
	});
	const output = [FILE_HEADER, ""];
	const shouldExclude = wildcardMatch(options?.exclude ?? []);
	output.push("$__token-values: (");
	for (const token of tokens) {
		if (shouldExclude(token.token.id)) continue;
		if (token.token.$type === "typography") output.push(`  "${token.token.id}": (
    "__tz-error": 'This is a typography mixin. Use \`@include typography("${token.token.id}")\` instead.',
  ),`);
		else {
			const name = token.localID ?? token.token.id;
			output.push(`  "${token.token.id}": (${makeCSSVar(name, { wrapVar: true })}),`);
		}
	}
	output.push(");", "");
	output.push("$__token-typography-mixins: (");
	const typographyTokens = getTransforms({
		format: "css",
		id: "*",
		mode: ".",
		$type: "typography"
	});
	for (const token of typographyTokens) {
		output.push(`  "${token.token.id}": (`);
		for (const property of Object.keys(token.value)) {
			const name = `${token.localID ?? token.token.id}-${property}`;
			output.push(`    "${property}": (${makeCSSVar(name, { wrapVar: true })}),`);
		}
		output.push("  ),");
	}
	output.push(");", "");
	output.push(MIXIN_TOKEN, "", MIXIN_TYPOGRAPHY, "");
	return output.join("\n");
}

//#endregion
//#region src/index.ts
function pluginSass(options) {
	const filename = options?.filename ?? "index.scss";
	return {
		name: "@terrazzo/plugin-sass",
		enforce: "post",
		config(config) {
			if (!config.plugins.some((p$3) => p$3.name === "@terrazzo/plugin-css")) throw new Error(`@terrazzo/plugin-sass relies on @terrazzo/plugin-css.
Please install @terrazzo/plugin-css and follow setup to add to your config.`);
		},
		async build({ getTransforms, outputFile }) {
			const output = build({
				getTransforms,
				options
			});
			outputFile(filename, output);
		}
	};
}

//#endregion
export { FILE_HEADER, MIXIN_TOKEN, MIXIN_TYPOGRAPHY, pluginSass as default };
//# sourceMappingURL=index.js.map