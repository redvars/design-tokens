{"version":3,"file":"index.js","names":["endLoc: Location","markerLines: Record<string, any>","MESSAGE_COLOR: Record<string, typeof pc.red | undefined>","baseMessage: LogEntry","formats: Record<string, TokenTransformed[]>","result: BuildRunnerResult","cleanValue: TokenTransformed['value']","rule: LintRule<typeof ERROR_INSUFFICIENT_CONTRAST, RuleA11yMinContrastOptions>","rule","rule: LintRule<typeof ERROR_TOO_SMALL, RuleA11yMinFontSizeOptions>","rule","ERROR_COLOR","ERROR_BORDER","ERROR_GRADIENT","ERROR_SHADOW","rule: LintRule<\n  typeof ERROR_COLOR | typeof ERROR_BORDER | typeof ERROR_GRADIENT | typeof ERROR_SHADOW,\n  RuleColorspaceOptions\n>","rule","rule: LintRule<typeof ERROR_WRONG_FORMAT, RuleConsistentNamingOptions>","rule","rule: LintRule<typeof ERROR_MISSING_DESCRIPTION, RuleDescriptionsOptions>","rule","rule: LintRule<typeof ERROR_DUPLICATE_VALUE, RuleDuplicateValueOptions>","values: Record<string, Set<any>>","rule","rule: LintRule<\n  typeof ERROR_COLOR | typeof ERROR_BORDER | typeof ERROR_GRADIENT | typeof ERROR_SHADOW,\n  RuleMaxGamutOptions\n>","rule","rule: LintRule<\n  typeof ERROR_EMPTY_MATCH | typeof ERROR_MISSING_REQUIRED_TOKENS | typeof ERROR_MISSING_REQUIRED_GROUP,\n  RuleRequiredChildrenOptions\n>","matchGroups: string[]","matchTokens: string[]","rule","rule: LintRule<never, RuleRequiredModesOptions>","rule","rule: LintRule<never, RuleRequiredTypographyPropertiesOptions>","colorspace","consistentNaming","descriptions","duplicateValues","maxGamut","requiredChidlren","requiredModes","requiredTypographyProperties","a11yMinContrast","a11yMinFontSize","rule","severity: LintRuleSeverity","options: any","listFormat","errors: LogEntry[]","warnings: LogEntry[]","rule","#text","#ended","#column","#offset","#last","#line","#end","#newLine","#options","#reader","#json5","#allowComments","#ranges","#isEscapedCharacter","#isJSON5LineTerminator","#isJSON5HexEscape","#isWhitespace","#unexpected","#readHexDigits","#unexpectedEOF","#readIdentifier","#token","#createToken","#readNumber","#readString","#readComment","#unexpectedIdentifier","parse","types","members: Record<string | number, ValueNodeWithIndex>","nextNode: AnyNode | undefined","momoaParse","newValue: ColorValueNormalized","output: GradientValueNormalized","output: TypographyValueNormalized","value","unit","parent$type: MemberNode | undefined","group: TokenNormalized['group']","tokensSet: Record<string, TokenNormalized>","$typeInheritance: Record<string, MemberNode>","$deprecatedInheritance: Record<string, MemberNode>","normalize"],"sources":["../src/lib/code-frame.ts","../src/logger.ts","../src/build/index.ts","../src/lint/plugin-core/lib/docs.ts","../src/lint/plugin-core/rules/a11y-min-contrast.ts","../src/lint/plugin-core/rules/a11y-min-font-size.ts","../src/lint/plugin-core/rules/colorspace.ts","../../../node_modules/.pnpm/scule@1.3.0/node_modules/scule/dist/index.mjs","../src/lint/plugin-core/rules/consistent-naming.ts","../src/lint/plugin-core/rules/descriptions.ts","../src/lint/plugin-core/rules/duplicate-values.ts","../src/lint/plugin-core/rules/max-gamut.ts","../src/lint/plugin-core/rules/required-children.ts","../src/lint/plugin-core/rules/required-modes.ts","../src/lint/plugin-core/rules/required-typography-properties.ts","../src/lint/plugin-core/index.ts","../src/config.ts","../src/lint/index.ts","../../../node_modules/.pnpm/@humanwhocodes+momoa@3.3.9/node_modules/@humanwhocodes/momoa/dist/momoa.js","../src/parse/json.ts","../src/parse/alias.ts","../src/parse/normalize.ts","../src/parse/validate.ts","../src/parse/index.ts"],"sourcesContent":["// This is copied from @babel/code-frame package but without the heavyweight color highlighting\n// (note: Babel loads both chalk AND picocolors, and doesn’t treeshake well)\n// Babel is MIT-licensed and unaffiliated with this project.\n\n// MIT License\n//\n// Copyright (c) 2014-present Sebastian McKenzie and other contributors\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport interface Location {\n  line: number;\n  column: number;\n}\n\nexport interface NodeLocation {\n  end?: Location;\n  start: Location;\n}\n\nexport interface Options {\n  /** Syntax highlight the code as JavaScript for terminals. default: false */\n  highlightCode?: boolean;\n  /**  The number of lines to show above the error. default: 2 */\n  linesAbove?: number;\n  /**  The number of lines to show below the error. default: 3 */\n  linesBelow?: number;\n  /**\n   * Forcibly syntax highlight the code as JavaScript (for non-terminals);\n   * overrides highlightCode.\n   * default: false\n   */\n  forceColor?: boolean;\n  /**\n   * Pass in a string to be displayed inline (if possible) next to the\n   * highlighted location in the code. If it can't be positioned inline,\n   * it will be placed above the code frame.\n   * default: nothing\n   */\n  message?: string;\n}\n\n/**\n * Extract what lines should be marked and highlighted.\n */\nfunction getMarkerLines(loc: NodeLocation, source: string[], opts: Options = {} as Options) {\n  const startLoc = {\n    // @ts-expect-error this is fine\n    column: 0,\n    // @ts-expect-error this is fine\n    line: -1,\n    ...loc.start,\n  } as Location;\n  const endLoc: Location = {\n    ...startLoc,\n    ...loc.end,\n  };\n  const { linesAbove = 2, linesBelow = 3 } = opts || {};\n  const startLine = startLoc.line;\n  const startColumn = startLoc.column;\n  const endLine = endLoc.line;\n  const endColumn = endLoc.column;\n\n  let start = Math.max(startLine - (linesAbove + 1), 0);\n  let end = Math.min(source.length, endLine + linesBelow);\n\n  if (startLine === -1) {\n    start = 0;\n  }\n\n  if (endLine === -1) {\n    end = source.length;\n  }\n\n  const lineDiff = endLine - startLine;\n  const markerLines: Record<string, any> = {};\n\n  if (lineDiff) {\n    for (let i = 0; i <= lineDiff; i++) {\n      const lineNumber = i + startLine;\n\n      if (!startColumn) {\n        markerLines[lineNumber] = true;\n      } else if (i === 0) {\n        const sourceLength = source[lineNumber - 1]!.length;\n\n        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n      } else if (i === lineDiff) {\n        markerLines[lineNumber] = [0, endColumn];\n      } else {\n        const sourceLength = source[lineNumber - i]!.length;\n\n        markerLines[lineNumber] = [0, sourceLength];\n      }\n    }\n  } else {\n    if (startColumn === endColumn) {\n      if (startColumn) {\n        markerLines[startLine] = [startColumn, 0];\n      } else {\n        markerLines[startLine] = true;\n      }\n    } else {\n      markerLines[startLine] = [startColumn, endColumn - startColumn];\n    }\n  }\n\n  return { start, end, markerLines };\n}\n\n/**\n * RegExp to test for newlines in terminal.\n */\n\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\nexport function codeFrameColumns(rawLines: string, loc: NodeLocation, opts: Options = {} as Options) {\n  const lines = rawLines.split(NEWLINE);\n  const { start, end, markerLines } = getMarkerLines(loc, lines, opts);\n  const hasColumns = loc.start && typeof loc.start.column === 'number';\n\n  const numberMaxWidth = String(end).length;\n\n  let frame = rawLines\n    .split(NEWLINE, end)\n    .slice(start, end)\n    .map((line, index) => {\n      const number = start + 1 + index;\n      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);\n      const gutter = ` ${paddedNumber} |`;\n      const hasMarker = markerLines[number];\n      const lastMarkerLine = !markerLines[number + 1];\n      if (hasMarker) {\n        let markerLine = '';\n        if (Array.isArray(hasMarker)) {\n          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\\t]/g, ' ');\n          const numberOfMarkers = hasMarker[1] || 1;\n\n          markerLine = ['\\n ', gutter.replace(/\\d/g, ' '), ' ', markerSpacing, '^'.repeat(numberOfMarkers)].join('');\n\n          if (lastMarkerLine && opts.message) {\n            markerLine += ` ${opts.message}`;\n          }\n        }\n        return ['>', gutter, line.length > 0 ? ` ${line}` : '', markerLine].join('');\n      } else {\n        return ` ${gutter}${line.length > 0 ? ` ${line}` : ''}`;\n      }\n    })\n    .join('\\n');\n\n  if (opts.message && !hasColumns) {\n    frame = `${' '.repeat(numberMaxWidth + 1)}${opts.message}\\n${frame}`;\n  }\n\n  return frame;\n}\n","import type { AnyNode } from '@humanwhocodes/momoa';\nimport pc from 'picocolors';\nimport wcmatch from 'wildcard-match';\nimport { codeFrameColumns } from './lib/code-frame.js';\n\nexport const LOG_ORDER = ['error', 'warn', 'info', 'debug'] as const;\n\nexport type LogSeverity = 'error' | 'warn' | 'info' | 'debug';\n\nexport type LogLevel = LogSeverity | 'silent';\n\nexport type LogGroup = 'config' | 'parser' | 'lint' | 'plugin' | 'server';\n\nexport interface LogEntry {\n  /** Originator of log message */\n  group: LogGroup;\n  /** Error message to be logged */\n  message: string;\n  /** Prefix message with label */\n  label?: string;\n  /** File in disk */\n  filename?: URL;\n  /**\n   * Continue on error?\n   * @default false\n   */\n  continueOnError?: boolean;\n  /** Show a code frame for the erring node */\n  node?: AnyNode;\n  /** To show a code frame, provide the original source code */\n  src?: string;\n}\n\nexport interface DebugEntry {\n  group: LogGroup;\n  /** Error message to be logged */\n  message: string;\n  /** Current subtask or submodule */\n  label?: string;\n  /** Show code below message */\n  codeFrame?: { src: string; line: number; column: number };\n  /** Display performance timing */\n  timing?: number;\n}\n\nconst MESSAGE_COLOR: Record<string, typeof pc.red | undefined> = { error: pc.red, warn: pc.yellow };\n\nconst timeFormatter = new Intl.DateTimeFormat('en-us', {\n  hour: 'numeric',\n  hour12: false,\n  minute: 'numeric',\n  second: 'numeric',\n  fractionalSecondDigits: 3,\n});\n\n/**\n * @param {Entry} entry\n * @param {Severity} severity\n * @return {string}\n */\nexport function formatMessage(entry: LogEntry, severity: LogSeverity) {\n  let message = entry.message;\n  message = `[${entry.group}${entry.label ? `:${entry.label}` : ''}] ${message}`;\n  if (severity in MESSAGE_COLOR) {\n    message = MESSAGE_COLOR[severity]!(message);\n  }\n  if (entry.src) {\n    const start = entry.node?.loc?.start ?? { line: 0, column: 0 };\n    //  strip \"file://\" protocol, but not href\n    const loc = entry.filename\n      ? `${entry.filename?.href.replace(/^file:\\/\\//, '')}:${start?.line ?? 0}:${start?.column ?? 0}\\n\\n`\n      : '';\n    const codeFrame = codeFrameColumns(entry.src, { start }, { highlightCode: false });\n    message = `${message}\\n\\n${loc}${codeFrame}`;\n  }\n  return message;\n}\n\nexport default class Logger {\n  level = 'info' as LogLevel;\n  debugScope = '*';\n  errorCount = 0;\n  warnCount = 0;\n  infoCount = 0;\n  debugCount = 0;\n\n  constructor(options?: { level?: LogLevel; debugScope?: string }) {\n    if (options?.level) {\n      this.level = options.level;\n    }\n    if (options?.debugScope) {\n      this.debugScope = options.debugScope;\n    }\n  }\n\n  setLevel(level: LogLevel) {\n    this.level = level;\n  }\n\n  /** Log an error message (always; can’t be silenced) */\n  error(entry: LogEntry) {\n    this.errorCount++;\n    const message = formatMessage(entry, 'error');\n    if (entry.continueOnError) {\n      // biome-ignore lint/suspicious/noConsole: this is a logger\n      console.error(message);\n      return;\n    }\n    if (entry.node) {\n      throw new TokensJSONError(message);\n    } else {\n      throw new Error(message);\n    }\n  }\n\n  /** Log an info message (if logging level permits) */\n  info(entry: LogEntry) {\n    this.infoCount++;\n    if (this.level === 'silent' || LOG_ORDER.indexOf(this.level) < LOG_ORDER.indexOf('info')) {\n      return;\n    }\n    const message = formatMessage(entry, 'info');\n    // biome-ignore lint/suspicious/noConsole: this is a logger\n    console.log(message);\n  }\n\n  /** Log a warning message (if logging level permits) */\n  warn(entry: LogEntry) {\n    this.warnCount++;\n    if (this.level === 'silent' || LOG_ORDER.indexOf(this.level) < LOG_ORDER.indexOf('warn')) {\n      return;\n    }\n    const message = formatMessage(entry, 'warn');\n    // biome-ignore lint/suspicious/noConsole: this is a logger\n    console.warn(message);\n  }\n\n  /** Log a diagnostics message (if logging level permits) */\n  debug(entry: DebugEntry) {\n    if (this.level === 'silent' || LOG_ORDER.indexOf(this.level) < LOG_ORDER.indexOf('debug')) {\n      return;\n    }\n    this.debugCount++;\n\n    let message = formatMessage(entry, 'debug');\n\n    const debugPrefix = entry.label ? `${entry.group}:${entry.label}` : entry.group;\n    if (this.debugScope !== '*' && !wcmatch(this.debugScope)(debugPrefix)) {\n      return;\n    }\n\n    // debug color\n    message\n      .replace(/\\[config[^\\]]+\\]/, (match) => pc.green(match))\n      .replace(/\\[parser[^\\]]+\\]/, (match) => pc.magenta(match))\n      .replace(/\\[lint[^\\]]+\\]/, (match) => pc.yellow(match))\n      .replace(/\\[plugin[^\\]]+\\]/, (match) => pc.cyan(match));\n\n    message = `${pc.dim(timeFormatter.format(performance.now()))} ${message}`;\n    if (typeof entry.timing === 'number') {\n      let timing = '';\n      if (entry.timing < 1_000) {\n        timing = `${Math.round(entry.timing * 100) / 100}ms`;\n      } else if (entry.timing < 60_000) {\n        timing = `${Math.round(entry.timing * 100) / 100_000}s`;\n      }\n      message = `${message} ${pc.dim(`[${timing}]`)}`;\n    }\n\n    // biome-ignore lint/suspicious/noConsole: this is a logger\n    console.log(message);\n  }\n\n  /** Get stats for current logger instance */\n  stats() {\n    return {\n      errorCount: this.errorCount,\n      warnCount: this.warnCount,\n      infoCount: this.infoCount,\n      debugCount: this.debugCount,\n    };\n  }\n}\n\nexport class TokensJSONError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'TokensJSONError';\n  }\n}\n","import type { DocumentNode } from '@humanwhocodes/momoa';\nimport type { TokenNormalized } from '@terrazzo/token-tools';\nimport wcmatch from 'wildcard-match';\nimport Logger, { type LogEntry } from '../logger.js';\nimport type { BuildRunnerResult, ConfigInit, TokenTransformed, TransformParams } from '../types.js';\n\nexport interface BuildRunnerOptions {\n  sources: { filename?: URL; src: string; document: DocumentNode }[];\n  config: ConfigInit;\n  logger?: Logger;\n}\n\nexport const SINGLE_VALUE = 'SINGLE_VALUE';\nexport const MULTI_VALUE = 'MULTI_VALUE';\n\n/** Validate plugin setTransform() calls for immediate feedback */\nfunction validateTransformParams({\n  params,\n  logger,\n  pluginName,\n}: {\n  params: TokenTransformed;\n  logger: Logger;\n  pluginName: string;\n}): void {\n  const baseMessage: LogEntry = { group: 'plugin', label: pluginName, message: '' };\n\n  // validate value is valid for SINGLE_VALUE or MULTI_VALUE\n  if (\n    !params.value ||\n    (typeof params.value !== 'string' && typeof params.value !== 'object') ||\n    Array.isArray(params.value)\n  ) {\n    logger.error({\n      ...baseMessage,\n      message: `setTransform() value expected string or object of strings, received ${\n        Array.isArray(params.value) ? 'Array' : typeof params.value\n      }`,\n    });\n  }\n  if (typeof params.value === 'object' && Object.values(params.value).some((v) => typeof v !== 'string')) {\n    logger.error({\n      ...baseMessage,\n      message: 'setTransform() value expected object of strings, received some non-string values',\n    });\n  }\n}\n\n/** Run build stage */\nexport default async function build(\n  tokens: Record<string, TokenNormalized>,\n  { sources, logger = new Logger(), config }: BuildRunnerOptions,\n): Promise<BuildRunnerResult> {\n  const formats: Record<string, TokenTransformed[]> = {};\n  const result: BuildRunnerResult = { outputFiles: [] };\n\n  function getTransforms(params: TransformParams) {\n    if (!params?.format) {\n      logger.warn({ group: 'plugin', message: '\"format\" missing from getTransforms(), no tokens returned.' });\n      return [];\n    }\n\n    const tokenMatcher = params.id ? wcmatch(Array.isArray(params.id) ? params.id : [params.id]) : null;\n    const modeMatcher = params.mode ? wcmatch(params.mode) : null;\n\n    return (formats[params.format!] ?? []).filter((token) => {\n      if (params.$type) {\n        if (typeof params.$type === 'string' && token.token.$type !== params.$type) {\n          return false;\n        } else if (Array.isArray(params.$type) && !params.$type.some(($type) => token.token.$type === $type)) {\n          return false;\n        }\n      }\n      if (params.id && params.id !== '*' && tokenMatcher && !tokenMatcher(token.token.id)) {\n        return false;\n      }\n      if (modeMatcher && !modeMatcher(token.mode)) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  // transform()\n  let transformsLocked = false; // prevent plugins from transforming after stage has ended\n  const startTransform = performance.now();\n  for (const plugin of config.plugins) {\n    if (typeof plugin.transform === 'function') {\n      await plugin.transform({\n        tokens,\n        sources,\n        getTransforms,\n        setTransform(id, params) {\n          if (transformsLocked) {\n            logger.warn({\n              message: 'Attempted to call setTransform() after transform step has completed.',\n              group: 'plugin',\n              label: plugin.name,\n            });\n            return;\n          }\n          const token = tokens[id]!;\n\n          // allow `undefined` values, but remove them here\n          const cleanValue: TokenTransformed['value'] =\n            typeof params.value === 'string' ? params.value : { ...(params.value as Record<string, string>) };\n          if (typeof cleanValue === 'object') {\n            for (const k of Object.keys(cleanValue)) {\n              if (cleanValue[k] === undefined) {\n                delete cleanValue[k];\n              }\n            }\n          }\n\n          validateTransformParams({\n            logger,\n            params: { ...(params as any), value: cleanValue },\n            pluginName: plugin.name,\n          });\n\n          // upsert\n          if (!formats[params.format]) {\n            formats[params.format] = [];\n          }\n          const foundTokenI = formats[params.format]!.findIndex(\n            (t) =>\n              id === t.id &&\n              (!params.localID || params.localID === t.localID) &&\n              (!params.mode || params.mode === t.mode),\n          );\n          if (foundTokenI === -1) {\n            formats[params.format]!.push({\n              ...params,\n              id,\n              value: cleanValue,\n              type: typeof cleanValue === 'string' ? SINGLE_VALUE : MULTI_VALUE,\n              mode: params.mode || '.',\n              token: structuredClone(token),\n            } as TokenTransformed);\n          } else {\n            formats[params.format]![foundTokenI]!.value = cleanValue;\n            formats[params.format]![foundTokenI]!.type = typeof cleanValue === 'string' ? SINGLE_VALUE : MULTI_VALUE;\n          }\n        },\n      });\n    }\n  }\n  transformsLocked = true;\n  logger.debug({\n    group: 'parser',\n    label: 'transform',\n    message: 'transform() step',\n    timing: performance.now() - startTransform,\n  });\n\n  // build()\n  const startBuild = performance.now();\n  for (const plugin of config.plugins) {\n    if (typeof plugin.build === 'function') {\n      const pluginBuildStart = performance.now();\n      await plugin.build({\n        tokens,\n        sources,\n        getTransforms,\n        outputFile(filename, contents) {\n          const resolved = new URL(filename, config.outDir);\n          if (result.outputFiles.some((f) => new URL(f.filename, config.outDir).href === resolved.href)) {\n            logger.error({\n              group: 'plugin',\n              message: `Can’t overwrite file \"${filename}\"`,\n              label: plugin.name,\n            });\n          }\n          result.outputFiles.push({\n            filename,\n            contents,\n            plugin: plugin.name,\n            time: performance.now() - pluginBuildStart,\n          });\n        },\n      });\n    }\n  }\n  logger.debug({\n    group: 'parser',\n    label: 'build',\n    message: 'build() step',\n    timing: performance.now() - startBuild,\n  });\n\n  // buildEnd()\n  const startBuildEnd = performance.now();\n  for (const plugin of config.plugins) {\n    if (typeof plugin.buildEnd === 'function') {\n      await plugin.buildEnd({ outputFiles: structuredClone(result.outputFiles) });\n    }\n  }\n  logger.debug({\n    group: 'parser',\n    label: 'build',\n    message: 'buildEnd() step',\n    timing: performance.now() - startBuildEnd,\n  });\n\n  return result;\n}\n","export function docsLink(ruleName: string): string {\n  return `https://terrazzo.app/docs/cli/lint#${ruleName.replaceAll('/', '')}`;\n}\n","import { tokenToCulori } from '@terrazzo/token-tools';\nimport { wcagContrast } from 'culori';\nimport type { LintRule } from '../../../types.js';\nimport { docsLink } from '../lib/docs.js';\n\nexport const A11Y_MIN_CONTRAST = 'a11y/min-contrast';\n\nexport interface RuleA11yMinContrastOptions {\n  /**\n   * Whether to adhere to AA (minimum) or AAA (enhanced) contrast levels.\n   * @default \"AA\"\n   */\n  level?: 'AA' | 'AAA';\n  /** Pairs of color tokens (and optionally typography) to test */\n  pairs: ContrastPair[];\n}\n\nexport interface ContrastPair {\n  /** The foreground color token ID */\n  foreground: string;\n  /** The background color token ID */\n  background: string;\n  /**\n   * Is this pair for large text? Large text allows a smaller contrast ratio.\n   *\n   * Note: while WCAG has _suggested_ sizes and weights, those are merely\n   * suggestions. It’s always more reliable to determine what constitutes “large\n   * text” for your designs yourself, based on your typographic stack.\n   * @see https://www.w3.org/WAI/WCAG22/quickref/#contrast-minimum\n   */\n  largeText?: boolean;\n}\n\nexport const WCAG2_MIN_CONTRAST = {\n  AA: { default: 4.5, large: 3 },\n  AAA: { default: 7, large: 4.5 },\n};\n\nexport const ERROR_INSUFFICIENT_CONTRAST = 'INSUFFICIENT_CONTRAST';\n\nconst rule: LintRule<typeof ERROR_INSUFFICIENT_CONTRAST, RuleA11yMinContrastOptions> = {\n  meta: {\n    messages: {\n      [ERROR_INSUFFICIENT_CONTRAST]: 'Pair {{ index }} failed; expected {{ expected }}, got {{ actual }} ({{ level }})',\n    },\n    docs: {\n      description: 'Enforce colors meet minimum contrast checks for WCAG 2.',\n      url: docsLink(A11Y_MIN_CONTRAST),\n    },\n  },\n  defaultOptions: { level: 'AA', pairs: [] },\n  create({ tokens, options, report }) {\n    for (let i = 0; i < options.pairs.length; i++) {\n      const { foreground, background, largeText } = options.pairs[i]!;\n      if (!tokens[foreground]) {\n        throw new Error(`Token ${foreground} does not exist`);\n      }\n      if (tokens[foreground].$type !== 'color') {\n        throw new Error(`Token ${foreground} isn’t a color`);\n      }\n      if (!tokens[background]) {\n        throw new Error(`Token ${background} does not exist`);\n      }\n      if (tokens[background].$type !== 'color') {\n        throw new Error(`Token ${background} isn’t a color`);\n      }\n\n      // Note: if these culors were unparseable, they would have already thrown an error before the linter\n      const a = tokenToCulori(tokens[foreground].$value)!;\n      const b = tokenToCulori(tokens[background].$value)!;\n\n      // Note: for the purposes of WCAG 2, foreground and background don’t\n      // matter. But in other contrast algorithms, they do.\n      const contrast = wcagContrast(a, b);\n      const min = WCAG2_MIN_CONTRAST[options.level ?? 'AA'][largeText ? 'large' : 'default'];\n      if (contrast < min) {\n        report({\n          messageId: ERROR_INSUFFICIENT_CONTRAST,\n          data: {\n            index: i + 1,\n            expected: min,\n            actual: Math.round(contrast * 100) / 100,\n            level: options.level,\n          },\n        });\n      }\n    }\n  },\n};\n\nexport default rule;\n","import wcmatch from 'wildcard-match';\nimport type { LintRule } from '../../../types.js';\nimport { docsLink } from '../lib/docs.js';\n\nexport const A11Y_MIN_FONT_SIZE = 'a11y/min-font-size';\n\nexport interface RuleA11yMinFontSizeOptions {\n  /** Minimum font size (pixels) */\n  minSizePx?: number;\n  /** Minimum font size (rems) */\n  minSizeRem?: number;\n  /** Token IDs to ignore. Accepts globs. */\n  ignore?: string[];\n}\n\nexport const ERROR_TOO_SMALL = 'TOO_SMALL';\n\nconst rule: LintRule<typeof ERROR_TOO_SMALL, RuleA11yMinFontSizeOptions> = {\n  meta: {\n    messages: {\n      [ERROR_TOO_SMALL]: '{{ id }} font size too small. Expected minimum of {{ min }}',\n    },\n    docs: {\n      description: 'Enforce font sizes are no smaller than the given value.',\n      url: docsLink(A11Y_MIN_FONT_SIZE),\n    },\n  },\n  defaultOptions: {},\n  create({ tokens, options, report }) {\n    if (!options.minSizePx && !options.minSizeRem) {\n      throw new Error('Must specify at least one of minSizePx or minSizeRem');\n    }\n\n    const shouldIgnore = options.ignore ? wcmatch(options.ignore) : null;\n\n    for (const t of Object.values(tokens)) {\n      if (shouldIgnore?.(t.id)) {\n        continue;\n      }\n\n      // skip aliases\n      if (t.aliasOf) {\n        continue;\n      }\n\n      if (t.$type === 'typography' && 'fontSize' in t.$value) {\n        const fontSize = t.$value.fontSize!;\n\n        if (\n          (fontSize.unit === 'px' && options.minSizePx && fontSize.value < options.minSizePx) ||\n          (fontSize.unit === 'rem' && options.minSizeRem && fontSize.value < options.minSizeRem)\n        ) {\n          report({\n            messageId: ERROR_TOO_SMALL,\n            data: {\n              id: t.id,\n              min: options.minSizePx ? `${options.minSizePx}px` : `${options.minSizeRem}rem`,\n            },\n          });\n        }\n      }\n    }\n  },\n};\n\nexport default rule;\n","import type { ColorValueNormalized } from '@terrazzo/token-tools';\nimport wcmatch from 'wildcard-match';\nimport type { LintRule } from '../../../types.js';\nimport { docsLink } from '../lib/docs.js';\n\nexport const COLORSPACE = 'core/colorspace';\n\nexport interface RuleColorspaceOptions {\n  colorSpace: ColorValueNormalized['colorSpace'];\n  /** (optional) Token IDs to ignore. Supports globs (`*`). */\n  ignore?: string[];\n}\n\nconst ERROR_COLOR = 'COLOR';\nconst ERROR_BORDER = 'BORDER';\nconst ERROR_GRADIENT = 'GRADIENT';\nconst ERROR_SHADOW = 'SHADOW';\n\nconst rule: LintRule<\n  typeof ERROR_COLOR | typeof ERROR_BORDER | typeof ERROR_GRADIENT | typeof ERROR_SHADOW,\n  RuleColorspaceOptions\n> = {\n  meta: {\n    messages: {\n      [ERROR_COLOR]: 'Color {{ id }} not in colorspace {{ colorSpace }}',\n      [ERROR_BORDER]: 'Border {{ id }} not in colorspace {{ colorSpace }}',\n      [ERROR_GRADIENT]: 'Gradient {{ id }} not in colorspace {{ colorSpace }}',\n      [ERROR_SHADOW]: 'Shadow {{ id }} not in colorspace {{ colorSpace }}',\n    },\n    docs: {\n      description: 'Enforce that all colors are in a specific colorspace.',\n      url: docsLink(COLORSPACE),\n    },\n  },\n  defaultOptions: { colorSpace: 'srgb' },\n  create({ tokens, options, report }) {\n    if (!options.colorSpace) {\n      return;\n    }\n\n    const shouldIgnore = options.ignore ? wcmatch(options.ignore) : null;\n\n    for (const t of Object.values(tokens)) {\n      // skip ignored tokens\n      if (shouldIgnore?.(t.id)) {\n        continue;\n      }\n\n      // skip aliases\n      if (t.aliasOf) {\n        continue;\n      }\n\n      switch (t.$type) {\n        case 'color': {\n          if (t.$value.colorSpace !== options.colorSpace) {\n            report({\n              messageId: ERROR_COLOR,\n              data: { id: t.id, colorSpace: options.colorSpace },\n              node: t.source.node,\n            });\n          }\n          break;\n        }\n        case 'border': {\n          if (!t.partialAliasOf?.color && t.$value.color.colorSpace !== options.colorSpace) {\n            report({\n              messageId: ERROR_BORDER,\n              data: { id: t.id, colorSpace: options.colorSpace },\n              node: t.source.node,\n            });\n          }\n          break;\n        }\n        case 'gradient': {\n          for (let stopI = 0; stopI < t.$value.length; stopI++) {\n            if (!t.partialAliasOf?.[stopI]?.color && t.$value[stopI]!.color.colorSpace !== options.colorSpace) {\n              report({\n                messageId: ERROR_GRADIENT,\n                data: { id: t.id, colorSpace: options.colorSpace },\n                node: t.source.node,\n              });\n            }\n          }\n          break;\n        }\n        case 'shadow': {\n          for (let shadowI = 0; shadowI < t.$value.length; shadowI++) {\n            if (!t.partialAliasOf?.[shadowI]?.color && t.$value[shadowI]!.color.colorSpace !== options.colorSpace) {\n              report({\n                messageId: ERROR_SHADOW,\n                data: { id: t.id, colorSpace: options.colorSpace },\n                node: t.source.node,\n              });\n            }\n          }\n          break;\n        }\n      }\n    }\n  },\n};\n\nexport default rule;\n","const NUMBER_CHAR_RE = /\\d/;\nconst STR_SPLITTERS = [\"-\", \"_\", \"/\", \".\"];\nfunction isUppercase(char = \"\") {\n  if (NUMBER_CHAR_RE.test(char)) {\n    return void 0;\n  }\n  return char !== char.toLowerCase();\n}\nfunction splitByCase(str, separators) {\n  const splitters = separators ?? STR_SPLITTERS;\n  const parts = [];\n  if (!str || typeof str !== \"string\") {\n    return parts;\n  }\n  let buff = \"\";\n  let previousUpper;\n  let previousSplitter;\n  for (const char of str) {\n    const isSplitter = splitters.includes(char);\n    if (isSplitter === true) {\n      parts.push(buff);\n      buff = \"\";\n      previousUpper = void 0;\n      continue;\n    }\n    const isUpper = isUppercase(char);\n    if (previousSplitter === false) {\n      if (previousUpper === false && isUpper === true) {\n        parts.push(buff);\n        buff = char;\n        previousUpper = isUpper;\n        continue;\n      }\n      if (previousUpper === true && isUpper === false && buff.length > 1) {\n        const lastChar = buff.at(-1);\n        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));\n        buff = lastChar + char;\n        previousUpper = isUpper;\n        continue;\n      }\n    }\n    buff += char;\n    previousUpper = isUpper;\n    previousSplitter = isSplitter;\n  }\n  parts.push(buff);\n  return parts;\n}\nfunction upperFirst(str) {\n  return str ? str[0].toUpperCase() + str.slice(1) : \"\";\n}\nfunction lowerFirst(str) {\n  return str ? str[0].toLowerCase() + str.slice(1) : \"\";\n}\nfunction pascalCase(str, opts) {\n  return str ? (Array.isArray(str) ? str : splitByCase(str)).map((p) => upperFirst(opts?.normalize ? p.toLowerCase() : p)).join(\"\") : \"\";\n}\nfunction camelCase(str, opts) {\n  return lowerFirst(pascalCase(str || \"\", opts));\n}\nfunction kebabCase(str, joiner) {\n  return str ? (Array.isArray(str) ? str : splitByCase(str)).map((p) => p.toLowerCase()).join(joiner ?? \"-\") : \"\";\n}\nfunction snakeCase(str) {\n  return kebabCase(str || \"\", \"_\");\n}\nfunction flatCase(str) {\n  return kebabCase(str || \"\", \"\");\n}\nfunction trainCase(str, opts) {\n  return (Array.isArray(str) ? str : splitByCase(str)).filter(Boolean).map((p) => upperFirst(opts?.normalize ? p.toLowerCase() : p)).join(\"-\");\n}\nconst titleCaseExceptions = /^(a|an|and|as|at|but|by|for|if|in|is|nor|of|on|or|the|to|with)$/i;\nfunction titleCase(str, opts) {\n  return (Array.isArray(str) ? str : splitByCase(str)).filter(Boolean).map(\n    (p) => titleCaseExceptions.test(p) ? p.toLowerCase() : upperFirst(opts?.normalize ? p.toLowerCase() : p)\n  ).join(\" \");\n}\n\nexport { camelCase, flatCase, isUppercase, kebabCase, lowerFirst, pascalCase, snakeCase, splitByCase, titleCase, trainCase, upperFirst };\n","import { camelCase, kebabCase, pascalCase, snakeCase } from 'scule';\nimport type { LintRule } from '../../../types.js';\nimport { docsLink } from '../lib/docs.js';\n\nexport const CONSISTENT_NAMING = 'core/consistent-naming';\nexport const ERROR_WRONG_FORMAT = 'ERROR_WRONG_FORMAT';\n\nexport interface RuleConsistentNamingOptions {\n  /** Specify format, or custom naming validator */\n  format:\n    | 'kebab-case'\n    | 'camelCase'\n    | 'PascalCase'\n    | 'snake_case'\n    | 'SCREAMING_SNAKE_CASE'\n    | ((tokenID: string) => boolean);\n  /** Token IDs to ignore. Supports globs (`*`). */\n  ignore?: string[];\n}\n\nconst rule: LintRule<typeof ERROR_WRONG_FORMAT, RuleConsistentNamingOptions> = {\n  meta: {\n    messages: {\n      [ERROR_WRONG_FORMAT]: '{{ id }} doesn’t match format {{ format }}',\n    },\n    docs: {\n      description: 'Enforce consistent naming for tokens.',\n      url: docsLink(CONSISTENT_NAMING),\n    },\n  },\n  defaultOptions: { format: 'kebab-case' },\n  create({ tokens, options, report }) {\n    const basicFormatter = {\n      'kebab-case': kebabCase,\n      camelCase,\n      PascalCase: pascalCase,\n      snake_case: snakeCase,\n      SCREAMING_SNAKE_CASE: (name: string) => snakeCase(name).toLocaleUpperCase(),\n    }[String(options.format)];\n\n    for (const t of Object.values(tokens)) {\n      if (basicFormatter) {\n        const parts = t.id.split('.');\n        if (!parts.every((part) => basicFormatter(part) === part)) {\n          report({\n            messageId: ERROR_WRONG_FORMAT,\n            data: { id: t.id, format: options.format },\n            node: t.source.node,\n          });\n        }\n      } else if (typeof options.format === 'function') {\n        const result = options.format(t.id);\n        if (result) {\n          report({\n            messageId: ERROR_WRONG_FORMAT,\n            data: { id: t.id, format: '(custom)' },\n            node: t.source.node,\n          });\n        }\n      }\n    }\n  },\n};\n\nexport default rule;\n","import wcmatch from 'wildcard-match';\nimport type { LintRule } from '../../../types.js';\nimport { docsLink } from '../lib/docs.js';\n\nexport const DESCRIPTIONS = 'core/descriptions';\n\nexport interface RuleDescriptionsOptions {\n  /** Token IDs to ignore. Supports globs (`*`). */\n  ignore?: string[];\n}\n\nconst ERROR_MISSING_DESCRIPTION = 'MISSING_DESCRIPTION';\n\nconst rule: LintRule<typeof ERROR_MISSING_DESCRIPTION, RuleDescriptionsOptions> = {\n  meta: {\n    messages: {\n      [ERROR_MISSING_DESCRIPTION]: '{{ id }} missing description',\n    },\n    docs: {\n      description: 'Enforce tokens have descriptions.',\n      url: docsLink(DESCRIPTIONS),\n    },\n  },\n  defaultOptions: {},\n  create({ tokens, options, report }) {\n    const shouldIgnore = options.ignore ? wcmatch(options.ignore) : null;\n\n    for (const t of Object.values(tokens)) {\n      if (shouldIgnore?.(t.id)) {\n        continue;\n      }\n      if (!t.$description) {\n        report({\n          messageId: ERROR_MISSING_DESCRIPTION,\n          data: { id: t.id },\n          node: t.source.node,\n        });\n      }\n    }\n  },\n};\n\nexport default rule;\n","import { isAlias } from '@terrazzo/token-tools';\nimport wcmatch from 'wildcard-match';\nimport type { LintRule } from '../../../types.js';\nimport { docsLink } from '../lib/docs.js';\n\nexport const DUPLICATE_VALUES = 'core/duplicate-values';\n\nexport interface RuleDuplicateValueOptions {\n  /** Token IDs to ignore. Supports globs (`*`). */\n  ignore?: string[];\n}\n\nconst ERROR_DUPLICATE_VALUE = 'ERROR_DUPLICATE_VALUE';\n\nconst rule: LintRule<typeof ERROR_DUPLICATE_VALUE, RuleDuplicateValueOptions> = {\n  meta: {\n    messages: {\n      [ERROR_DUPLICATE_VALUE]: '{{ id }} declared a duplicate value',\n    },\n    docs: {\n      description: 'Enforce tokens can’t redeclare the same value (excludes aliases).',\n      url: docsLink(DUPLICATE_VALUES),\n    },\n  },\n  defaultOptions: {},\n  create({ report, tokens, options }) {\n    const values: Record<string, Set<any>> = {};\n\n    const shouldIgnore = options.ignore ? wcmatch(options.ignore) : null;\n\n    for (const t of Object.values(tokens)) {\n      // skip ignored tokens\n      if (shouldIgnore?.(t.id)) {\n        continue;\n      }\n\n      if (!values[t.$type]) {\n        values[t.$type] = new Set();\n      }\n\n      // primitives: direct comparison is easy\n      if (\n        t.$type === 'boolean' ||\n        t.$type === 'duration' ||\n        t.$type === 'fontWeight' ||\n        t.$type === 'link' ||\n        t.$type === 'number' ||\n        t.$type === 'string'\n      ) {\n        // skip aliases (note: $value will be resolved)\n        if (typeof t.aliasOf === 'string' && isAlias(t.aliasOf)) {\n          continue;\n        }\n\n        if (values[t.$type]?.has(t.$value)) {\n          report({\n            messageId: ERROR_DUPLICATE_VALUE,\n            data: { id: t.id },\n            node: t.source.node,\n          });\n        }\n\n        values[t.$type]?.add(t.$value);\n      } else {\n        // everything else: use deepEqual\n        for (const v of values[t.$type]!.values() ?? []) {\n          // TODO: don’t JSON.stringify\n          if (JSON.stringify(t.$value) === JSON.stringify(v)) {\n            report({\n              messageId: ERROR_DUPLICATE_VALUE,\n              data: { id: t.id },\n              node: t.source.node,\n            });\n            break;\n          }\n        }\n        values[t.$type]!.add(t.$value);\n      }\n    }\n  },\n};\n\nexport default rule;\n","import { type ColorValueNormalized, tokenToCulori } from '@terrazzo/token-tools';\nimport { type Color, clampChroma } from 'culori';\nimport wcmatch from 'wildcard-match';\nimport type { LintRule } from '../../../types.js';\nimport { docsLink } from '../lib/docs.js';\n\nexport const MAX_GAMUT = 'core/max-gamut';\n\nexport interface RuleMaxGamutOptions {\n  /** Gamut to constrain color tokens to. */\n  gamut: 'srgb' | 'p3' | 'rec2020';\n  /** (optional) Token IDs to ignore. Supports globs (`*`). */\n  ignore?: string[];\n}\n\nconst TOLERANCE = 0.000001; // threshold above which it counts as an error (take rounding errors into account)\n\n/** is a Culori-parseable color within the specified gamut? */\nfunction isWithinGamut(color: ColorValueNormalized, gamut: RuleMaxGamutOptions['gamut']): boolean {\n  const parsed = tokenToCulori(color);\n  if (!parsed) {\n    return false;\n  }\n  if (['rgb', 'hsl', 'hwb'].includes(parsed.mode)) {\n    return true;\n  }\n  const clamped = clampChroma(parsed, parsed.mode, gamut === 'srgb' ? 'rgb' : gamut);\n  return isWithinThreshold(parsed, clamped);\n}\n\n/** is Color A close enough to Color B? */\nfunction isWithinThreshold(a: Color, b: Color, tolerance = TOLERANCE) {\n  for (const k in a) {\n    if (k === 'mode' || k === 'alpha') {\n      continue;\n    }\n    if (!(k in b)) {\n      throw new Error(`Can’t compare ${a.mode} to ${b.mode}`);\n    }\n    if (Math.abs((a as any)[k] - (b as any)[k]) > tolerance) {\n      return false;\n    }\n  }\n  return true;\n}\n\nconst ERROR_COLOR = 'COLOR';\nconst ERROR_BORDER = 'BORDER';\nconst ERROR_GRADIENT = 'GRADIENT';\nconst ERROR_SHADOW = 'SHADOW';\n\nconst rule: LintRule<\n  typeof ERROR_COLOR | typeof ERROR_BORDER | typeof ERROR_GRADIENT | typeof ERROR_SHADOW,\n  RuleMaxGamutOptions\n> = {\n  meta: {\n    messages: {\n      [ERROR_COLOR]: 'Color {{ id }} is outside {{ gamut }} gamut',\n      [ERROR_BORDER]: 'Border {{ id }} is outside {{ gamut }} gamut',\n      [ERROR_GRADIENT]: 'Gradient {{ id }} is outside {{ gamut }} gamut',\n      [ERROR_SHADOW]: 'Shadow {{ id }} is outside {{ gamut }} gamut',\n    },\n    docs: {\n      description: 'Enforce colors are within the specified gamut.',\n      url: docsLink(MAX_GAMUT),\n    },\n  },\n  defaultOptions: { gamut: 'rec2020' },\n  create({ tokens, options, report }) {\n    if (!options?.gamut) {\n      return;\n    }\n    if (options.gamut !== 'srgb' && options.gamut !== 'p3' && options.gamut !== 'rec2020') {\n      throw new Error(`Unknown gamut \"${options.gamut}\". Options are \"srgb\", \"p3\", or \"rec2020\"`);\n    }\n\n    const shouldIgnore = options.ignore ? wcmatch(options.ignore) : null;\n\n    for (const t of Object.values(tokens)) {\n      // skip ignored tokens\n      if (shouldIgnore?.(t.id)) {\n        continue;\n      }\n\n      // skip aliases\n      if (t.aliasOf) {\n        continue;\n      }\n\n      switch (t.$type) {\n        case 'color': {\n          if (!isWithinGamut(t.$value, options.gamut)) {\n            report({ messageId: ERROR_COLOR, data: { id: t.id, gamut: options.gamut }, node: t.source.node });\n          }\n          break;\n        }\n        case 'border': {\n          if (!t.partialAliasOf?.color && !isWithinGamut(t.$value.color, options.gamut)) {\n            report({ messageId: ERROR_BORDER, data: { id: t.id, gamut: options.gamut }, node: t.source.node });\n          }\n          break;\n        }\n        case 'gradient': {\n          for (let stopI = 0; stopI < t.$value.length; stopI++) {\n            if (!t.partialAliasOf?.[stopI]?.color && !isWithinGamut(t.$value[stopI]!.color, options.gamut)) {\n              report({ messageId: ERROR_GRADIENT, data: { id: t.id, gamut: options.gamut }, node: t.source.node });\n            }\n          }\n          break;\n        }\n        case 'shadow': {\n          for (let shadowI = 0; shadowI < t.$value.length; shadowI++) {\n            if (!t.partialAliasOf?.[shadowI]?.color && !isWithinGamut(t.$value[shadowI]!.color, options.gamut)) {\n              report({ messageId: ERROR_SHADOW, data: { id: t.id, gamut: options.gamut }, node: t.source.node });\n            }\n          }\n          break;\n        }\n      }\n    }\n  },\n};\n\nexport default rule;\n","import wcmatch from 'wildcard-match';\nimport type { LintRule } from '../../../types.js';\nimport { docsLink } from '../lib/docs.js';\n\nexport const REQUIRED_CHILDREN = 'core/required-children';\n\nexport interface RequiredChildrenMatch {\n  /** Glob of tokens/groups to match */\n  match: string[];\n  /** Required token IDs to match (this only looks at the very last segment of a token ID!) */\n  requiredTokens?: string[];\n  /** Required groups to match (this only looks at the beginning/middle segments of a token ID!) */\n  requiredGroups?: string[];\n}\n\nexport interface RuleRequiredChildrenOptions {\n  matches: RequiredChildrenMatch[];\n}\n\nexport const ERROR_EMPTY_MATCH = 'EMPTY_MATCH';\nexport const ERROR_MISSING_REQUIRED_TOKENS = 'MISSING_REQUIRED_TOKENS';\nexport const ERROR_MISSING_REQUIRED_GROUP = 'MISSING_REQUIRED_GROUP';\n\nconst rule: LintRule<\n  typeof ERROR_EMPTY_MATCH | typeof ERROR_MISSING_REQUIRED_TOKENS | typeof ERROR_MISSING_REQUIRED_GROUP,\n  RuleRequiredChildrenOptions\n> = {\n  meta: {\n    messages: {\n      [ERROR_EMPTY_MATCH]: 'No tokens matched {{ matcher }}',\n      [ERROR_MISSING_REQUIRED_TOKENS]: 'Match {{ index }}: some groups missing required token \"{{ token }}\"',\n      [ERROR_MISSING_REQUIRED_GROUP]: 'Match {{ index }}: some tokens missing required group \"{{ group }}\"',\n    },\n    docs: {\n      description: 'Enforce token groups have specific children, whether tokens and/or groups.',\n      url: docsLink(REQUIRED_CHILDREN),\n    },\n  },\n  defaultOptions: { matches: [] },\n  create({ tokens, options, report }) {\n    if (!options.matches?.length) {\n      throw new Error('Invalid config. Missing `matches: […]`');\n    }\n\n    // note: in many other rules, the operation can be completed in one iteration through all tokens\n    // in this rule, however, we have to scan all tokens every time per-match, because they may overlap\n\n    for (let matchI = 0; matchI < options.matches.length; matchI++) {\n      const { match, requiredTokens, requiredGroups } = options.matches[matchI]!;\n\n      // validate\n      if (!match.length) {\n        throw new Error(`Match ${matchI}: must declare \\`match: […]\\``);\n      }\n      if (!requiredTokens?.length && !requiredGroups?.length) {\n        throw new Error(`Match ${matchI}: must declare either \\`requiredTokens: […]\\` or \\`requiredGroups: […]\\``);\n      }\n\n      const matcher = wcmatch(match);\n\n      const matchGroups: string[] = [];\n      const matchTokens: string[] = [];\n      let tokensMatched = false;\n      for (const t of Object.values(tokens)) {\n        if (!matcher(t.id)) {\n          continue;\n        }\n        tokensMatched = true;\n        const groups = t.id.split('.');\n        matchTokens.push(groups.pop()!);\n        matchGroups.push(...groups);\n      }\n\n      if (!tokensMatched) {\n        report({\n          messageId: ERROR_EMPTY_MATCH,\n          data: { matcher: JSON.stringify(match) },\n        });\n        continue;\n      }\n\n      if (requiredTokens) {\n        for (const id of requiredTokens) {\n          if (!matchTokens.includes(id)) {\n            report({\n              messageId: ERROR_MISSING_REQUIRED_TOKENS,\n              data: { index: matchI, token: id },\n            });\n          }\n        }\n      }\n      if (requiredGroups) {\n        for (const groupName of requiredGroups) {\n          if (!matchGroups.includes(groupName)) {\n            report({\n              messageId: ERROR_MISSING_REQUIRED_GROUP,\n              data: { index: matchI, group: groupName },\n            });\n          }\n        }\n      }\n    }\n  },\n};\n\nexport default rule;\n","import wcmatch from 'wildcard-match';\nimport type { LintRule } from '../../../types.js';\nimport { docsLink } from '../lib/docs.js';\n\nexport const REQUIRED_MODES = 'core/required-modes';\n\nexport type RequiredModesMatch = {\n  /** Glob of tokens/groups to match */\n  match: string[];\n  /** Required modes */\n  modes: string[];\n};\n\nexport interface RuleRequiredModesOptions {\n  matches: RequiredModesMatch[];\n}\n\nconst rule: LintRule<never, RuleRequiredModesOptions> = {\n  meta: {\n    docs: {\n      description: 'Enforce certain tokens have specific modes.',\n      url: docsLink(REQUIRED_MODES),\n    },\n  },\n  defaultOptions: { matches: [] },\n  create({ tokens, options, report }) {\n    if (!options?.matches?.length) {\n      throw new Error('Invalid config. Missing `matches: […]`');\n    }\n\n    // note: in many other rules, the operation can be completed in one iteration through all tokens\n    // in this rule, however, we have to scan all tokens every time per-match, because they may overlap\n    for (let matchI = 0; matchI < options.matches.length; matchI++) {\n      const { match, modes } = options.matches[matchI]!;\n\n      // validate\n      if (!match.length) {\n        throw new Error(`Match ${matchI}: must declare \\`match: […]\\``);\n      }\n      if (!modes?.length) {\n        throw new Error(`Match ${matchI}: must declare \\`modes: […]\\``);\n      }\n\n      const matcher = wcmatch(match);\n\n      let tokensMatched = false;\n      for (const t of Object.values(tokens)) {\n        if (!matcher(t.id)) {\n          continue;\n        }\n        tokensMatched = true;\n\n        for (const mode of modes) {\n          if (!t.mode?.[mode]) {\n            report({\n              message: `Token ${t.id}: missing required mode \"${mode}\"`,\n              node: t.source.node,\n            });\n          }\n        }\n\n        if (!tokensMatched) {\n          report({\n            message: `Match \"${matchI}\": no tokens matched ${JSON.stringify(match)}`,\n            node: t.source.node,\n          });\n        }\n      }\n    }\n  },\n};\n\nexport default rule;\n","import wcmatch from 'wildcard-match';\nimport type { LintRule } from '../../../types.js';\nimport { docsLink } from '../lib/docs.js';\n\nexport const REQUIRED_TYPOGRAPHY_PROPERTIES = 'core/required-typography-properties';\n\nexport interface RuleRequiredTypographyPropertiesOptions {\n  /** Required typography properties */\n  properties: string[];\n  /** Token globs to ignore */\n  ignore?: string[];\n}\n\nconst rule: LintRule<never, RuleRequiredTypographyPropertiesOptions> = {\n  meta: {\n    docs: {\n      description: 'Enforce typography tokens have required properties.',\n      url: docsLink(REQUIRED_TYPOGRAPHY_PROPERTIES),\n    },\n  },\n  defaultOptions: { properties: [] },\n  create({ tokens, options, report }) {\n    if (!options) {\n      return;\n    }\n\n    if (!options.properties.length) {\n      throw new Error(`\"properties\" can’t be empty`);\n    }\n\n    const shouldIgnore = options.ignore ? wcmatch(options.ignore) : null;\n\n    for (const t of Object.values(tokens)) {\n      if (shouldIgnore?.(t.id)) {\n        continue;\n      }\n\n      if (t.$type !== 'typography') {\n        continue;\n      }\n\n      if (t.aliasOf) {\n        continue;\n      }\n\n      for (const p of options.properties) {\n        if (!t.partialAliasOf?.[p] && !(p in t.$value)) {\n          report({ message: `${t.id} missing required typographic property \"${p}\"`, node: t.source.node });\n        }\n      }\n    }\n  },\n};\n\nexport default rule;\n","// Terrazzo internal plugin that powers lint rules. Always enabled (but all\n// rules are opt-in).\nimport type { Plugin } from '../../types.js';\n\nexport * from './rules/a11y-min-contrast.js';\nexport * from './rules/a11y-min-font-size.js';\nexport * from './rules/colorspace.js';\nexport * from './rules/consistent-naming.js';\nexport * from './rules/descriptions.js';\nexport * from './rules/duplicate-values.js';\nexport * from './rules/max-gamut.js';\nexport * from './rules/required-children.js';\nexport * from './rules/required-modes.js';\nexport * from './rules/required-typography-properties.js';\n\nimport a11yMinContrast, { A11Y_MIN_CONTRAST } from './rules/a11y-min-contrast.js';\nimport a11yMinFontSize, { A11Y_MIN_FONT_SIZE } from './rules/a11y-min-font-size.js';\nimport colorspace, { COLORSPACE } from './rules/colorspace.js';\nimport consistentNaming, { CONSISTENT_NAMING } from './rules/consistent-naming.js';\nimport descriptions, { DESCRIPTIONS } from './rules/descriptions.js';\nimport duplicateValues, { DUPLICATE_VALUES } from './rules/duplicate-values.js';\nimport maxGamut, { MAX_GAMUT } from './rules/max-gamut.js';\nimport requiredChidlren, { REQUIRED_CHILDREN } from './rules/required-children.js';\nimport requiredModes, { REQUIRED_MODES } from './rules/required-modes.js';\nimport requiredTypographyProperties, {\n  REQUIRED_TYPOGRAPHY_PROPERTIES,\n} from './rules/required-typography-properties.js';\n\nexport default function coreLintPlugin(): Plugin {\n  return {\n    name: '@terrazzo/plugin-lint-core',\n    lint() {\n      return {\n        [COLORSPACE]: colorspace,\n        [CONSISTENT_NAMING]: consistentNaming,\n        [DESCRIPTIONS]: descriptions,\n        [DUPLICATE_VALUES]: duplicateValues,\n        [MAX_GAMUT]: maxGamut,\n        [REQUIRED_CHILDREN]: requiredChidlren,\n        [REQUIRED_MODES]: requiredModes,\n        [REQUIRED_TYPOGRAPHY_PROPERTIES]: requiredTypographyProperties,\n        [A11Y_MIN_CONTRAST]: a11yMinContrast,\n        [A11Y_MIN_FONT_SIZE]: a11yMinFontSize,\n      };\n    },\n  };\n}\n","import { merge } from 'merge-anything';\nimport coreLintPlugin from './lint/plugin-core/index.js';\nimport Logger from './logger.js';\nimport type { Config, ConfigInit, ConfigOptions, LintRuleSeverity } from './types.js';\n\nconst TRAILING_SLASH_RE = /\\/*$/;\n\n/**\n * Validate and normalize a config\n */\nexport default function defineConfig(\n  rawConfig: Config,\n  { logger = new Logger(), cwd }: ConfigOptions = {} as ConfigOptions,\n): ConfigInit {\n  const configStart = performance.now();\n\n  if (!cwd) {\n    logger.error({ group: 'config', label: 'core', message: 'defineConfig() missing `cwd` for JS API' });\n  }\n\n  const config = merge({}, rawConfig) as unknown as ConfigInit;\n\n  // 1. normalize and init\n  normalizeTokens({ rawConfig, config, logger, cwd });\n  normalizeOutDir({ config, cwd, logger });\n  normalizePlugins({ config, logger });\n  normalizeLint({ config, logger });\n  normalizeIgnore({ config, logger });\n\n  // 2. Start build by calling config()\n  for (const plugin of config.plugins) {\n    plugin.config?.({ ...config });\n  }\n\n  // 3. finish\n  logger.debug({\n    group: 'parser',\n    label: 'config',\n    message: 'Finish config validation',\n    timing: performance.now() - configStart,\n  });\n  return config;\n}\n\n/** Normalize config.tokens */\nfunction normalizeTokens({\n  rawConfig,\n  config,\n  logger,\n  cwd,\n}: {\n  rawConfig: Config;\n  config: ConfigInit;\n  logger: Logger;\n  cwd: URL;\n}) {\n  if (rawConfig.tokens === undefined) {\n    config.tokens = [\n      // @ts-ignore we’ll normalize in next step\n      './tokens.json',\n    ];\n  } else if (typeof rawConfig.tokens === 'string') {\n    config.tokens = [\n      // @ts-ignore we’ll normalize in next step\n      rawConfig.tokens,\n    ];\n  } else if (Array.isArray(rawConfig.tokens)) {\n    config.tokens = [];\n    for (const file of rawConfig.tokens) {\n      if (typeof file === 'string' || (file as URL) instanceof URL) {\n        config.tokens.push(\n          // @ts-ignore we’ll normalize in next step\n          file,\n        );\n      } else {\n        logger.error({\n          group: 'config',\n          label: 'tokens',\n          message: `Expected array of strings, encountered ${JSON.stringify(file)}`,\n        });\n      }\n    }\n  } else {\n    logger.error({\n      group: 'config',\n      label: 'tokens',\n      message: `Expected string or array of strings, received ${typeof rawConfig.tokens}`,\n    });\n  }\n  for (let i = 0; i < config.tokens!.length; i++) {\n    const filepath = config.tokens[i]!;\n    if (filepath instanceof URL) {\n      continue; // skip if already resolved\n    }\n    try {\n      config.tokens[i] = new URL(filepath, cwd);\n    } catch {\n      logger.error({ group: 'config', label: 'tokens', message: `Invalid URL ${filepath}` });\n    }\n  }\n}\n\n/** Normalize config.outDir */\nfunction normalizeOutDir({ config, cwd, logger }: { config: ConfigInit; logger: Logger; cwd: URL }) {\n  if (config.outDir instanceof URL) {\n    // noop\n  } else if (typeof config.outDir === 'undefined') {\n    config.outDir = new URL('./tokens/', cwd);\n  } else if (typeof config.outDir !== 'string') {\n    logger.error({\n      group: 'config',\n      label: 'outDir',\n      message: `Expected string, received ${JSON.stringify(config.outDir)}`,\n    });\n  } else {\n    config.outDir = new URL(config.outDir, cwd);\n    // always add trailing slash so URL treats it as a directory.\n    // do AFTER it has been normalized to POSIX paths with `href` (don’t use Node internals here! This may run in the browser)\n    config.outDir = new URL(config.outDir.href.replace(TRAILING_SLASH_RE, '/'));\n  }\n}\n\n/** Normalize config.plugins */\nfunction normalizePlugins({ config, logger }: { config: ConfigInit; logger: Logger }) {\n  if (typeof config.plugins === 'undefined') {\n    config.plugins = [];\n  }\n  if (!Array.isArray(config.plugins)) {\n    logger.error({\n      group: 'config',\n      label: 'plugins',\n      message: `Expected array of plugins, received ${JSON.stringify(config.plugins)}`,\n    });\n  }\n  config.plugins.push(coreLintPlugin());\n  for (let n = 0; n < config.plugins.length; n++) {\n    const plugin = config.plugins[n];\n    if (typeof plugin !== 'object') {\n      logger.error({\n        group: 'config',\n        label: `plugin[${n}]`,\n        message: `Expected output plugin, received ${JSON.stringify(plugin)}`,\n      });\n    } else if (!plugin.name) {\n      logger.error({ group: 'config', label: `plugin[${n}]`, message: `Missing \"name\"` });\n    }\n  }\n  // order plugins with \"enforce\"\n  config.plugins.sort((a, b) => {\n    if (a.enforce === 'pre' && b.enforce !== 'pre') {\n      return -1;\n    } else if (a.enforce === 'post' && b.enforce !== 'post') {\n      return 1;\n    }\n    return 0;\n  });\n}\n\nfunction normalizeLint({ config, logger }: { config: ConfigInit; logger: Logger }) {\n  if (config.lint !== undefined) {\n    if (config.lint === null || typeof config.lint !== 'object' || Array.isArray(config.lint)) {\n      logger.error({ group: 'config', label: 'lint', message: 'Must be an object' });\n    }\n    if (!config.lint.build) {\n      config.lint.build = { enabled: true };\n    }\n    if (config.lint.build.enabled !== undefined) {\n      if (typeof config.lint.build.enabled !== 'boolean') {\n        logger.error({\n          group: 'config',\n          label: 'lint › build › enabled',\n          message: `Expected boolean, received ${JSON.stringify(config.lint.build)}`,\n        });\n      }\n    } else {\n      config.lint.build.enabled = true;\n    }\n\n    if (config.lint.rules === undefined) {\n      config.lint.rules = {};\n    } else {\n      if (config.lint.rules === null || typeof config.lint.rules !== 'object' || Array.isArray(config.lint.rules)) {\n        logger.error({\n          group: 'config',\n          label: 'lint › rules',\n          message: `Expected object, received ${JSON.stringify(config.lint.rules)}`,\n        });\n        return;\n      }\n\n      const allRules = new Map<string, string>();\n      for (const plugin of config.plugins) {\n        if (typeof plugin.lint !== 'function') {\n          continue;\n        }\n        const pluginRules = plugin.lint();\n        if (!pluginRules || Array.isArray(pluginRules) || typeof pluginRules !== 'object') {\n          logger.error({\n            group: 'config',\n            label: `plugin › ${plugin.name}`,\n            message: `Expected object for lint() received ${JSON.stringify(pluginRules)}`,\n          });\n          continue;\n        }\n        for (const rule of Object.keys(pluginRules)) {\n          // Note: sometimes plugins will be loaded multiple times, in which case it’s expected\n          // they’re register rules again for lint(). Only throw an error if plugin A and plugin B’s\n          // rules conflict.\n\n          if (allRules.get(rule) && allRules.get(rule) !== plugin.name) {\n            logger.error({\n              group: 'config',\n              label: `plugin › ${plugin.name}`,\n              message: `Duplicate rule ${rule} already registered by plugin ${allRules.get(rule)}`,\n            });\n          }\n          allRules.set(rule, plugin.name);\n        }\n      }\n\n      for (const id of Object.keys(config.lint.rules)) {\n        if (!allRules.has(id)) {\n          logger.error({\n            group: 'config',\n            label: `lint › rule › ${id}`,\n            message: 'Unknown rule. Is the plugin installed?',\n          });\n        }\n\n        const value = config.lint.rules[id];\n        let severity: LintRuleSeverity = 'off';\n        let options: any;\n        if (typeof value === 'number' || typeof value === 'string') {\n          severity = value;\n        } else if (Array.isArray(value)) {\n          severity = value[0] as LintRuleSeverity;\n          options = value[1];\n        } else if (value !== undefined) {\n          logger.error({\n            group: 'config',\n            label: `lint › rule › ${id}`,\n            message: `Invalid eyntax. Expected \\`string | number | Array\\`, received ${JSON.stringify(value)}}`,\n          });\n        }\n        config.lint.rules[id] = [severity, options];\n        if (typeof severity === 'number') {\n          if (severity !== 0 && severity !== 1 && severity !== 2) {\n            logger.error({\n              group: 'config',\n              label: `lint › rule › ${id}`,\n              message: `Invalid number ${severity}. Specify 0 (off), 1 (warn), or 2 (error).`,\n            });\n          }\n          config.lint.rules[id]![0] = (['off', 'warn', 'error'] as const)[severity]!;\n        } else if (typeof severity === 'string') {\n          if (severity !== 'off' && severity !== 'warn' && severity !== 'error') {\n            logger.error({\n              group: 'config',\n              label: `lint › rule › ${id}`,\n              message: `Invalid string ${JSON.stringify(severity)}. Specify \"off\", \"warn\", or \"error\".`,\n            });\n          }\n        } else if (value !== null) {\n          logger.error({\n            group: 'config',\n            label: `lint › rule › ${id}`,\n            message: `Expected string or number, received ${JSON.stringify(value)}`,\n          });\n        }\n      }\n    }\n  } else {\n    config.lint = {\n      build: { enabled: true },\n      rules: {},\n    };\n  }\n}\n\nfunction normalizeIgnore({ config, logger }: { config: ConfigInit; logger: Logger }) {\n  if (!config.ignore) {\n    config.ignore = {} as typeof config.ignore;\n  }\n  config.ignore.tokens ??= [];\n  config.ignore.deprecated ??= false;\n  if (!Array.isArray(config.ignore.tokens) || config.ignore.tokens.some((x) => typeof x !== 'string')) {\n    logger.error({\n      group: 'config',\n      label: 'ignore › tokens',\n      message: `Expected array of strings, received ${JSON.stringify(config.ignore.tokens)}`,\n    });\n  }\n  if (typeof config.ignore.deprecated !== 'boolean') {\n    logger.error({\n      group: 'config',\n      label: 'ignore › deprecated',\n      message: `Expected boolean, received ${JSON.stringify(config.ignore.deprecated)}`,\n    });\n  }\n}\n\n/** Merge configs */\nexport function mergeConfigs(a: Config, b: Config): Config {\n  return merge(a, b);\n}\n","import { pluralize, type TokenNormalized } from '@terrazzo/token-tools';\nimport { merge } from 'merge-anything';\nimport type { LogEntry, default as Logger } from '../logger.js';\nimport type { ConfigInit } from '../types.js';\n\nconst listFormat = new Intl.ListFormat('en-us');\n\nexport interface LintRunnerOptions {\n  tokens: Record<string, TokenNormalized>;\n  filename?: URL;\n  config: ConfigInit;\n  src: string;\n  logger: Logger;\n}\n\nexport default async function lintRunner({\n  tokens,\n  filename,\n  config = {} as ConfigInit,\n  src,\n  logger,\n}: LintRunnerOptions): Promise<void> {\n  const { plugins = [], lint } = config;\n  const unusedLintRules = Object.keys(lint?.rules ?? {});\n\n  for (const plugin of plugins) {\n    if (typeof plugin.lint === 'function') {\n      const s = performance.now();\n\n      const linter = plugin.lint();\n      const errors: LogEntry[] = [];\n      const warnings: LogEntry[] = [];\n\n      await Promise.all(\n        Object.entries(linter).map(async ([id, rule]) => {\n          if (!(id in lint.rules) || lint.rules[id] === null) {\n            return;\n          }\n          const [severity, options] = lint.rules[id]!;\n          if (severity === 'off') {\n            return;\n          }\n\n          // note: this usually isn’t a Promise, but it _might_ be!\n          await rule.create({\n            id,\n            report(descriptor) {\n              let message = '';\n              if (!descriptor.message && !descriptor.messageId) {\n                logger.error({\n                  group: 'lint',\n                  label: `${plugin.name} › lint › ${id}`,\n                  message: 'Unable to report error: missing message or messageId',\n                });\n              }\n\n              // handle message or messageId\n              if (descriptor.message) {\n                message = descriptor.message;\n              } else {\n                if (!(descriptor.messageId! in (rule.meta?.messages ?? {}))) {\n                  logger.error({\n                    group: 'lint',\n                    label: `${plugin.name} › lint › ${id}`,\n                    message: `messageId \"${descriptor.messageId}\" does not exist`,\n                  });\n                }\n                message = rule.meta?.messages?.[descriptor.messageId as keyof typeof rule.meta.messages] ?? '';\n              }\n\n              // replace with descriptor.data (if any)\n              if (descriptor.data && typeof descriptor.data === 'object') {\n                for (const [k, v] of Object.entries(descriptor.data)) {\n                  // lazy formatting\n                  const formatted = ['string', 'number', 'boolean'].includes(typeof v) ? String(v) : JSON.stringify(v);\n                  message = message.replace(/{{[^}]+}}/g, (inner) => {\n                    const key = inner.substring(2, inner.length - 2).trim();\n                    return key === k ? formatted : inner;\n                  });\n                }\n              }\n\n              (severity === 'error' ? errors : warnings).push({\n                group: 'lint',\n                label: id,\n                message,\n                filename,\n                node: descriptor.node,\n                src: descriptor.source?.src,\n              });\n            },\n            tokens,\n            filename,\n            src,\n            options: merge(\n              rule.meta?.defaultOptions ?? [],\n              rule.defaultOptions ?? [], // Note: is this the correct order to merge in?\n              options,\n            ),\n          });\n          // tick off used rule\n          const unusedLintRuleI = unusedLintRules.indexOf(id);\n          if (unusedLintRuleI !== -1) {\n            unusedLintRules.splice(unusedLintRuleI, 1);\n          }\n        }),\n      );\n\n      for (const error of errors) {\n        logger.error({ ...error, continueOnError: true }); // print out all errors before exiting here\n      }\n      for (const warning of warnings) {\n        logger.warn(warning);\n      }\n\n      logger.debug({ group: 'lint', label: plugin.name, message: 'Finished', timing: performance.now() - s });\n\n      if (errors.length) {\n        const counts = [pluralize(errors.length, 'error', 'errors')];\n        if (warnings.length) {\n          counts.push(pluralize(warnings.length, 'warning', 'warnings'));\n        }\n        logger.error({\n          group: 'lint',\n          message: `Lint failed with ${listFormat.format(counts)}`,\n          label: plugin.name,\n          continueOnError: false,\n        });\n      }\n    }\n  }\n\n  // warn user if they have unused lint rules (they might have meant to configure something!)\n  for (const unusedRule of unusedLintRules) {\n    logger.warn({ group: 'lint', label: 'lint', message: `Unknown lint rule \"${unusedRule}\"` });\n  }\n}\n","/**\n * @fileoverview Character codes.\n * @author Nicholas C. Zakas\n */\n\nconst CHAR_0 = 48;          // 0\nconst CHAR_1 = 49;          // 1\nconst CHAR_9 = 57;          // 9\nconst CHAR_BACKSLASH = 92;  // \\\nconst CHAR_DOLLAR = 36;     // $\nconst CHAR_DOT = 46;        // .\nconst CHAR_DOUBLE_QUOTE = 34; // \"\nconst CHAR_LOWER_A = 97;    // a\nconst CHAR_LOWER_E = 101;         // e\nconst CHAR_LOWER_F = 102;   // f\nconst CHAR_LOWER_N = 110;   // n\nconst CHAR_LOWER_T = 116;   // t\nconst CHAR_LOWER_U = 117;   // u\nconst CHAR_LOWER_X = 120;   // x\nconst CHAR_LOWER_Z = 122;   // z\nconst CHAR_MINUS = 45;      // -\nconst CHAR_NEWLINE = 10;    // newline\nconst CHAR_PLUS = 43;       // +\nconst CHAR_RETURN = 13;     // return\nconst CHAR_SINGLE_QUOTE = 39; // '\nconst CHAR_SLASH = 47;      // /\nconst CHAR_SPACE = 32;      // space\nconst CHAR_TAB = 9;         // tab\nconst CHAR_UNDERSCORE = 95; // _\nconst CHAR_UPPER_A = 65;    // A\nconst CHAR_UPPER_E = 69;          // E\nconst CHAR_UPPER_F = 70;    // F\nconst CHAR_UPPER_N = 78;    // N\nconst CHAR_UPPER_X = 88;    // X\nconst CHAR_UPPER_Z = 90;    // Z\nconst CHAR_LOWER_B = 98;    // b\nconst CHAR_LOWER_R = 114;   // r\nconst CHAR_LOWER_V = 118;   // v\nconst CHAR_LINE_SEPARATOR = 0x2028;\nconst CHAR_PARAGRAPH_SEPARATOR = 0x2029;\nconst CHAR_UPPER_I = 73;    // I\nconst CHAR_STAR = 42;       // *\nconst CHAR_VTAB = 11;            // U+000B Vertical tab\nconst CHAR_FORM_FEED = 12;       // U+000C Form feed\nconst CHAR_NBSP = 160;           // U+00A0 Non-breaking space\nconst CHAR_BOM = 65279;          // U+FEFF\nconst CHAR_NON_BREAKING_SPACE = 160;\nconst CHAR_EN_QUAD = 8192;\nconst CHAR_EM_QUAD = 8193;\nconst CHAR_EN_SPACE = 8194;\nconst CHAR_EM_SPACE = 8195;\nconst CHAR_THREE_PER_EM_SPACE = 8196;\nconst CHAR_FOUR_PER_EM_SPACE = 8197;\nconst CHAR_SIX_PER_EM_SPACE = 8198;\nconst CHAR_FIGURE_SPACE = 8199;\nconst CHAR_PUNCTUATION_SPACE = 8200;\nconst CHAR_THIN_SPACE = 8201;\nconst CHAR_HAIR_SPACE = 8202;\nconst CHAR_NARROW_NO_BREAK_SPACE = 8239;\nconst CHAR_MEDIUM_MATHEMATICAL_SPACE = 8287;\nconst CHAR_IDEOGRAPHIC_SPACE = 12288;\n\n/**\n * @fileoverview JSON syntax helpers\n * @author Nicholas C. Zakas\n */\n\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typedefs.js\").TokenType} TokenType */\n\n//-----------------------------------------------------------------------------\n// Predefined Tokens\n//-----------------------------------------------------------------------------\n\nconst LBRACKET = \"[\";\nconst RBRACKET = \"]\";\nconst LBRACE = \"{\";\nconst RBRACE = \"}\";\nconst COLON = \":\";\nconst COMMA = \",\";\n\nconst TRUE = \"true\";\nconst FALSE = \"false\";\nconst NULL = \"null\";\nconst NAN$1 = \"NaN\";\nconst INFINITY$1 = \"Infinity\";\nconst QUOTE = \"\\\"\";\n\nconst escapeToChar = new Map([\n    [CHAR_DOUBLE_QUOTE, QUOTE],\n    [CHAR_BACKSLASH, \"\\\\\"],\n    [CHAR_SLASH, \"/\"],\n    [CHAR_LOWER_B, \"\\b\"],\n    [CHAR_LOWER_N, \"\\n\"],\n    [CHAR_LOWER_F, \"\\f\"],\n    [CHAR_LOWER_R, \"\\r\"],\n    [CHAR_LOWER_T, \"\\t\"]\n]);\n\nconst json5EscapeToChar = new Map([\n    ...escapeToChar,\n    [CHAR_LOWER_V, \"\\v\"],\n    [CHAR_0, \"\\0\"]\n]);\n\nconst charToEscape = new Map([\n    [QUOTE, QUOTE],\n    [\"\\\\\", \"\\\\\"],\n    [\"/\", \"/\"],\n    [\"\\b\", \"b\"],\n    [\"\\n\", \"n\"],\n    [\"\\f\", \"f\"],\n    [\"\\r\", \"r\"],\n    [\"\\t\", \"t\"]\n]);\n\nconst json5CharToEscape = new Map([\n    ...charToEscape,\n    [\"\\v\", \"v\"],\n    [\"\\0\", \"0\"],\n    [\"\\u2028\", \"u2028\"],\n    [\"\\u2029\", \"u2029\"]\n]);\n\n/** @type {Map<string,TokenType>} */\nconst knownTokenTypes = new Map([\n    [LBRACKET, \"LBracket\"],\n    [RBRACKET, \"RBracket\"],\n    [LBRACE, \"LBrace\"],\n    [RBRACE, \"RBrace\"],\n    [COLON, \"Colon\"],\n    [COMMA, \"Comma\"],\n    [TRUE, \"Boolean\"],\n    [FALSE, \"Boolean\"],\n    [NULL, \"Null\"]\n]);\n\n/** @type {Map<string,TokenType>} */\nconst knownJSON5TokenTypes = new Map([\n    ...knownTokenTypes,\n    [NAN$1, \"Number\"],\n    [INFINITY$1, \"Number\"]\n]);\n\n// JSON5\nconst json5LineTerminators = new Set([\n    CHAR_NEWLINE,\n    CHAR_RETURN,\n    CHAR_LINE_SEPARATOR,\n    CHAR_PARAGRAPH_SEPARATOR\n]);\n\n/**\n * @fileoverview JSON tokenization/parsing errors\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typedefs.js\").Location} Location */\n/** @typedef {import(\"./typedefs.js\").Token} Token */\n\n//-----------------------------------------------------------------------------\n// Errors\n//-----------------------------------------------------------------------------\n\n/**\n * Base class that attaches location to an error.\n */\nclass ErrorWithLocation extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {string} message The error message to report. \n     * @param {Location} loc The location information for the error.\n     */\n    constructor(message, { line, column, offset }) {\n        super(`${ message } (${ line }:${ column})`);\n\n        /**\n         * The line on which the error occurred.\n         * @type {number}\n         */\n        this.line = line;\n\n        /**\n         * The column on which the error occurred.\n         * @type {number}\n         */\n        this.column = column;\n        \n        /**\n         * The index into the string where the error occurred.\n         * @type {number}\n         */\n        this.offset = offset;\n    }\n\n}\n\n/**\n * Error thrown when an unexpected character is found during tokenizing.\n */\nclass UnexpectedChar extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {number} unexpected The character that was found.\n     * @param {Location} loc The location information for the found character.\n     */\n    constructor(unexpected, loc) {\n        super(`Unexpected character '${ String.fromCharCode(unexpected) }' found.`, loc);\n    }\n}\n\n/**\n * Error thrown when an unexpected identifier is found during tokenizing.\n */\nclass UnexpectedIdentifier extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} unexpected The character that was found.\n     * @param {Location} loc The location information for the found character.\n     */\n    constructor(unexpected, loc) {\n        super(`Unexpected identifier '${ unexpected }' found.`, loc);\n    }\n}\n\n/**\n * Error thrown when an unexpected token is found during parsing.\n */\nclass UnexpectedToken extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {Token} token The token that was found. \n     */\n    constructor(token) {\n        super(`Unexpected token ${ token.type } found.`, token.loc.start);\n    }\n}\n\n/**\n * Error thrown when the end of input is found where it isn't expected.\n */\nclass UnexpectedEOF extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {Location} loc The location information for the found character.\n     */\n    constructor(loc) {\n        super(\"Unexpected end of input found.\", loc);\n    }\n}\n\n/*\n * The following is extracted from https://github.com/json5/json5/\n *\n * MIT License\n * \n * Copyright (c) 2012-2018 Aseem Kishore, and others.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nconst ID_Start = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE83\\uDE86-\\uDE89\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/;\n// eslint-disable-next-line no-misleading-character-class\nconst ID_Continue = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF9\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE83\\uDE86-\\uDE99\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/;\n\n/**\n * @fileoverview A charactor code reader.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n\n//-----------------------------------------------------------------------------\n// Data\n//-----------------------------------------------------------------------------\n\nconst CHAR_CR = 13; // \\r\nconst CHAR_LF = 10; // \\n\n\n//-----------------------------------------------------------------------------\n// CharCodeReader\n//-----------------------------------------------------------------------------\n\n/**\n * A reader that reads character codes from a string.\n */\nclass CharCodeReader {\n\n    /**\n     * The text to read from.\n     * @type {string}\n     */\n    #text = \"\";\n\n    /**\n     * The current line number.\n     * @type {number}\n     */\n    #line = 1;\n\n    /**\n     * The current column number.\n     * @type {number}\n     */\n    #column = 0;\n\n    /**\n     * The current offset in the text.\n     * @type {number}\n     */\n    #offset = -1;\n\n    /**\n     * Whether the last character read was a new line.\n     * @type {boolean}\n     */\n    #newLine = false;\n\n    /**\n     * The last character code read.\n     * @type {number}\n     */\n    #last = -1;\n\n    /**\n     * Whether the reader has ended.\n     * @type {boolean}\n     */\n    #ended = false;\n\n    /**\n     * Creates a new instance.\n     * @param {string} text The text to read from\n     */\n    constructor(text) {\n        this.#text = text;\n    }\n\n    /**\n     * Ends the reader.\n     * @returns {void}\n     */\n    #end() {\n        if (this.#ended) {\n            return;\n        }\n\n        this.#column++;\n        this.#offset++;\n        this.#last = -1;\n        this.#ended = true;\n    }\n\n    /**\n     * Returns the current position of the reader.\n     * @returns {Location} An object with line, column, and offset properties.\n     */\n    locate() {\n        return {\n            line: this.#line,\n            column: this.#column,\n            offset: this.#offset\n        };\n    }\n\n    /**\n     * Reads the next character code in the text.\n     * @returns {number} The next character code, or -1 if there are no more characters.\n     */\n    next() {\n        if (this.#offset >= this.#text.length - 1) {\n            this.#end();\n            return -1;\n        }\n\n        this.#offset++;\n        const charCode = this.#text.charCodeAt(this.#offset);\n\n        if (this.#newLine) {\n            this.#line++;\n            this.#column = 1;\n            this.#newLine = false;\n        } else {\n            this.#column++;\n        }\n\n        if (charCode === CHAR_CR) {\n            this.#newLine = true;\n\n            // if we already see a \\r, just ignore upcoming \\n\n            if (this.peek() === CHAR_LF) {\n                this.#offset++;\n            }\n        } else if (charCode === CHAR_LF) {\n            this.#newLine = true;\n        }\n\n        this.#last = charCode;\n\n        return charCode;\n    }\n\n    /**\n     * Peeks at the next character code in the text.\n     * @returns {number} The next character code, or -1 if there are no more characters.\n     */\n    peek() {\n        if (this.#offset === this.#text.length - 1) {\n            return -1;\n        }\n\n        return this.#text.charCodeAt(this.#offset + 1);\n    }\n\n    /**\n     * Determines if the next character code in the text matches a specific character code.\n     * @param {(number) => boolean} fn A function to call on the next character.\n     * @returns {boolean} True if the next character code matches, false if not.\n     */ \n    match(fn) {\n        if (fn(this.peek())) {\n            this.next();\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the last character code read.\n     * @returns {number} The last character code read.\n     */\n    current() {\n        return this.#last;\n    }\n\n\n}\n\n/**\n * @fileoverview JSON tokenizer\n * @author Nicholas C. Zakas\n */\n\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typedefs.js\").Range} Range */\n/** @typedef {import(\"./typedefs.js\").TokenizeOptions} TokenizeOptions */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst INFINITY = \"Infinity\";\nconst NAN = \"NaN\";\n\nconst keywordStarts = new Set([CHAR_LOWER_T, CHAR_LOWER_F, CHAR_LOWER_N]);\nconst whitespace = new Set([CHAR_SPACE, CHAR_TAB, CHAR_NEWLINE, CHAR_RETURN]);\nconst json5Whitespace = new Set([\n    ...whitespace,\n    CHAR_VTAB,\n    CHAR_FORM_FEED,\n    CHAR_NBSP,\n    CHAR_LINE_SEPARATOR,\n    CHAR_PARAGRAPH_SEPARATOR,\n    CHAR_BOM,\n    CHAR_NON_BREAKING_SPACE,\n    CHAR_EN_QUAD,\n    CHAR_EM_QUAD,\n    CHAR_EN_SPACE,\n    CHAR_EM_SPACE,\n    CHAR_THREE_PER_EM_SPACE,\n    CHAR_FOUR_PER_EM_SPACE,\n    CHAR_SIX_PER_EM_SPACE,\n    CHAR_FIGURE_SPACE,\n    CHAR_PUNCTUATION_SPACE,\n    CHAR_THIN_SPACE,\n    CHAR_HAIR_SPACE,\n    CHAR_NARROW_NO_BREAK_SPACE,\n    CHAR_MEDIUM_MATHEMATICAL_SPACE,\n    CHAR_IDEOGRAPHIC_SPACE,\n]);\n\n\n/** @type {TokenizeOptions} */\nconst DEFAULT_OPTIONS$1 = {\n    mode: \"json\",\n    ranges: false\n};\n\nconst jsonKeywords = new Set([\"true\", \"false\", \"null\"]);\n\nconst tt = {\n    EOF: 0,\n    Number: 1,\n    String: 2,\n    Boolean: 3,\n    Null: 4,\n    NaN: 5,\n    Infinity: 6,\n    Identifier: 7,\n    Colon: 20,\n    LBrace: 21,\n    RBrace: 22,\n    LBracket: 23,\n    RBracket: 24,\n    Comma: 25,\n    LineComment: 40,\n    BlockComment: 41\n};\n\n\n// #region Helpers\n\n\n/**\n * Determines if a given character is a decimal digit.\n * @param {number} c The character to check.\n * @returns {boolean} `true` if the character is a digit.\n */\nfunction isDigit(c) {\n    return c >= CHAR_0 && c <= CHAR_9;\n}\n\n/**\n * Determines if a given character is a hexadecimal digit.\n * @param {number} c The character to check.\n * @returns {boolean} `true` if the character is a hexadecimal digit.\n */\nfunction isHexDigit(c) {\n    return isDigit(c) ||\n        c >= CHAR_UPPER_A && c <= CHAR_UPPER_F ||\n        c >= CHAR_LOWER_A && c <= CHAR_LOWER_F;\n}\n\n/**\n * Determines if a given character is a positive digit (1-9).\n * @param {number} c The character to check.\n * @returns {boolean} `true` if the character is a positive digit.\n */\nfunction isPositiveDigit(c) {\n    return c >= CHAR_1 && c <= CHAR_9;\n}\n\n/**\n * Determines if a given character is the start of a keyword.\n * @param {number} c The character to check.\n * @returns {boolean} `true` if the character is the start of a keyword.\n */\nfunction isKeywordStart(c) {\n    return keywordStarts.has(c);\n}\n\n/**\n * Determines if a given character is the start of a number.\n * @param {number} c The character to check.\n * @returns {boolean} `true` if the character is the start of a number.\n */\nfunction isNumberStart(c) {\n    return isDigit(c) || c === CHAR_DOT || c === CHAR_MINUS;\n}\n\n/**\n * Determines if a given character is the start of a JSON5 number.\n * @param {number} c The character to check.\n * @returns {boolean} `true` if the character is the start of a JSON5 number.\n */\nfunction isJSON5NumberStart(c) {\n    return isNumberStart(c) || c === CHAR_PLUS;\n}\n\n/**\n * Determines if a given character is the start of a string.\n * @param {number} c The character to check.\n * @param {boolean} json5 `true` if JSON5 mode is enabled.\n * @returns {boolean} `true` if the character is the start of a string.\n */\nfunction isStringStart(c, json5) {\n    return c === CHAR_DOUBLE_QUOTE || (json5 && c === CHAR_SINGLE_QUOTE);\n}\n\n/**\n * Tests that a given character is a valid first character of a\n * JSON5 identifier\n * @param {number} c The character to check.\n * @returns {boolean} `true` if the character is a valid first character. \n */\nfunction isJSON5IdentifierStart(c) {\n\n    // test simple cases first\n\n    if (c === CHAR_DOLLAR || c === CHAR_UNDERSCORE || c === CHAR_BACKSLASH) {\n        return true;\n    }\n\n    if (c >= CHAR_LOWER_A && c <= CHAR_LOWER_Z || c >= CHAR_UPPER_A && c <= CHAR_UPPER_Z) {\n        return true;\n    }\n\n    if (c === 0x200C || c === 0x200D) {\n        return true;\n    }\n    \n    const ct = String.fromCharCode(c);\n    return ID_Start.test(ct);\n}\n\n/**\n * Tests that a given character is a valid part of a JSON5 identifier.\n * @param {number} c The character to check.\n * @returns {boolean} `true` if the character is a valid part of an identifier.\n */\nfunction isJSON5IdentifierPart(c) {\n\n    // fast path for simple cases\n    if (isJSON5IdentifierStart(c) || isDigit(c)) {\n        return true;\n    }\n\n    const ct = String.fromCharCode(c);\n    return ID_Continue.test(ct);\n}\n\n\n// #endregion\n\nclass Tokenizer {\n\n    /**\n     * Options for the tokenizer.\n     * @type {TokenizeOptions}\n     */\n    #options;\n\n    /**\n     * The source text to tokenize.\n     * @type {string}\n     */\n    #text;\n\n    /**\n     * The reader for the source text.\n     * @type {CharCodeReader}\n     */\n    #reader;\n\n    /**\n     * Indicates if the tokenizer is in JSON5 mode.\n     * @type {boolean}\n     */\n    #json5;\n\n    /**\n     * Indicates if comments are allowed.\n     * @type {boolean}\n     */\n    #allowComments;\n\n    /**\n     * Indicates if ranges should be included in the tokens.\n     * @type {boolean}\n     */\n    #ranges;\n\n    /**\n     * The last token type read.\n     * @type {Token}\n     */\n    #token;\n\n    /**\n     * Determines if a character is an escaped character.\n     * @type {(c:number) => boolean}\n     */\n    #isEscapedCharacter;\n\n    /**\n     * Determines if a character is a JSON5 line terminator.\n     * @type {(c:number) => boolean}\n     */\n    #isJSON5LineTerminator;\n\n\n    /**\n     * Determines if a character is a JSON5 hex escape.\n     * @type {(c:number) => boolean}\n     */\n    #isJSON5HexEscape;\n\n    /**\n     * Determines if a character is whitespace.\n     * @type {(c:number) => boolean}\n     */\n    #isWhitespace;\n\n    /**\n     * Creates a new instance of the tokenizer.\n     * @param {string} text The source text\n     * @param {TokenizeOptions} [options] Options for the tokenizer.\n     */ \n    constructor(text, options) {\n        this.#text = text;\n        this.#options = {\n            ...DEFAULT_OPTIONS$1,\n            ...options\n        };\n\n        this.#reader = new CharCodeReader(text);\n        this.#json5 = this.#options.mode === \"json5\";\n        this.#allowComments = this.#options.mode !== \"json\";\n        this.#ranges = this.#options.ranges;\n\n        // TODO: Clean this up\n        this.#isEscapedCharacter = this.#json5 ? json5EscapeToChar.has.bind(json5EscapeToChar) : escapeToChar.has.bind(escapeToChar);\n        this.#isJSON5LineTerminator = this.#json5 ? json5LineTerminators.has.bind(json5LineTerminators) : () => false;\n        this.#isJSON5HexEscape = this.#json5 ? c => c === CHAR_LOWER_X : () => false;\n        this.#isWhitespace = this.#json5 ? json5Whitespace.has.bind(json5Whitespace) : whitespace.has.bind(whitespace);\n    }\n\n    // #region Errors\n\n    /**\n     * Convenience function for throwing unexpected character errors.\n     * @param {number} c The unexpected character.\n     * @param {Location} [loc] The location of the unexpected character.\n     * @returns {never}\n     * @throws {UnexpectedChar} always.\n     */\n    #unexpected(c, loc = this.#reader.locate()) {\n        throw new UnexpectedChar(c, loc);\n    }\n\n    /**\n     * Convenience function for throwing unexpected identifier errors.\n     * @param {string} identifier The unexpected identifier.\n     * @param {Location} [loc] The location of the unexpected identifier.\n     * @returns {never}\n     * @throws {UnexpectedIdentifier} always.\n     */\n    #unexpectedIdentifier(identifier, loc = this.#reader.locate()) {\n        throw new UnexpectedIdentifier(identifier, loc);\n    }\n\n    /**\n    * Convenience function for throwing unexpected EOF errors.\n    * @returns {never}\n    * @throws {UnexpectedEOF} always.\n    */\n    #unexpectedEOF() {\n        throw new UnexpectedEOF(this.#reader.locate());\n    }\n\n    // #endregion\n\n    // #region Helpers\n\n    /**\n     * Creates a new token.\n     * @param {TokenType} tokenType The type of token to create.\n     * @param {number} length The length of the token.\n     * @param {Location} startLoc The start location for the token.\n     * @param {Location} [endLoc] The end location for the token.\n     * @returns {Token} The token.\n     */\n    #createToken(tokenType, length, startLoc, endLoc) {\n\n        const endOffset = startLoc.offset + length;\n\n        let range = this.#options.ranges ? {\n            range: /** @type {Range} */ ([startLoc.offset, endOffset])\n        } : undefined;\n\n        return {\n            type: tokenType,\n            loc: {\n                start: startLoc,\n                end: endLoc || {\n                    line: startLoc.line,\n                    column: startLoc.column + length,\n                    offset: endOffset\n                }\n            },\n            ...range\n        };        \n    }\n\n    /**\n     * Reads in a specific number of hex digits.\n     * @param {number} count The number of hex digits to read.\n     * @returns {string} The hex digits read.\n     */\n    #readHexDigits(count) {\n        let value = \"\";\n        let c;\n\n        for (let i = 0; i < count; i++) {\n            c = this.#reader.peek();\n            if (isHexDigit(c)) {\n                this.#reader.next();\n                value += String.fromCharCode(c);\n                continue;\n            }\n\n            this.#unexpected(c);\n        }\n\n        return value;\n    }\n\n    /**\n     * Reads in a JSON5 identifier. Also used for JSON but we validate\n     * the identifier later.\n     * @param {number} c The first character of the identifier.\n     * @returns {string} The identifier read.\n     * @throws {UnexpectedChar} when the identifier cannot be read.\n     */\n    #readIdentifier(c) {\n        let value = \"\";\n\n        do {\n\n            value += String.fromCharCode(c);\n\n            if (c === CHAR_BACKSLASH) {\n\n                c = this.#reader.next();\n\n                if (c !== CHAR_LOWER_U) {\n                    this.#unexpected(c);\n                }\n\n                value += String.fromCharCode(c);\n\n                const hexDigits = this.#readHexDigits(4);\n\n                // check for a valid character code\n                const charCode = parseInt(hexDigits, 16);\n\n                if (value.length === 2 && !isJSON5IdentifierStart(charCode)) {\n                    const loc = this.#reader.locate();\n                    this.#unexpected(CHAR_BACKSLASH, { line: loc.line, column: loc.column - 5, offset: loc.offset - 5 });\n                } else if (!isJSON5IdentifierPart(charCode)) {\n                    const loc = this.#reader.locate();\n                    this.#unexpected(charCode, { line: loc.line, column: loc.column - 5, offset: loc.offset - 5 });\n                }\n\n                value += hexDigits;\n            }\n\n            c = this.#reader.peek();\n\n            if (!isJSON5IdentifierPart(c)) {\n                break;\n            }\n\n            this.#reader.next();\n\n        } while (true);  // eslint-disable-line no-constant-condition\n\n        return value;\n    }\n\n    /**\n     * Reads in a string. Works for both JSON and JSON5.\n     * @param {number} c The first character of the string (either \" or ').\n     * @returns {number} The length of the string.\n     * @throws {UnexpectedChar} when the string cannot be read.\n     * @throws {UnexpectedEOF} when EOF is reached before the string is finalized.\n     */\n    #readString(c) {\n        \n        const delimiter = c;\n        let length = 1;\n        c = this.#reader.peek();\n\n        while (c !== -1 && c !== delimiter) {\n\n            this.#reader.next();\n            length++;\n\n            // escapes\n            if (c === CHAR_BACKSLASH) {\n                c = this.#reader.peek();\n\n                if (this.#isEscapedCharacter(c) || this.#isJSON5LineTerminator(c)) {\n                    this.#reader.next();\n                    length++;\n                } else if (c === CHAR_LOWER_U) {\n                    this.#reader.next();\n                    length++;\n\n                    const result = this.#readHexDigits(4);\n                    length += result.length;\n                } else if (this.#isJSON5HexEscape(c)) {\n                    this.#reader.next();\n                    length++;\n\n                    // hex escapes: \\xHH\n                    const result = this.#readHexDigits(2);\n                    length += result.length;\n                } else if (this.#json5) {  // JSON doesn't allow anything else\n                    this.#reader.next();\n                    length++;\n                } else {\n                    this.#unexpected(c);\n                }\n            }\n\n            c = this.#reader.peek();\n        }\n\n        if (c === -1) {\n            this.#reader.next();\n            this.#unexpectedEOF();\n        }\n\n        // c is the delimiter\n        this.#reader.next();\n        length++;\n\n        return length;\n    \n    \n    }\n\n    /**\n     * Reads a number. Works for both JSON and JSON5.\n     * @param {number} c The first character of the number.\n     * @returns {number} The length of the number.\n     * @throws {UnexpectedChar} when the number cannot be read.\n     * @throws {UnexpectedEOF} when EOF is reached before the number is finalized.\n     */\n    #readNumber(c) {\n        \n        // we've already read the first character\n        let length = 1;\n\n        // JSON number may start with a minus but not a plus\n        // JSON5 allows a plus.\n        if (c === CHAR_MINUS || this.#json5 && c === CHAR_PLUS) {\n            \n            c = this.#reader.peek();\n            \n            /*\n            * JSON5 allows Infinity or NaN preceded by a sign.\n            * This blocks handles +Infinity, -Infinity, +NaN, and -NaN.\n            * Standalone Infinity and NaN are handled in `readJSON5Identifier()`\n            */\n            if (this.#json5) {\n\n                if (c === CHAR_UPPER_I || c === CHAR_UPPER_N) {\n                    this.#reader.next();\n                    const identifier = this.#readIdentifier(c);\n\n                    if (identifier !== INFINITY && identifier !== NAN) {\n                        this.#unexpected(c);\n                    }\n\n                    return length + identifier.length;\n                }\n            }\n\n            // Next digit cannot be zero\n            if (!isDigit(c)) {\n                this.#unexpected(c);\n            }\n\n            // if we made it here, we need to continue on, so register the character\n            this.#reader.next();\n            length++;\n        }\n\n        /*\n        * In JSON, a zero must be followed by a decimal point or nothing.\n        * In JSON5, a zero can additionally be followed by an `x` indicating\n        * that it's a hexadecimal number.\n        */\n        if (c === CHAR_0) {\n\n            // c = this.#reader.next();\n            // length++;\n            c = this.#reader.peek();\n\n            // check for a hex number\n            if (this.#json5 && (c === CHAR_LOWER_X || c === CHAR_UPPER_X)) {\n\n                this.#reader.next();\n                length++;\n\n                c = this.#reader.peek();\n\n                if (!isHexDigit(c)) {\n                    this.#reader.next();\n                    this.#unexpected(c);\n                }\n\n                do {\n                    this.#reader.next();\n                    length++;\n                    c = this.#reader.peek();\n                } while (isHexDigit(c));\n\n            } else if (isDigit(c)) {\n                this.#unexpected(c);\n            }\n\n        } else {\n\n            // JSON5 allows leading decimal points\n            if (!this.#json5 || c !== CHAR_DOT) {\n                if (!isPositiveDigit(c)) {\n                    this.#unexpected(c);\n                }\n\n                c = this.#reader.peek();\n\n                while (isDigit(c)) {\n                    this.#reader.next();\n                    length++;\n                    c = this.#reader.peek();\n                }\n            }\n        }\n\n        /*\n        * In JSON, a decimal point must be followed by at least one digit.\n        * In JSON5, a decimal point need not be followed by any digits.\n        */\n        if (c === CHAR_DOT) {\n                                \n            let digitCount = -1;\n            this.#reader.next();\n            length++;\n            digitCount++;\n\n            c = this.#reader.peek();\n\n            while (isDigit(c)) {\n                this.#reader.next();\n                length++;\n                digitCount++;\n                c = this.#reader.peek();\n            }\n\n            if (!this.#json5 && digitCount === 0) {\n                this.#reader.next();\n                if (c) {\n                    this.#unexpected(c);\n                } else {\n                    this.#unexpectedEOF();\n                }\n            }\n        }\n\n        // Exponent is always last\n        if (c === CHAR_LOWER_E || c === CHAR_UPPER_E) {\n\n            this.#reader.next();\n            length++;\n            c = this.#reader.peek();\n\n            if (c === CHAR_PLUS || c === CHAR_MINUS) {\n                this.#reader.next();\n                length++;\n                c = this.#reader.peek();\n            }\n\n            /*\n            * Must always have a digit in this position to avoid:\n            * 5e\n            * 12E+\n            * 42e-\n            */\n            if (c === -1) {\n                this.#reader.next();\n                this.#unexpectedEOF();\n            }\n\n            if (!isDigit(c)) {\n                this.#reader.next();\n                this.#unexpected(c);\n            }\n\n            while (isDigit(c)) {\n                this.#reader.next();\n                length++;\n                c = this.#reader.peek();\n            }\n        }\n\n        return length;\n    }\n\n    /**\n     * Reads a comment. Works for both JSON and JSON5.\n     * @param {number} c The first character of the comment.\n     * @returns {{length: number, multiline: boolean}} The length of the comment, and whether the comment is multi-line.\n     * @throws {UnexpectedChar} when the comment cannot be read.\n     * @throws {UnexpectedEOF} when EOF is reached before the comment is finalized.\n     */ \n    #readComment(c) {\n        \n        let length = 1;\n\n        // next character determines single- or multi-line\n        c = this.#reader.peek();\n\n        // single-line comments\n        if (c === CHAR_SLASH) {\n            \n            do {\n                this.#reader.next();\n                length += 1;\n                c = this.#reader.peek();\n            } while (c > -1 && c !== CHAR_RETURN && c !== CHAR_NEWLINE);\n\n            return { length, multiline: false };\n        }\n\n        // multi-line comments\n        if (c === CHAR_STAR) {\n\n            this.#reader.next();\n            length += 1;\n\n            while (c > -1) {\n                c = this.#reader.peek();\n\n                // check for end of comment\n                if (c === CHAR_STAR) {\n                    this.#reader.next();\n                    length += 1;\n                    c = this.#reader.peek();\n                    \n                    //end of comment\n                    if (c === CHAR_SLASH) {\n                        this.#reader.next();\n                        length += 1;\n\n                        return { length, multiline: true };\n                    }\n                } else {\n                    this.#reader.next();\n                    length += 1;\n                }\n            }\n\n            this.#reader.next();\n            this.#unexpectedEOF();\n            \n        }\n\n        // if we've made it here, there's an invalid character\n        this.#reader.next();\n        this.#unexpected(c);        \n    }\n    // #endregion\n\n    /**\n     * Returns the next token in the source text.\n     * @returns {number} The code for the next token.\n     */\n    next() {\n\n        let c = this.#reader.next();\n\n        while (this.#isWhitespace(c)) {\n            c = this.#reader.next();\n        }\n\n        if (c === -1) {\n            return tt.EOF;\n        }\n\n        const start = this.#reader.locate();\n        const ct = String.fromCharCode(c);\n\n        // check for JSON5 syntax only\n        if (this.#json5) {\n                \n            if (knownJSON5TokenTypes.has(ct)) {\n                this.#token = this.#createToken(knownJSON5TokenTypes.get(ct), 1, start);\n            } else if (isJSON5IdentifierStart(c)) {\n                const value = this.#readIdentifier(c);\n\n                if (knownJSON5TokenTypes.has(value)) {\n                    this.#token = this.#createToken(knownJSON5TokenTypes.get(value), value.length, start);\n                } else {\n                    this.#token = this.#createToken(\"Identifier\", value.length, start);\n                }\n            } else if (isJSON5NumberStart(c)) {\n                const result = this.#readNumber(c);\n                this.#token = this.#createToken(\"Number\", result, start);\n            } else if (isStringStart(c, this.#json5)) {\n                const result = this.#readString(c);\n                const lastCharLoc = this.#reader.locate();\n                this.#token = this.#createToken(\"String\", result, start, {\n                    line: lastCharLoc.line,\n                    column: lastCharLoc.column + 1,\n                    offset: lastCharLoc.offset + 1\n                });\n            } else if (c === CHAR_SLASH && this.#allowComments) {\n                const result = this.#readComment(c);\n                const lastCharLoc = this.#reader.locate();\n                this.#token = this.#createToken(!result.multiline ? \"LineComment\" : \"BlockComment\", result.length, start, {\n                    line: lastCharLoc.line,\n                    column: lastCharLoc.column + 1,\n                    offset: lastCharLoc.offset + 1\n                });\n            } else {\n                this.#unexpected(c);\n            }\n\n        } else {\n\n            // check for JSON/JSONC syntax only\n            if (knownTokenTypes.has(ct)) {\n                this.#token = this.#createToken(knownTokenTypes.get(ct), 1, start);\n            } else if (isKeywordStart(c)) {\n                const value = this.#readIdentifier(c);\n\n                if (!jsonKeywords.has(value)) {\n                    this.#unexpectedIdentifier(value, start);\n                }\n\n                this.#token = this.#createToken(knownTokenTypes.get(value), value.length, start);\n            } else if (isNumberStart(c)) {\n                const result = this.#readNumber(c);\n                this.#token = this.#createToken(\"Number\", result, start);\n            } else if (isStringStart(c, this.#json5)) {\n                const result = this.#readString(c);\n                this.#token = this.#createToken(\"String\", result, start);\n            } else if (c === CHAR_SLASH && this.#allowComments) {\n                const result = this.#readComment(c);\n                const lastCharLoc = this.#reader.locate();\n                this.#token = this.#createToken(!result.multiline ? \"LineComment\" : \"BlockComment\", result.length, start, {\n                    line: lastCharLoc.line,\n                    column: lastCharLoc.column + 1,\n                    offset: lastCharLoc.offset + 1\n                });\n            } else {\n                this.#unexpected(c);\n            }\n        }\n        return tt[this.#token.type];\n    }\n\n    /**\n     * Returns the current token in the source text.\n     * @returns {Token} The current token.\n     */\n    get token() {\n        return this.#token;\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Creates an iterator over the tokens representing the source text.\n * @param {string} text The source text to tokenize.\n * @param {TokenizeOptions} [options] Options for doing the tokenization.\n * @returns {Array<Token>} An iterator over the tokens. \n */\nfunction tokenize(text, options) {\n\n    const tokenizer = new Tokenizer(text, options);\n    const tokens = [];\n\n    while (tokenizer.next() !== tt.EOF) {\n        tokens.push(tokenizer.token);\n    }\n\n    return tokens;\n\n}\n\n/**\n * @fileoverview  JSON AST types\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typedefs.js\").NodeParts} NodeParts */\n/** @typedef {import(\"./typedefs.js\").DocumentNode} DocumentNode */\n/** @typedef {import(\"./typedefs.js\").StringNode} StringNode */\n/** @typedef {import(\"./typedefs.js\").NumberNode} NumberNode */\n/** @typedef {import(\"./typedefs.js\").BooleanNode} BooleanNode */\n/** @typedef {import(\"./typedefs.js\").MemberNode} MemberNode */\n/** @typedef {import(\"./typedefs.js\").ObjectNode} ObjectNode */\n/** @typedef {import(\"./typedefs.js\").ElementNode} ElementNode */\n/** @typedef {import(\"./typedefs.js\").ArrayNode} ArrayNode */\n/** @typedef {import(\"./typedefs.js\").NullNode} NullNode */\n/** @typedef {import(\"./typedefs.js\").ValueNode} ValueNode */\n/** @typedef {import(\"./typedefs.js\").IdentifierNode} IdentifierNode */\n/** @typedef {import(\"./typedefs.js\").NaNNode} NaNNode */\n/** @typedef {import(\"./typedefs.js\").InfinityNode} InfinityNode */\n/** @typedef {import(\"./typedefs.js\").Sign} Sign */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nconst types = {\n\n    /**\n     * Creates a document node.\n     * @param {ValueNode} body The body of the document.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {DocumentNode} The document node.\n     */\n    document(body, parts = {}) {\n        return {\n            type: \"Document\",\n            body,\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates a string node.\n     * @param {string} value The value for the string.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {StringNode} The string node.\n     */\n    string(value, parts = {}) {\n        return {\n            type: \"String\",\n            value,\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates a number node.\n     * @param {number} value The value for the number.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {NumberNode} The number node.\n     */\n    number(value, parts = {}) {\n        return {\n            type: \"Number\",\n            value,\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates a boolean node.\n     * @param {boolean} value The value for the boolean.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {BooleanNode} The boolean node.\n     */\n    boolean(value, parts = {}) {\n        return {\n            type: \"Boolean\",\n            value,\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates a null node.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {NullNode} The null node.\n     */\n    null(parts = {}) {\n        return {\n            type: \"Null\",\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates an array node.\n     * @param {Array<ElementNode>} elements The elements to add.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {ArrayNode} The array node.\n     */\n    array(elements, parts = {}) {\n        return {\n            type: \"Array\",\n            elements,\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates an element node.\n     * @param {ValueNode} value The value for the element.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {ElementNode} The element node.\n     */\n    element(value, parts = {}) {\n        return {\n            type: \"Element\",\n            value,\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates an object node.\n     * @param {Array<MemberNode>} members The members to add.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {ObjectNode} The object node.\n     */\n    object(members, parts = {}) {\n        return {\n            type: \"Object\",\n            members,\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates a member node.\n     * @param {StringNode|IdentifierNode} name The name for the member.\n     * @param {ValueNode} value The value for the member.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {MemberNode} The member node.\n     */\n    member(name, value, parts = {}) {\n        return {\n            type: \"Member\",\n            name,\n            value,\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates an identifier node.\n     * @param {string} name The name for the identifier.\n     * @param {NodeParts} parts Additional properties for the node.\n     * @returns {IdentifierNode} The identifier node.\n     */\n    identifier(name, parts = {}) {\n        return {\n            type: \"Identifier\",\n            name,\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates a NaN node.\n     * @param {Sign} sign The sign for the Infinity.\n     * @param {NodeParts} parts Additional properties for the node.\n     * @returns {NaNNode} The NaN node.\n     */ \n    nan(sign = \"\", parts = {}) {\n        return {\n            type: \"NaN\",\n            sign,\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates an Infinity node.\n     * @param {Sign} sign The sign for the Infinity.\n     * @param {NodeParts} parts Additional properties for the node.\n     * @returns {InfinityNode} The Infinity node.\n     */\n    infinity(sign = \"\", parts = {}) {\n        return {\n            type: \"Infinity\",\n            sign,\n            loc: parts.loc,\n            ...parts\n        };\n    },\n\n};\n\n/**\n * @fileoverview JSON parser\n * @author Nicholas C. Zakas\n */\n\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typedefs.js\").Node} Node */\n/** @typedef {import(\"./typedefs.js\").Mode} Mode */\n/** @typedef {import(\"./typedefs.js\").ParseOptions} ParseOptions */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/** @type {ParseOptions} */\nconst DEFAULT_OPTIONS = {\n    mode: \"json\",\n    ranges: false,\n    tokens: false,\n    allowTrailingCommas: false\n};\n\nconst UNICODE_SEQUENCE = /\\\\u[\\da-fA-F]{4}/gu;\n\n/**\n * Normalizes a JSON5 identifier by converting Unicode escape sequences into\n * their corresponding characters.\n * @param {string} identifier The identifier to normalize.\n * @returns {string} The normalized identifier.\n */\nfunction normalizeIdentifier(identifier) {\n    return identifier.replace(UNICODE_SEQUENCE, unicodeEscape => {\n        return String.fromCharCode(parseInt(unicodeEscape.slice(2), 16));\n    });\n}\n\n/**\n * Calculates the location at the end of the given text.\n * @param {string} text The text to calculate the end location for.\n * @returns {Location} The location at the end of the text.\n */\nfunction getEndLocation(text) {\n    let line = 1;\n    let column = 1;\n    \n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        if (char === \"\\n\") {\n            line++;\n            column = 1;\n        } else if (char === \"\\r\") {\n            // Handle \\r\\n as a single line ending\n            if (text[i + 1] === \"\\n\") {\n                i++; // Skip the \\n\n            }\n            line++;\n            column = 1;\n        } else {\n            column++;\n        }\n    }\n    \n    return {\n        line,\n        column,\n        offset: text.length\n    };\n}\n\n/**\n * Converts a JSON-encoded string into a JavaScript string, interpreting each\n * escape sequence.\n * @param {string} value The text for the token.\n * @param {Token} token The string token to convert into a JavaScript string.\n * @param {boolean} json5 `true` if parsing JSON5, `false` otherwise.\n * @returns {string} A JavaScript string.\n */\nfunction getStringValue(value, token, json5 = false) {\n    \n    let result = \"\";\n    let escapeIndex = value.indexOf(\"\\\\\");\n    let lastIndex = 0;\n\n    // While there are escapes, interpret them to build up the result\n    while (escapeIndex >= 0) {\n\n        // append the text that happened before the escape\n        result += value.slice(lastIndex, escapeIndex);\n\n        // get the character immediately after the \\\n        const escapeChar = value.charAt(escapeIndex + 1);\n        const escapeCharCode = escapeChar.charCodeAt(0);\n        \n        // check for the non-Unicode escape sequences first\n        if (json5 && json5EscapeToChar.has(escapeCharCode)) {\n            result += json5EscapeToChar.get(escapeCharCode);\n            lastIndex = escapeIndex + 2;\n        } else if (escapeToChar.has(escapeCharCode)) {\n            result += escapeToChar.get(escapeCharCode);\n            lastIndex = escapeIndex + 2;\n        } else if (escapeChar === \"u\") {\n            const hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);\n            if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {\n                throw new ErrorWithLocation(\n                    `Invalid unicode escape \\\\u${ hexCode}.`,\n                    {\n                        line: token.loc.start.line,\n                        column: token.loc.start.column + escapeIndex,\n                        offset: token.loc.start.offset + escapeIndex\n                    }\n                );\n            }\n\n            result += String.fromCharCode(parseInt(hexCode, 16));\n            lastIndex = escapeIndex + 6;\n        } else if (json5 && escapeChar === \"x\") {\n            const hexCode = value.slice(escapeIndex + 2, escapeIndex + 4);\n            if (hexCode.length < 2 || /[^0-9a-f]/i.test(hexCode)) {\n                throw new ErrorWithLocation(\n                    `Invalid hex escape \\\\x${ hexCode}.`,\n                    {\n                        line: token.loc.start.line,\n                        column: token.loc.start.column + escapeIndex,\n                        offset: token.loc.start.offset + escapeIndex\n                    }\n                );\n            }\n\n            result += String.fromCharCode(parseInt(hexCode, 16));\n            lastIndex = escapeIndex + 4;\n        } else if (json5 && json5LineTerminators.has(escapeCharCode)) {\n            lastIndex = escapeIndex + 2;\n\n            // we also need to skip \\n after a \\r\n            if (escapeChar === \"\\r\" && value.charAt(lastIndex) === \"\\n\") {\n                lastIndex++;\n            }\n            \n        } else {\n            // all characters can be escaped in JSON5\n            if (json5) {\n                result += escapeChar;\n                lastIndex = escapeIndex + 2;\n            } else {\n                throw new ErrorWithLocation(\n                    `Invalid escape \\\\${ escapeChar }.`,\n                    {\n                        line: token.loc.start.line,\n                        column: token.loc.start.column + escapeIndex,\n                        offset: token.loc.start.offset + escapeIndex\n                    }\n                );\n            }\n        }\n\n        // find the next escape sequence\n        escapeIndex = value.indexOf(\"\\\\\", lastIndex);\n    }\n\n    // get the last segment of the string value\n    result += value.slice(lastIndex);\n\n    return result;\n}\n\n/**\n * Gets the JavaScript value represented by a JSON token.\n * @param {string} value The text value of the token.\n * @param {Token} token The JSON token to get a value for.\n * @param {boolean} json5 `true` if parsing JSON5, `false` otherwise.\n * @returns {string|boolean|number} A number, string, or boolean.\n * @throws {TypeError} If an unknown token type is found. \n */\nfunction getLiteralValue(value, token, json5 = false) {\n    switch (token.type) {\n        case \"Boolean\":\n            return value === \"true\";\n            \n        case \"Number\":\n            if (json5) {\n\n                /*\n                 * Numbers like -0x1 are converted to NaN by Number(), so we need\n                 * to handle them separately. Rather than checking for -0x, we can\n                 * just check if the first character is a minus sign. The same for\n                 * checking for +0x.\n                 */\n\n                if (value.charCodeAt(0) === 45) { // 45 is the char code for '-'\n                    return -Number(value.slice(1));\n                }\n\n                if (value.charCodeAt(0) === 43) { // 43 is the char code for '+'\n                    return Number(value.slice(1));\n                }\n            }\n            return Number(value);\n\n        case \"String\":\n            return getStringValue(value.slice(1, -1), token, json5);\n\n        default:\n            throw new TypeError(`Unknown token type \"${token.type}.`);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main Function\n//-----------------------------------------------------------------------------\n\n/**\n * \n * @param {string} text The text to parse.\n * @param {ParseOptions} [options] The options object.\n * @returns {DocumentNode} The AST representing the parsed JSON.\n * @throws {Error} When there is a parsing error. \n */\nfunction parse(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS,\n        ...options\n    });\n\n    const tokens = [];\n    const tokenizer = new Tokenizer(text, {\n        mode: options.mode,\n        ranges: options.ranges\n    });\n\n    const json5 = options.mode === \"json5\";\n    const allowTrailingCommas = options.allowTrailingCommas || json5;\n\n    /**\n     * Returns the next token knowing there are no comments.\n     * @returns {number} The next token type or 0 if no next token.\n     */\n    function nextNoComments() {\n        const nextType = tokenizer.next();\n\n        if (nextType && options.tokens) {\n            tokens.push(tokenizer.token);\n        }\n        return nextType;\n    }\n    \n    /**\n     * Returns the next token knowing there are comments to skip.\n     * @returns {number} The next token type or 0 if no next token.\n     */\n    function nextSkipComments() {\n        const nextType = tokenizer.next();\n        if (nextType && options.tokens) {\n            tokens.push(tokenizer.token);\n        }\n\n        if (nextType >= tt.LineComment) {\n            return nextSkipComments();\n        }\n\n        return nextType;\n\n    }\n\n    // determine correct way to evaluate tokens based on presence of comments\n    const next = options.mode === \"json\" ? nextNoComments : nextSkipComments;\n\n    /**\n     * Asserts a token has the given type.\n     * @param {number} token The token to check.\n     * @param {number} type The token type.\n     * @throws {UnexpectedToken} If the token type isn't expected.\n     * @returns {void}\n     */\n    function assertTokenType(token, type) {\n        if (token !== type) {\n            throw new UnexpectedToken(tokenizer.token);\n        }\n    }\n\n    /**\n     * Asserts a token has one of the given types.\n     * @param {number} token The token to check.\n     * @param {number[]} types The token types.\n     * @returns {void}\n     * @throws {UnexpectedToken} If the token type isn't expected.\n     */ \n    function assertTokenTypes(token, types) {\n        if (!types.includes(token)) {\n            throw new UnexpectedToken(tokenizer.token);\n        }\n    }\n\n    /**\n     * Creates a range only if ranges are specified.\n     * @param {Location} start The start offset for the range.\n     * @param {Location} end The end offset for the range.\n     * @returns {{range:[number,number]}|undefined} An object with a \n     */\n    function createRange(start, end) {\n        // @ts-ignore tsc incorrect - options might be undefined\n        return options.ranges ? {\n            range: [start.offset, end.offset]\n        } : undefined;\n    }\n\n    /**\n     * Creates a node for a string, boolean, or number.\n     * @param {number} tokenType The token representing the literal. \n     * @returns {StringNode|NumberNode|BooleanNode} The node representing\n     *      the value.\n     */\n    function createLiteralNode(tokenType) {\n        const token = tokenizer.token;\n        const range = createRange(token.loc.start, token.loc.end);\n        const value = getLiteralValue(\n            text.slice(token.loc.start.offset, token.loc.end.offset),\n            token,\n            json5\n        );\n        const loc = {\n            start: {\n                ...token.loc.start\n            },\n            end: {\n                ...token.loc.end\n            }\n        };\n        const parts = { loc, ...range };\n\n        switch (tokenType) {\n            case tt.String:\n                return types.string(/** @type {string} */ (value), parts);\n\n            case tt.Number:\n                return types.number(/** @type {number} */ (value), parts);\n                \n            case tt.Boolean:\n                return types.boolean(/** @type {boolean} */ (value), parts);\n\n            default:\n                throw new TypeError(`Unknown token type ${token.type}.`);\n        }\n    }\n\n    /**\n     * Creates a node for a JSON5 identifier.\n     * @param {Token} token The token representing the identifer. \n     * @returns {NaNNode|InfinityNode|IdentifierNode} The node representing\n     *      the value.\n     */\n    function createJSON5IdentifierNode(token) {\n        const range = createRange(token.loc.start, token.loc.end);\n        const identifier = text.slice(token.loc.start.offset, token.loc.end.offset);\n        const loc = {\n            start: {\n                ...token.loc.start\n            },\n            end: {\n                ...token.loc.end\n            }\n        };\n        const parts = { loc, ...range };\n\n        // Check for NaN or Infinity\n        if (token.type !== \"Identifier\") {\n\n            let sign = \"\";\n\n            // check if the first character in the token is a plus or minus\n            if (identifier[0] === \"+\" || identifier[0] === \"-\") {\n                sign = identifier[0];\n            }\n\n            // check if the token is NaN or Infinity\n            return types[identifier.includes(\"NaN\") ? \"nan\" : \"infinity\"](/** @type {Sign} */ (sign), parts);\n        }\n        return types.identifier(normalizeIdentifier(identifier), parts);\n    }\n\n    /**\n     * Creates a node for a null.\n     * @param {Token} token The token representing null. \n     * @returns {NullNode} The node representing null.\n     */\n    function createNullNode(token) {\n        const range = createRange(token.loc.start, token.loc.end);\n\n        return types.null({\n            loc: {\n                start: {\n                    ...token.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n    }\n\n\n    /**\n     * Parses a property in an object.\n     * @param {number} tokenType The token representing the property.\n     * @returns {MemberNode} The node representing the property.\n     * @throws {UnexpectedToken} When an unexpected token is found.\n     * @throws {UnexpectedEOF} When the end of the file is reached.\n     */\n    function parseProperty(tokenType) {\n\n        if (json5) {\n            assertTokenTypes(tokenType, [tt.String, tt.Identifier, tt.Number]);\n        } else {\n            assertTokenType(tokenType, tt.String);\n        }\n\n        const token = tokenizer.token;\n\n        // check for -NaN, +NaN, -Infinity, +Infinity, and any number\n        if (json5 && tokenType === tt.Number && /[+\\-0-9]/.test(text[token.loc.start.offset])) {\n            throw new UnexpectedToken(token);\n        }\n\n        // TODO: Clean this up a bit\n        let key = tokenType === tt.String\n            ? /** @type {StringNode} */ (createLiteralNode(tokenType))\n            : /** @type {IdentifierNode|NaNNode|InfinityNode} */ (createJSON5IdentifierNode(token));\n\n        // in JSON5, need to check for NaN and Infinity and create identifier nodes\n        if (json5 && (key.type === \"NaN\" || key.type === \"Infinity\")) {\n\n            // NaN and Infinity cannot be signed and be a property key\n            if (key.sign !== \"\") {\n                throw new UnexpectedToken(tokenizer.token);\n            }\n\n            key = types.identifier(key.type, { loc: key.loc, ...createRange(key.loc.start, key.loc.end) });\n        }\n\n        tokenType = next();\n        assertTokenType(tokenType, tt.Colon);\n        const value = parseValue();\n        const range = createRange(key.loc.start, value.loc.end);\n\n        return types.member(\n            /** @type {StringNode|IdentifierNode} */ (key),\n            /** @type {ValueNode} */ (value),\n            {\n                loc: {\n                    start: {\n                        ...key.loc.start\n                    },\n                    end: {\n                        ...value.loc.end\n                    }\n                },\n                ...range\n            }\n        );\n    }\n\n    /**\n     * Parses an object literal.\n     * @param {number} firstTokenType The first token type in the object.\n     * @returns {ObjectNode} The object node.\n     * @throws {UnexpectedEOF} When the end of the file is reached.\n     * @throws {UnexpectedToken} When an unexpected token is found.\n     */\n    function parseObject(firstTokenType) {\n\n        // The first token must be a { or else it's an error\n        assertTokenType(firstTokenType, tt.LBrace);\n\n        const firstToken = tokenizer.token;\n        const members = [];\n        let tokenType = next();\n\n        if (tokenType !== tt.RBrace) {\n            do {\n    \n                // add the value into the array\n                members.push(parseProperty(tokenType));\n    \n                tokenType = next();\n\n                if (!tokenType) {\n                    throw new UnexpectedEOF(members[members.length-1].loc.end);\n                }\n    \n                if (tokenType === tt.Comma) {\n                    tokenType = next();\n\n                    /*\n                      * Trailing commas.\n                      * So we need to check if the token is a comma,\n                      * and if so, then we need to check if the next\n                      * token is a RBrace. If it is, then we need to\n                      * break out of the loop.\n                      */\n                    if (allowTrailingCommas && tokenType === tt.RBrace) {\n                        break;\n                    }                      \n                } else {\n                    break;\n                }\n            } while (tokenType);\n        }\n\n        assertTokenType(tokenType, tt.RBrace);\n        const lastToken = tokenizer.token;\n        const range = createRange(firstToken.loc.start, lastToken.loc.end);\n\n        return types.object(members, {\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...lastToken.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n    /**\n     * Parses an array literal.\n     * @param {number} firstTokenType The first token in the array.\n     * @returns {ArrayNode} The array node.\n     * @throws {UnexpectedToken} When an unexpected token is found.\n     * @throws {UnexpectedEOF} When the end of the file is reached.\n     */\n    function parseArray(firstTokenType) {\n\n        // The first token must be a [ or else it's an error\n        assertTokenType(firstTokenType, tt.LBracket);\n\n        const firstToken = tokenizer.token;\n        const elements = [];\n        let tokenType = next();\n        \n        if (tokenType !== tt.RBracket) {\n\n            do {\n\n                // add the value into the array\n                const value = parseValue(tokenType);\n\n                elements.push(types.element(\n                    /** @type {ValueNode} */ (value),\n                    { loc: value.loc }\n                ));\n\n                tokenType = next();\n              \n                if (tokenType === tt.Comma) {\n                    tokenType = next();\n\n                    /*\n                      * Trailing commas.\n                      * So we need to check if the token is a comma,\n                      * and if so, then we need to check if the next\n                      * token is a RBracket. If it is, then we need to\n                      * break out of the loop.\n                      */\n                    if (allowTrailingCommas && tokenType === tt.RBracket) {\n                        break;\n                    }                    \n                } else {\n                    break;\n                }\n            } while (tokenType);\n        }\n\n        assertTokenType(tokenType, tt.RBracket);\n\n        const lastToken = tokenizer.token;\n        const range = createRange(firstToken.loc.start, lastToken.loc.end);\n\n        return types.array(elements, {\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...lastToken.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n    /**\n     * Parses a JSON value.\n     * @param {number} [tokenType] The token type to parse.\n     * @returns {ValueNode|IdentifierNode} The node representing the value.\n     */\n    function parseValue(tokenType) {\n\n        tokenType = tokenType ?? next();\n        const token = tokenizer.token;\n        \n        switch (tokenType) {\n            case tt.String:\n            case tt.Boolean:\n                return createLiteralNode(tokenType);\n\n            case tt.Number:\n                if (json5) {\n                    let tokenText = text.slice(token.loc.start.offset, token.loc.end.offset);\n                    if (tokenText[0] === \"+\" || tokenText[0] === \"-\") {\n                        tokenText = tokenText.slice(1);\n                    }\n\n                    if (tokenText === \"NaN\" || tokenText === \"Infinity\") {\n                        return createJSON5IdentifierNode(token);\n                    }\n                }\n                return createLiteralNode(tokenType);\n\n            case tt.Null:\n                return createNullNode(token);\n\n            case tt.LBrace:\n                return parseObject(tokenType);\n\n            case tt.LBracket:\n                return parseArray(tokenType);\n\n            default:\n                throw new UnexpectedToken(token);\n        }\n\n    }\n\n    \n    const docBody = parseValue();\n    \n    const unexpectedToken = next();\n    if (unexpectedToken) {\n        throw new UnexpectedToken(tokenizer.token);\n    }\n    \n    \n    const textEndLocation = getEndLocation(text);\n    const docParts = {\n        loc: {\n            start: {\n                line: 1,\n                column: 1,\n                offset: 0\n            },\n            end: {\n                ...textEndLocation\n            }\n        }\n    };\n    \n    if (options.tokens) {\n        docParts.tokens = tokens;\n    }\n\n    if (options.ranges) {\n        docParts.range = [\n            docParts.loc.start.offset,\n            docParts.loc.end.offset\n        ];\n    }\n\n    return types.document(/** @type {ValueNode} */ (docBody), docParts);\n}\n\n/**\n * @fileoverview Traversal approaches for Momoa JSON AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typedefs.js\").TraversalPhase} TraversalPhase */\n/**\n * @typedef {Object} TraversalVisitor\n * @property {(node: Node, parent?: Node) => void} [enter]\n * @property {(node: Node, parent?: Node) => void} [exit]\n */\n\n//-----------------------------------------------------------------------------\n// Data\n//-----------------------------------------------------------------------------\n\nconst childKeys = new Map([\n    [\"Document\", [\"body\"]],\n    [\"Object\", [\"members\"]],\n    [\"Member\", [\"name\", \"value\"]],\n    [\"Element\", [\"value\"]],\n    [\"Array\", [\"elements\"]],\n    [\"String\", []],\n    [\"Number\", []],\n    [\"Boolean\", []],\n    [\"Null\", []],\n    [\"NaN\", []],\n    [\"Infinity\", []],\n    [\"Identifier\", []],\n]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Determines if a given value is an object.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is an object, false if not. \n */\nfunction isObject(value) {\n    return value && (typeof value === \"object\");\n}\n\n/**\n * Determines if a given value is an AST node.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is a node, false if not. \n */\nfunction isNode(value) {\n    return isObject(value) && (typeof value.type === \"string\");\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Traverses an AST from the given node.\n * @param {Node} root The node to traverse from \n * @param {TraversalVisitor} visitor An object with an `enter` and `exit` method. \n */\nfunction traverse(root, visitor) {\n\n    /**\n     * Recursively visits a node.\n     * @param {Node} node The node to visit.\n     * @param {Node} [parent] The parent of the node to visit.\n     * @returns {void}\n     */\n    function visitNode(node, parent) {\n\n        if (typeof visitor.enter === \"function\") {\n            visitor.enter(node, parent);\n        }\n\n        for (const key of childKeys.get(node.type)) {\n            const value = node[key];\n\n            if (isObject(value)) {\n                if (Array.isArray(value)) {\n                    value.forEach(child => visitNode(child, node));\n                } else if (isNode(value)) {\n                    visitNode(value, node);\n                }\n            }\n        }\n\n        if (typeof visitor.exit === \"function\") {\n            visitor.exit(node, parent);\n        }\n    }\n\n    visitNode(root);\n}\n\n/**\n * @callback FilterPredicate\n * @param {{node: Node, parent?: Node, phase: TraversalPhase}} item\n * @param {number} index\n * @param {Array<{node: Node, parent?: Node, phase: TraversalPhase}>} array\n * @returns {boolean}\n */\n\n/**\n * Creates an iterator over the given AST.\n * @param {Node} root The root AST node to traverse. \n * @param {FilterPredicate} [filter] A filter function to determine which steps to\n *      return;\n * @returns {IterableIterator<{node: Node, parent?: Node, phase: TraversalPhase}>} An iterator over the AST.  \n */\nfunction iterator(root, filter = () => true) {\n\n    /** @type {Array<{node: Node, parent?: Node, phase: TraversalPhase}>} */\n    const traversal = [];\n\n    traverse(root, {\n        enter(node, parent) {\n            traversal.push({ node, parent, phase: \"enter\" });\n        },\n        exit(node, parent) {\n            traversal.push({ node, parent, phase: \"exit\" });\n        }\n    });\n\n    return traversal.filter(filter).values();\n}\n\n/**\n * @fileoverview Evaluator for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typedefs.js\").AnyNode} AnyNode */\n/** @typedef {import(\"./typedefs.js\").JSONValue} JSONValue */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Evaluates a Momoa AST node into a JavaScript value.\n * @param {AnyNode} node The node to interpet.\n * @returns {JSONValue} The JavaScript value for the node. \n */\nfunction evaluate(node) {\n    switch (node.type) {\n        case \"String\":\n            return node.value;\n\n        case \"Number\":\n            return node.value;\n\n        case \"Boolean\":\n            return node.value;\n\n        case \"Null\":\n            return null;\n\n        case \"NaN\":\n            return NaN;\n        \n        case \"Infinity\":\n            return node.sign === \"-\" ? -Infinity : Infinity;\n\n        case \"Identifier\":\n            return node.name;\n\n        case \"Array\": {\n            // const arrayNode = /** @type {ArrayNode} */ (node);\n            return node.elements.map(element => evaluate(element.value));\n        }\n\n        case \"Object\": {\n\n            /** @type {{[property: string]: JSONValue}} */\n            const object = {};\n\n            node.members.forEach(member => {\n                object[/** @type {string} */ (evaluate(member.name))] = evaluate(member.value);\n            });    \n\n            return object;\n        }    \n\n        case \"Document\": {\n            return evaluate(node.body);\n        }\n\n        case \"Element\":\n            throw new Error(\"Cannot evaluate array element outside of an array.\");\n\n        case \"Member\":\n            throw new Error(\"Cannot evaluate object member outside of an object.\");\n\n        default:\n            // @ts-ignore tsc doesn't know about the type property here?\n            throw new Error(`Unknown node type ${ node.type }.`);\n    }\n}\n\n/**\n * @fileoverview Printer for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Prints the string representation of a Boolean node.\n * @param {BooleanNode} node The node to print.\n * @returns {string} The boolean value.\n */\nfunction printBoolean(node) {\n    return node.value ? \"true\" : \"false\";\n}\n\n/**\n * Prints the string representation of a null node.\n * @returns {string} The string \"null\".\n */\nfunction printNull() {\n    return \"null\";\n}\n\n/**\n * Prints the string representation of a number node.\n * @param {NumberNode} node The node to print.\n * @returns {string} The number value.\n */\nfunction printNumber(node) {\n    return node.value.toString();\n}\n\n/**\n * Prints the string representation of a NaN node.\n * @returns {string} The string \"NaN\".\n */\nfunction printNaN() {\n    return \"NaN\";\n}\n\n/**\n * Prints the string representation of an Infinity node.\n * @param {InfinityNode} node The node to print.\n * @returns {string} The string \"Infinity\" or \"-Infinity\".\n */\nfunction printInfinity(node) {\n    return node.sign + \"Infinity\";\n}\n\n/**\n * Prints the string representation of a string node.\n * @param {StringNode} node The node to print.\n * @returns {string} The string value.\n */\nfunction printString(node) {\n\n    let result = \"\\\"\";\n\n    // escape all characters that need escaping\n    for (const c of node.value) {\n\n        const newChar = json5CharToEscape.get(c);\n\n        if (newChar) {\n            result += \"\\\\\" + newChar;\n            continue;\n        }\n\n        // if it's a double quote, escape it\n        if (c === \"\\\"\") {\n            result += \"\\\\\\\"\";\n            continue;\n        }\n\n        // if it's a control character, escape it\n        if (c < \" \" || c === \"\\u007F\") {\n            const hex = c.codePointAt(0).toString(16).toUpperCase();\n            result += `\\\\u${\"0000\".substring(hex.length)}${hex}`;\n            continue;\n        }\n\n        // otherwise, just add the character\n        result += c;\n\n    }\n    \n    return result + \"\\\"\";\n}\n\n/**\n * Prints the string representation of an identifier node.\n * @param {IdentifierNode} node The node to print.\n * @returns {string} The identifier name.\n */\nfunction printIdentifier(node) {\n    return node.name;\n}\n\n/**\n * Prints the string representation of an array node.\n * @param {ArrayNode} node The node to print.\n * @param {string} indent The string to use for indentation.\n * @param {number} indentLevel The current level of indentation.\n * @returns {string} The array value.\n */\nfunction printArray(node, indent, indentLevel) {\n    const newLine = indent ? \"\\n\" : \"\";\n    const indentString = indent.repeat(indentLevel);\n    const elementIndentString = indent.repeat(indentLevel + 1);\n\n    return `[${newLine}${\n        node.elements.map(element =>\n            `${elementIndentString}${printValue(element.value, indent, indentLevel + 1)}`\n        ).join(`,${newLine}`)\n    }${newLine}${indentString}]`;\n}\n\n/**\n * Prints the string representation of a member node.\n * @param {MemberNode} node The node to print.\n * @param {string} indent The string to use for indentation.\n * @param {number} indentLevel The current level of indentation.\n * @returns {string} The member value.\n */\nfunction printMember(node, indent, indentLevel) {\n    const space = indent ? \" \" : \"\";\n    return `${printValue(node.name, indent, indentLevel)}:${space}${printValue(node.value, indent, indentLevel + 1)}`;\n}\n\n/**\n * Prints the string representation of an object node.\n * @param {ObjectNode} node The node to print.\n * @param {string} indent The string to use for indentation.\n * @param {number} indentLevel The current level of indentation.\n * @returns {string} The object value.\n */\nfunction printObject(node, indent, indentLevel) {\n    const newLine = indent ? \"\\n\" : \"\";\n    const indentString = indent.repeat(indentLevel);\n    const memberIndentString = indent.repeat(indentLevel + 1);\n\n    return `{${newLine}${\n        node.members.map(member => \n            `${memberIndentString}${printMember(member, indent, indentLevel)}`\n        ).join(`,${newLine}`)\n    }${newLine}${indentString}}`;\n}\n\n/**\n * Prints the string representation of a node.\n * @param {AnyNode} node The node to print.\n * @param {string} indentString The string to use for indentation.\n * @param {number} indentLevel The current level of indentation.\n * @returns {string} The string representation of the node.\n * @throws {TypeError} If the node type is unknown.\n\n */\nfunction printValue(node, indentString, indentLevel) {\n    switch (node.type) {\n        case \"String\":\n            return printString(node);\n        case \"Number\":\n            return printNumber(node);\n        case \"Boolean\":\n            return printBoolean(node);\n        case \"Null\":\n            return printNull();\n        case \"NaN\":\n            return printNaN();\n        case \"Infinity\":\n            return printInfinity(node);\n        case \"Identifier\":\n            return printIdentifier(node);\n        case \"Array\":\n            return printArray(node, indentString, indentLevel);\n        case \"Object\":\n            return printObject(node, indentString, indentLevel);\n        case \"Document\":\n            return printValue(node.body, indentString, indentLevel);\n        default:\n            throw new TypeError(`Unknown node type: ${node.type}`);\n    }\n}\n\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Converts a Momoa AST back into a JSON string.\n * @param {AnyNode} node The node to print.\n * @param {Object} options Options for the print.\n * @param {number} [options.indent=0] The number of spaces to indent each line. If\n *      greater than 0, then newlines and indents will be added to output. \n * @returns {string} The JSON representation of the AST.\n */\nfunction print(node, { indent = 0 } = {}) {\n\n    const indentLevel = 0;\n    const indentString = \" \".repeat(indent);\n\n    return printValue(node, indentString, indentLevel);\n}\n\nexport { evaluate, iterator, parse, print, tokenize, traverse, types, childKeys as visitorKeys };\n","import {\n  type AnyNode,\n  type DocumentNode,\n  type MemberNode,\n  parse as momoaParse,\n  type ObjectNode,\n  type ParseOptions,\n  print,\n  type ValueNode,\n} from '@humanwhocodes/momoa';\nimport type yamlToMomoa from 'yaml-to-momoa';\nimport type Logger from '../logger.js';\nimport type { InputSource } from '../types.js';\n\nexport interface JSONVisitor {\n  enter?: (node: AnyNode, parent: AnyNode | undefined, path: string[]) => void;\n  exit?: (node: AnyNode, parent: AnyNode | undefined, path: string[]) => void;\n}\n\nexport const CHILD_KEYS = {\n  Document: ['body'] as const,\n  Object: ['members'] as const,\n  Member: ['name', 'value'] as const,\n  Element: ['value'] as const,\n  Array: ['elements'] as const,\n  String: [] as const,\n  Number: [] as const,\n  Boolean: [] as const,\n  Null: [] as const,\n  Identifier: [] as const,\n  NaN: [] as const,\n  Infinity: [] as const,\n};\n\n/** Determines if a given value is an AST node. */\nexport function isNode(value: unknown): boolean {\n  return !!value && typeof value === 'object' && 'type' in value && typeof value.type === 'string';\n}\n\nexport type ValueNodeWithIndex = ValueNode & { index: number };\n\n/** Get ObjectNode members as object */\nexport function getObjMembers(node: ObjectNode): Record<string | number, ValueNodeWithIndex> {\n  const members: Record<string | number, ValueNodeWithIndex> = {};\n  if (node.type !== 'Object') {\n    return members;\n  }\n  for (let i = 0; i < node.members.length; i++) {\n    const m = node.members[i]!;\n    if (m.name.type !== 'String') {\n      continue;\n    }\n    members[m.name.value] = { ...m.value, index: i };\n  }\n  return members;\n}\n\n/** Inject members to ObjectNode */\nexport function injectObjMembers(node: ObjectNode, members: MemberNode[] = []) {\n  if (node.type !== 'Object') {\n    return;\n  }\n  node.members.push(...members);\n}\n\n/** Replace an ObjectNode’s contents outright with another */\nexport function replaceObjMembers(a: ObjectNode, b: DocumentNode | ObjectNode) {\n  a.members = (b.type === 'Document' && (b.body as ObjectNode)?.members) || (b as ObjectNode).members;\n}\n\n/**\n * Variation of Momoa’s traverse(), which keeps track of global path.\n * Allows mutation of AST (along with any consequences)\n */\nexport function traverse(root: AnyNode, visitor: JSONVisitor) {\n  /**\n   * Recursively visits a node.\n   * @param {AnyNode} node The node to visit.\n   * @param {AnyNode} [parent] The parent of the node to visit.\n   * @return {void}\n   */\n  function visitNode(node: AnyNode, parent: AnyNode | undefined, path: string[] = []) {\n    const nextPath = [...path];\n    if (node.type === 'Member') {\n      const { name } = node;\n      nextPath.push('value' in name ? name.value : String(name));\n    }\n\n    visitor.enter?.(node, parent, nextPath);\n\n    const childNode = CHILD_KEYS[node.type];\n    for (const key of childNode ?? []) {\n      const value = node[key as keyof typeof node];\n      if (!value) {\n        continue;\n      }\n      if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n          visitNode(value[i] as unknown as AnyNode, node, key === 'elements' ? [...nextPath, String(i)] : nextPath);\n        }\n      } else if (isNode(value)) {\n        visitNode(value as unknown as AnyNode, node, nextPath);\n      }\n    }\n\n    visitor.exit?.(node, parent, nextPath);\n  }\n\n  visitNode(root, undefined, []);\n}\n\n/** Determine if an input is likely a JSON string */\nexport function maybeRawJSON(input: string): boolean {\n  return typeof input === 'string' && input.trim().startsWith('{');\n}\n\n/** Find Momoa node by traversing paths */\nexport function findNode<T = AnyNode>(node: AnyNode, path: string[]): T | undefined {\n  if (!path.length) {\n    return;\n  }\n\n  let nextNode: AnyNode | undefined;\n\n  switch (node.type) {\n    // for Document nodes, dive into body for “free” (not part of the path)\n    case 'Document': {\n      return findNode(node.body, path);\n    }\n    case 'Object': {\n      const [member, ...rest] = path;\n      nextNode = node.members.find((m) => m.name.type === 'String' && m.name.value === member)?.value;\n      if (nextNode && rest.length) {\n        return findNode(nextNode, path.slice(1));\n      }\n      break;\n    }\n    case 'Array': {\n      const [_index, ...rest] = path;\n      const index = Number.parseInt(_index!, 10);\n      nextNode = node.elements[index]?.value;\n      if (nextNode && rest.length) {\n        return findNode(nextNode, path.slice(1));\n      }\n      break;\n    }\n  }\n\n  return nextNode as T;\n}\n\nexport interface ToMomoaOptions {\n  filename?: URL;\n  continueOnError?: boolean;\n  logger: Logger;\n  yamlToMomoa?: typeof yamlToMomoa;\n}\n\nexport function toMomoa(\n  input: string | Record<string, any>,\n  { continueOnError, filename, logger, yamlToMomoa }: ToMomoaOptions,\n): InputSource {\n  let src = '';\n  if (typeof input === 'string') {\n    src = input;\n  }\n  let document = {} as DocumentNode;\n  if (typeof input === 'string' && !maybeRawJSON(input)) {\n    if (yamlToMomoa) {\n      try {\n        document = yamlToMomoa(input); // if string, but not JSON, attempt YAML\n      } catch (err) {\n        logger.error({ group: 'parser', label: 'json', message: String(err), filename, src: input, continueOnError });\n      }\n    } else {\n      logger.error({\n        group: 'parser',\n        label: 'yaml',\n        message: `Install \\`yaml-to-momoa\\` package to parse YAML, and pass in as option, e.g.:\n\n    import { parse } from '@terrazzo/parser';\n    import yamlToMomoa from 'yaml-to-momoa';\n\n    parse(yamlString, { yamlToMomoa });`,\n        continueOnError: false, // fail here; no point in continuing\n      });\n    }\n  } else {\n    document = parseJSON(input);\n  }\n  if (!src) {\n    src = print(document, { indent: 2 });\n  }\n  return { src, document };\n}\n\n/** Momoa, just with default options pre-set */\nexport function parseJSON(input: string | Record<string, any>, options?: ParseOptions): any {\n  return momoaParse(\n    // note: it seems silly, at first glance, to have JSON.stringify() inside an actual JSON parser. But\n    // this provides a common interface to generate a Momoa AST for JSON created in-memory, which we already\n    // know is 100% valid because it’s already deserialized.\n    typeof input === 'string' ? input : JSON.stringify(input, undefined, 2),\n    {\n      mode: 'jsonc',\n      ranges: true,\n      tokens: true,\n      ...options,\n    },\n  );\n}\n","import type { AnyNode, ArrayNode, ObjectNode } from '@humanwhocodes/momoa';\nimport {\n  type BorderTokenNormalized,\n  type GradientTokenNormalized,\n  isAlias,\n  parseAlias,\n  type ShadowTokenNormalized,\n  type StrokeStyleTokenNormalized,\n  type TokenNormalized,\n  type TokenNormalizedSet,\n  type TransitionTokenNormalized,\n  type TypographyTokenNormalized,\n} from '@terrazzo/token-tools';\nimport type Logger from '../logger.js';\nimport { getObjMembers } from './json.js';\n\nexport interface ApplyAliasOptions {\n  tokensSet: TokenNormalizedSet;\n  filename: URL;\n  src: string;\n  node: ObjectNode;\n  logger: Logger;\n}\n\nexport type PreAliased<T extends TokenNormalized> = {\n  $value: T['$value'] | string;\n  mode: Record<string, T['mode'][string] & { $value: T['$value'] | string }>;\n};\n\n/**\n * Resolve aliases and update the token nodes.\n *\n * Data structures are in an awkward in-between phase, where they have\n * placeholders for data but we still need to resolve everything. As such,\n * TypeScript will raise errors expecting the final shape.\n *\n * This is also a bit tricky because different token types alias slightly\n * differently. For example, color tokens and other “primitive” tokens behave\n * as-expected. But composite tokens like Typography, Gradient, Border, etc. can\n * either fully- or partially-alias their values. Then we add modes to the mix,\n * and we have to do the work all over again for each mode declared.\n *\n * All that to say, there are a generous amount of TypeScript overrides here rather\n * than try to codify indeterminate shapes.\n */\nexport default function applyAliases(token: TokenNormalized, options: ApplyAliasOptions): void {\n  // prepopulate default mode (if not set)\n  token.mode['.'] ??= {} as any;\n  token.mode['.'].$value = token.$value;\n  token.mode['.'].originalValue ??= token.originalValue.$value;\n  token.mode['.'].source ??= token.source;\n\n  // resolve root\n  if (typeof token.$value === 'string' && isAlias(token.$value)) {\n    const { aliasChain, resolvedToken } = resolveAlias(token.$value, { ...options, token });\n    token.aliasOf = resolvedToken.id;\n    token.aliasChain = aliasChain;\n    (token as any).$value = resolvedToken.$value;\n  }\n\n  // resolve modes\n  for (const mode of Object.keys(token.mode)) {\n    const modeValue = token.mode[mode]!.$value;\n\n    // if the entire mode value is a simple alias, resolve & continue\n    if (typeof modeValue === 'string' && isAlias(modeValue)) {\n      const expectedType = [token.$type];\n      const { aliasChain, resolvedToken } = resolveAlias(modeValue, {\n        ...options,\n        token,\n        expectedType,\n        node: token.mode[mode]!.source?.node || options.node,\n      });\n      token.mode[mode]!.aliasOf = resolvedToken.id;\n      token.mode[mode]!.aliasChain = aliasChain;\n      (token.mode[mode] as any).$value = resolvedToken.$value;\n      continue;\n    }\n\n    // object types: expand default $value into current mode\n    if (\n      typeof token.$value === 'object' &&\n      typeof token.mode[mode]!.$value === 'object' &&\n      !Array.isArray(token.$value)\n    ) {\n      for (const [k, v] of Object.entries(token.$value)) {\n        if (!(k in token.mode[mode]!.$value)) {\n          (token.mode[mode]!.$value as any)[k] = v;\n        }\n      }\n    }\n\n    // if the mode is an object or array that’s partially aliased, do work per-token type\n    const node = (getObjMembers(options.node).$value as any) || options.node;\n    switch (token.$type) {\n      case 'border': {\n        applyBorderPartialAlias(token, mode, { ...options, node });\n        break;\n      }\n      case 'gradient': {\n        applyGradientPartialAlias(token, mode, { ...options, node });\n        break;\n      }\n      case 'shadow': {\n        applyShadowPartialAlias(token, mode, { ...options, node });\n        break;\n      }\n      case 'strokeStyle': {\n        applyStrokeStylePartialAlias(token, mode, { ...options, node });\n        break;\n      }\n      case 'transition': {\n        applyTransitionPartialAlias(token, mode, { ...options, node });\n        break;\n      }\n      case 'typography': {\n        applyTypographyPartialAlias(token, mode, { ...options, node });\n        break;\n      }\n    }\n  }\n}\n\nconst LIST_FORMAT = new Intl.ListFormat('en-us', { type: 'disjunction' });\n\n/**\n * Resolve alias. Also add info on root node if it’s the root token (has .id)\n */\nfunction resolveAlias(alias: string, options: { token: TokenNormalized; expectedType?: string[] } & ApplyAliasOptions) {\n  const baseMessage = {\n    group: 'parser' as const,\n    label: 'alias',\n    node: options?.node,\n    filename: options.filename,\n    src: options.src,\n  };\n  const { logger, token, tokensSet } = options;\n  const shallowAliasID = parseAlias(alias);\n  const { token: resolvedToken, chain } = _resolveAliasInner(shallowAliasID, options);\n\n  // Apply missing $types while resolving\n  if (!tokensSet[token.id]!.$type) {\n    tokensSet[token.id]!.$type = resolvedToken!.$type;\n  }\n\n  // throw error if expectedType differed\n  const expectedType = [...(options.expectedType ?? [])];\n  if (token.$type && !expectedType?.length) {\n    expectedType.push(token.$type);\n  }\n  if (expectedType?.length && !expectedType.includes(resolvedToken!.$type)) {\n    logger.error({\n      ...baseMessage,\n      message: `Invalid alias: expected $type: ${LIST_FORMAT.format(expectedType!)}, received $type: ${resolvedToken!.$type}.`,\n      node: (options.node?.type === 'Object' && getObjMembers(options.node).$value) || baseMessage.node,\n    });\n  }\n\n  // Apply reverse aliases as we’re traversing the graph\n  if (chain?.length && resolvedToken) {\n    let needsSort = false;\n    for (const id of chain) {\n      if (id !== resolvedToken.id && !resolvedToken.aliasedBy?.includes(id)) {\n        resolvedToken.aliasedBy ??= [];\n        resolvedToken.aliasedBy!.push(id);\n        needsSort = true;\n      }\n      if (token && !resolvedToken.aliasedBy?.includes(token.id)) {\n        resolvedToken.aliasedBy ??= [];\n        resolvedToken.aliasedBy!.push(token.id);\n        needsSort = true;\n      }\n    }\n    if (needsSort) {\n      resolvedToken.aliasedBy!.sort((a, b) => a.localeCompare(b, 'en-us', { numeric: true }));\n    }\n  }\n  return { resolvedToken: resolvedToken!, aliasChain: chain };\n}\n\nfunction _resolveAliasInner(\n  alias: string,\n  {\n    scanned = [],\n    ...options\n  }: {\n    tokensSet: Record<string, TokenNormalized>;\n    logger: Logger;\n    filename?: URL;\n    src: string;\n    node: AnyNode;\n    scanned?: string[];\n  },\n): { token: TokenNormalized; chain: string[] } {\n  const { logger, filename, src, node, tokensSet } = options;\n  const baseMessage = { group: 'parser' as const, label: 'alias', filename, src, node };\n  const id = parseAlias(alias);\n  if (!tokensSet[id]) {\n    logger.error({ ...baseMessage, message: `Alias {${alias}} not found.` });\n  }\n  if (scanned.includes(id)) {\n    logger.error({ ...baseMessage, message: `Circular alias detected from ${alias}.` });\n  }\n\n  const token = tokensSet[id]!;\n  scanned.push(id);\n\n  // important: use originalValue to trace the full alias path correctly\n  // finish resolution\n  if (typeof token.originalValue.$value !== 'string' || !isAlias(token.originalValue.$value)) {\n    return { token, chain: scanned };\n  }\n\n  // continue resolving\n  return _resolveAliasInner(token.originalValue.$value as string, { ...options, scanned });\n}\n\nfunction applyBorderPartialAlias(token: BorderTokenNormalized, mode: string, options: ApplyAliasOptions): void {\n  for (const [k, v] of Object.entries(token.mode[mode]!.$value)) {\n    if (typeof v === 'string' && isAlias(v)) {\n      token.mode[mode]!.partialAliasOf ??= {};\n      const node = (getObjMembers(options.node)[k] as any) || options.node;\n      const { resolvedToken } = resolveAlias(v, {\n        ...options,\n        token,\n        expectedType: { color: ['color'], width: ['dimension'], style: ['strokeStyle'] }[k],\n        node,\n      });\n      (token.mode[mode]!.partialAliasOf as any)[k] = parseAlias(v);\n      if (mode === '.') {\n        token.partialAliasOf ??= {};\n        (token.partialAliasOf as any)[k] = parseAlias(v);\n      }\n      (token.mode[mode]!.$value as any)[k] = resolvedToken.$value;\n    }\n  }\n}\n\nfunction applyGradientPartialAlias(token: GradientTokenNormalized, mode: string, options: ApplyAliasOptions): void {\n  for (let i = 0; i < token.mode[mode]!.$value.length; i++) {\n    const step = token.mode[mode]!.$value[i]!;\n    for (const [k, v] of Object.entries(step)) {\n      if (typeof v === 'string' && isAlias(v)) {\n        token.mode[mode]!.partialAliasOf ??= [];\n        (token.mode[mode]!.partialAliasOf as any)[i] ??= {};\n        const expectedType = { color: ['color'], position: ['number'] }[k];\n        let node = ((options.node as unknown as ArrayNode | undefined)?.elements?.[i]?.value as any) || options.node;\n        if (node.type === 'Object') {\n          node = getObjMembers(node)[k] || node;\n        }\n        const { resolvedToken } = resolveAlias(v, { ...options, token, expectedType, node });\n        (token.mode[mode]!.partialAliasOf[i] as any)[k] = parseAlias(v);\n        if (mode === '.') {\n          token.partialAliasOf ??= [];\n          (token.partialAliasOf as any)[i] ??= {};\n          (token.partialAliasOf[i] as any)[k] = parseAlias(v);\n        }\n        (step as any)[k] = resolvedToken.$value;\n      }\n    }\n  }\n}\n\nfunction applyShadowPartialAlias(token: ShadowTokenNormalized, mode: string, options: ApplyAliasOptions): void {\n  // shadow-only fix: historically this token type may or may not allow an array\n  // of values, and at this stage in parsing, they all might not have been\n  // normalized yet.\n  if (!Array.isArray(token.mode[mode]!.$value)) {\n    token.mode[mode]!.$value = [token.mode[mode]!.$value];\n  }\n\n  for (let i = 0; i < token.mode[mode]!.$value.length; i++) {\n    const layer = token.mode[mode]!.$value[i]!;\n    for (const [k, v] of Object.entries(layer)) {\n      if (typeof v === 'string' && isAlias(v)) {\n        token.mode[mode]!.partialAliasOf ??= [];\n        token.mode[mode]!.partialAliasOf[i] ??= {};\n        const expectedType = {\n          offsetX: ['dimension'],\n          offsetY: ['dimension'],\n          blur: ['dimension'],\n          spread: ['dimension'],\n          color: ['color'],\n          inset: ['boolean'],\n        }[k];\n        let node = ((options.node as unknown as ArrayNode | undefined)?.elements?.[i] as any) || options.node;\n        if (node.type === 'Object') {\n          node = getObjMembers(node)[k] || node;\n        }\n        const { resolvedToken } = resolveAlias(v, { ...options, token, expectedType, node });\n        (token.mode[mode]!.partialAliasOf[i] as any)[k] = parseAlias(v);\n        if (mode === '.') {\n          token.partialAliasOf ??= [];\n          token.partialAliasOf[i] ??= {};\n          (token.partialAliasOf[i] as any)[k] = parseAlias(v);\n        }\n        (layer as any)[k] = resolvedToken.$value;\n      }\n    }\n  }\n}\n\nfunction applyStrokeStylePartialAlias(\n  token: StrokeStyleTokenNormalized,\n  mode: string,\n  options: ApplyAliasOptions,\n): void {\n  // only dashArray can be aliased\n  if (typeof token.mode[mode]!.$value !== 'object' || !('dashArray' in token.mode[mode]!.$value)) {\n    return;\n  }\n\n  for (let i = 0; i < token.mode[mode]!.$value.dashArray.length; i++) {\n    const dash = token.mode[mode]!.$value.dashArray[i]!;\n    if (typeof dash === 'string' && isAlias(dash)) {\n      let node = (getObjMembers(options.node).dashArray as any) || options.node;\n      if (node.type === 'Array') {\n        node = ((node as unknown as ArrayNode | undefined)?.elements?.[i]?.value as any) || node;\n      }\n      const { resolvedToken } = resolveAlias(dash, {\n        ...options,\n        token,\n        expectedType: ['dimension'],\n        node,\n      });\n      (token.mode[mode]!.$value as any).dashArray[i] = resolvedToken.$value;\n    }\n  }\n}\n\nfunction applyTransitionPartialAlias(token: TransitionTokenNormalized, mode: string, options: ApplyAliasOptions): void {\n  for (const [k, v] of Object.entries(token.mode[mode]!.$value)) {\n    if (typeof v === 'string' && isAlias(v)) {\n      token.mode[mode]!.partialAliasOf ??= {};\n      const expectedType = { duration: ['duration'], delay: ['duration'], timingFunction: ['cubicBezier'] }[k];\n      const node = (getObjMembers(options.node)[k] as any) || options.node;\n      const { resolvedToken } = resolveAlias(v, { ...options, token, expectedType, node });\n      (token.mode[mode]!.partialAliasOf as any)[k] = parseAlias(v);\n      if (mode === '.') {\n        token.partialAliasOf ??= {};\n        (token.partialAliasOf as any)[k] = parseAlias(v);\n      }\n      (token.mode[mode]!.$value as any)[k] = resolvedToken.$value;\n    }\n  }\n}\n\nfunction applyTypographyPartialAlias(token: TypographyTokenNormalized, mode: string, options: ApplyAliasOptions): void {\n  for (const [k, v] of Object.entries(token.mode[mode]!.$value)) {\n    if (typeof v === 'string' && isAlias(v)) {\n      token.partialAliasOf ??= {};\n      token.mode[mode]!.partialAliasOf ??= {};\n      const expectedType = {\n        fontFamily: ['fontFamily'],\n        fontSize: ['dimension'],\n        fontWeight: ['fontWeight'],\n        letterSpacing: ['dimension'],\n        lineHeight: ['dimension', 'number'],\n      }[k] || ['string'];\n      const node = (getObjMembers(options.node)[k] as any) || options.node;\n      const { resolvedToken } = resolveAlias(v, { ...options, token, expectedType, node });\n      (token.mode[mode]!.partialAliasOf as any)[k] = parseAlias(v);\n      if (mode === '.') {\n        token.partialAliasOf[k] = parseAlias(v);\n      }\n      (token.mode[mode]!.$value as any)[k] = resolvedToken.$value;\n    }\n  }\n}\n","import {\n  type ColorValueNormalized,\n  type CubicBezierValue,\n  type DimensionValue,\n  type FontFamilyValue,\n  type GradientStopNormalized,\n  type GradientValueNormalized,\n  isAlias,\n  parseColor,\n  type ShadowValueNormalized,\n  type Token,\n  type TransitionValue,\n  type TypographyValueNormalized,\n} from '@terrazzo/token-tools';\n\nexport const FONT_WEIGHT_MAP = {\n  thin: 100,\n  hairline: 100,\n  'extra-light': 200,\n  'ultra-light': 200,\n  light: 300,\n  normal: 400,\n  regular: 400,\n  book: 400,\n  medium: 500,\n  'semi-bold': 600,\n  'demi-bold': 600,\n  bold: 700,\n  'extra-bold': 800,\n  'ultra-bold': 800,\n  black: 900,\n  heavy: 900,\n  'extra-black': 950,\n  'ultra-black': 950,\n};\n\nconst NUMBER_WITH_UNIT_RE = /(-?\\d*\\.?\\d+)(.*)/;\n\n/** Fill in defaults, and return predictable shapes for tokens */\nexport default function normalizeValue<T extends Token>(token: T): T['$value'] {\n  if (typeof token.$value === 'string' && isAlias(token.$value)) {\n    return token.$value;\n  }\n  switch (token.$type) {\n    case 'boolean': {\n      return !!token.$value;\n    }\n    case 'border': {\n      if (typeof token.$value === 'string') {\n        return token.$value;\n      }\n      return {\n        color: normalizeValue({ $type: 'color', $value: token.$value.color ?? '#000000' }),\n        style: normalizeValue({ $type: 'strokeStyle', $value: token.$value.style ?? 'solid' }),\n        width: normalizeValue({ $type: 'dimension', $value: token.$value.width }),\n      };\n    }\n    case 'color': {\n      if (typeof token.$value === 'string') {\n        return parseColor(token.$value);\n      }\n      const newValue: ColorValueNormalized = {\n        colorSpace: token.$value.colorSpace,\n        components: token.$value.components ?? token.$value.channels,\n        alpha: token.$value.alpha ?? 1,\n      };\n      if ('hex' in token.$value) {\n        newValue.hex = token.$value.hex;\n      }\n      return newValue;\n    }\n    case 'cubicBezier': {\n      if (typeof token.$value === 'string') {\n        return token.$value;\n      }\n      return token.$value.map((value) =>\n        typeof value === 'number' ? normalizeValue({ $type: 'number', $value: value }) : value,\n      ) as CubicBezierValue;\n    }\n    case 'dimension': {\n      if ((token as any).$value === 0) {\n        return { value: 0, unit: 'px' };\n      }\n      // Backwards compat: handle string\n      if (typeof token.$value === 'string') {\n        const match = token.$value.match(NUMBER_WITH_UNIT_RE);\n        return { value: Number.parseFloat(match?.[1] || token.$value), unit: match?.[2] || 'px' };\n      }\n      return token.$value;\n    }\n    case 'duration': {\n      if ((token as any).$value === 0) {\n        return { value: 0, unit: 'ms' };\n      }\n      // Backwards compat: handle string\n      if (typeof token.$value === 'string') {\n        const match = token.$value.match(NUMBER_WITH_UNIT_RE);\n        return { value: Number.parseFloat(match?.[1] || token.$value), unit: match?.[2] || 'ms' };\n      }\n      return token.$value;\n    }\n    case 'fontFamily': {\n      return Array.isArray(token.$value) ? token.$value : [token.$value];\n    }\n    case 'fontWeight': {\n      if (typeof token.$value === 'string' && FONT_WEIGHT_MAP[token.$value as keyof typeof FONT_WEIGHT_MAP]) {\n        return FONT_WEIGHT_MAP[token.$value as keyof typeof FONT_WEIGHT_MAP];\n      }\n      return Math.min(\n        999,\n        Math.max(1, typeof token.$value === 'string' ? Number.parseInt(token.$value) : token.$value),\n      );\n    }\n    case 'gradient': {\n      if (typeof token.$value === 'string') {\n        return token.$value;\n      }\n      const output: GradientValueNormalized = [];\n      for (let i = 0; i < token.$value.length; i++) {\n        const stop = structuredClone(token.$value[i] as GradientStopNormalized);\n        stop.color = normalizeValue({ $type: 'color', $value: stop.color! });\n        if (stop.position === undefined) {\n          stop.position = i / (token.$value.length - 1);\n        }\n        output.push(stop);\n      }\n      return output;\n    }\n    case 'number': {\n      return typeof token.$value === 'number' ? token.$value : Number.parseFloat(token.$value);\n    }\n    case 'shadow': {\n      if (typeof token.$value === 'string') {\n        return token.$value;\n      }\n      return (Array.isArray(token.$value) ? token.$value : [token.$value]).map(\n        (layer) =>\n          ({\n            color: normalizeValue({ $type: 'color', $value: layer.color }),\n            offsetX: normalizeValue({ $type: 'dimension', $value: layer.offsetX ?? { value: 0, unit: 'px' } }),\n            offsetY: normalizeValue({ $type: 'dimension', $value: layer.offsetY ?? { value: 0, unit: 'px' } }),\n            blur: normalizeValue({ $type: 'dimension', $value: layer.blur ?? { value: 0, unit: 'px' } }),\n            spread: normalizeValue({ $type: 'dimension', $value: layer.spread ?? { value: 0, unit: 'px' } }),\n            inset: layer.inset === true,\n          }) as ShadowValueNormalized,\n      );\n    }\n    case 'strokeStyle': {\n      return token.$value;\n    }\n    case 'string': {\n      return String(token.$value);\n    }\n    case 'transition': {\n      if (typeof token.$value === 'string') {\n        return token.$value;\n      }\n      return {\n        duration: normalizeValue({ $type: 'duration', $value: token.$value.duration ?? 0 }),\n        delay: normalizeValue({ $type: 'duration', $value: token.$value.delay ?? 0 }),\n        timingFunction: normalizeValue({ $type: 'cubicBezier', $value: token.$value.timingFunction }),\n      } as TransitionValue;\n    }\n    case 'typography': {\n      if (typeof token.$value === 'string') {\n        return token.$value;\n      }\n      const output: TypographyValueNormalized = {};\n      for (const [k, $value] of Object.entries(token.$value)) {\n        switch (k) {\n          case 'fontFamily': {\n            output[k] = normalizeValue({ $type: 'fontFamily', $value: $value as FontFamilyValue });\n            break;\n          }\n          case 'fontSize':\n          case 'letterSpacing': {\n            output[k] = normalizeValue({ $type: 'dimension', $value: $value as DimensionValue });\n            break;\n          }\n          case 'lineHeight': {\n            output[k] = normalizeValue({\n              $type: typeof token.$value === 'number' ? 'number' : 'dimension',\n              $value: $value as any,\n            });\n            break;\n          }\n          default: {\n            output[k] = $value;\n            break;\n          }\n        }\n      }\n      return output;\n    }\n    default: {\n      return token.$value;\n    }\n  }\n}\n","import {\n  type AnyNode,\n  type BooleanNode,\n  evaluate,\n  type MemberNode,\n  type ObjectNode,\n  print,\n  type StringNode,\n  type ValueNode,\n} from '@humanwhocodes/momoa';\nimport { isAlias, splitID, type Token, type TokenNormalized } from '@terrazzo/token-tools';\nimport wcmatch from 'wildcard-match';\nimport type Logger from '../logger.js';\nimport type { ConfigInit } from '../types.js';\nimport { getObjMembers, injectObjMembers } from './json.js';\n\nconst listFormat = new Intl.ListFormat('en-us', { type: 'disjunction' });\n\nexport interface ValidateOptions {\n  filename?: URL;\n  src: string;\n  logger: Logger;\n}\n\nexport interface Visitors {\n  color?: Visitor;\n  dimension?: Visitor;\n  fontFamily?: Visitor;\n  fontWeight?: Visitor;\n  duration?: Visitor;\n  cubicBezier?: Visitor;\n  number?: Visitor;\n  link?: Visitor;\n  boolean?: Visitor;\n  strokeStyle?: Visitor;\n  border?: Visitor;\n  transition?: Visitor;\n  shadow?: Visitor;\n  gradient?: Visitor;\n  typography?: Visitor;\n  root?: Visitor;\n  group?: Visitor;\n  [key: string]: Visitor | undefined;\n}\n\nexport type Visitor = (json: any, path: string, ast: AnyNode) => any | undefined | null;\n\nexport const VALID_COLORSPACES = new Set([\n  'adobe-rgb',\n  'display-p3',\n  'hsl',\n  'hwb',\n  'lab',\n  'lch',\n  'oklab',\n  'oklch',\n  'prophoto',\n  'rec2020',\n  'srgb',\n  'srgb-linear',\n  'xyz',\n  'xyz-d50',\n  'xyz-d65',\n]);\n\nexport const FONT_WEIGHT_VALUES = new Set([\n  'thin',\n  'hairline',\n  'extra-light',\n  'ultra-light',\n  'light',\n  'normal',\n  'regular',\n  'book',\n  'medium',\n  'semi-bold',\n  'demi-bold',\n  'bold',\n  'extra-bold',\n  'ultra-bold',\n  'black',\n  'heavy',\n  'extra-black',\n  'ultra-black',\n]);\n\nexport const STROKE_STYLE_VALUES = new Set([\n  'solid',\n  'dashed',\n  'dotted',\n  'double',\n  'groove',\n  'ridge',\n  'outset',\n  'inset',\n]);\nexport const STROKE_STYLE_LINE_CAP_VALUES = new Set(['round', 'butt', 'square']);\n\n/** Distinct from isAlias() in that this accepts malformed aliases */\nfunction isMaybeAlias(node: AnyNode) {\n  if (node?.type === 'String') {\n    return node.value.startsWith('{');\n  }\n  return false;\n}\n\n/** Assert object members match given types */\nfunction validateMembersAs(\n  $value: ObjectNode,\n  properties: Record<string, { validator: typeof validateAliasSyntax; required?: boolean }>,\n  node: AnyNode,\n  { filename, src, logger }: ValidateOptions,\n) {\n  const members = getObjMembers($value);\n  for (const [name, value] of Object.entries(properties)) {\n    const { validator, required } = value;\n    if (!members[name]) {\n      if (required) {\n        logger.error({\n          group: 'parser',\n          label: 'validate',\n          message: `Missing required property \"${name}\"`,\n          filename,\n          node: $value,\n          src,\n        });\n      }\n      continue;\n    }\n    const memberValue = members[name];\n    if (isMaybeAlias(memberValue)) {\n      validateAliasSyntax(memberValue, node, { filename, src, logger });\n    } else {\n      validator(memberValue, node, { filename, src, logger });\n    }\n  }\n}\n\n/** Verify an Alias $value is formatted correctly */\nexport function validateAliasSyntax($value: ValueNode, _node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  if ($value.type !== 'String' || !isAlias($value.value)) {\n    logger.error({\n      group: 'parser',\n      label: 'validate',\n      message: `Invalid alias: ${print($value)}`,\n      filename,\n      node: $value,\n      src,\n    });\n  }\n}\n\n/** Verify a Border token is valid */\nexport function validateBorder($value: ValueNode, node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  if ($value.type !== 'Object') {\n    logger.error({\n      group: 'parser',\n      label: 'validate',\n      message: `Expected object, received ${$value.type}`,\n      filename,\n      node: $value,\n      src,\n    });\n  } else {\n    validateMembersAs(\n      $value,\n      {\n        color: { validator: validateColor, required: true },\n        style: { validator: validateStrokeStyle, required: true },\n        width: { validator: validateDimension, required: true },\n      },\n      node,\n      { filename, src, logger },\n    );\n  }\n}\n\n/** Verify a Color token is valid */\nexport function validateColor($value: ValueNode, node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  const baseMessage = { group: 'parser' as const, label: 'validate', filename, node: $value, src };\n  if ($value.type === 'String') {\n    // TODO: enable when object notation is finalized\n    // logger.warn({\n    //   filename,\n    //   message: 'String colors are no longer recommended; please use the object notation instead.',\n    //   node: $value,\n    //   src,\n    // });\n    if ($value.value === '') {\n      logger.error({ ...baseMessage, message: 'Expected color, received empty string' });\n    }\n  } else if ($value.type === 'Object') {\n    // allow \"channels\" but raise warning. also rename as a workaround (mutating the AST is a bad idea in general, but this is safe)\n    const channelMemberI = $value.members.findIndex((m) => m.name.type === 'String' && m.name.value === 'channels');\n\n    if (channelMemberI !== -1) {\n      logger.warn({ ...baseMessage, message: '\"channels\" is deprecated; rename \"channels\" to \"components\"' });\n      ($value.members[channelMemberI]!.name as StringNode).value = 'components';\n    }\n\n    validateMembersAs(\n      $value,\n      {\n        colorSpace: {\n          validator: (v) => {\n            if (v.type !== 'String') {\n              logger.error({\n                ...baseMessage,\n                message: `Expected string, received ${print(v)}`,\n                node: v,\n              });\n            }\n            if (!VALID_COLORSPACES.has((v as StringNode).value)) {\n              logger.error({\n                ...baseMessage,\n                message: `Unsupported colorspace ${print(v)}`,\n                node: v,\n              });\n            }\n          },\n          required: true,\n        },\n        components: {\n          validator: (v) => {\n            if (v.type !== 'Array') {\n              logger.error({\n                ...baseMessage,\n                message: `Expected array, received ${print(v)}`,\n                node: v,\n              });\n            } else {\n              // note: in the future, length will change depending on colorSpace, e.g. CMYK\n              // but in the current spec it’s 3 for now.\n              if (v.elements?.length !== 3) {\n                logger.error({\n                  ...baseMessage,\n                  message: `Expected 3 components, received ${v.elements?.length ?? 0}`,\n                  node: v,\n                });\n              }\n              for (const element of v.elements) {\n                if (element.value.type !== 'Number') {\n                  logger.error({\n                    ...baseMessage,\n                    message: `Expected number, received ${print(element.value)}`,\n                    node: element,\n                  });\n                }\n              }\n            }\n          },\n          required: true,\n        },\n        hex: {\n          validator: (v) => {\n            if (\n              v.type !== 'String' ||\n              // this is a weird one—with the RegEx we test, it will work for\n              // lengths of 3, 4, 6, and 8 (but not 5 or 7). So we check length\n              // here, to keep the RegEx simple and readable. The \"+ 1\" is just\n              // accounting for the '#' prefix character.\n              v.value.length === 5 + 1 ||\n              v.value.length === 7 + 1 ||\n              !/^#[a-f0-9]{3,8}$/i.test(v.value)\n            ) {\n              logger.error({\n                ...baseMessage,\n                message: `Invalid hex color ${print(v)}`,\n                node: v,\n              });\n            }\n          },\n        },\n        alpha: { validator: validateNumber },\n      },\n      node,\n      { filename, src, logger },\n    );\n  } else {\n    logger.error({\n      ...baseMessage,\n      message: `Expected object, received ${$value.type}`,\n      node: $value,\n    });\n  }\n}\n\n/** Verify a Cubic Bézier token is valid */\nexport function validateCubicBezier($value: ValueNode, _node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  const baseMessage = { group: 'parser' as const, label: 'validate', filename, node: $value, src };\n  if ($value.type !== 'Array') {\n    logger.error({ ...baseMessage, message: `Expected array of numbers, received ${print($value)}` });\n  } else if (!$value.elements.every((e) => e.value.type === 'Number')) {\n    logger.error({ ...baseMessage, message: 'Expected an array of 4 numbers, received some non-numbers' });\n  } else if ($value.elements.length !== 4) {\n    logger.error({ ...baseMessage, message: `Expected an array of 4 numbers, received ${$value.elements.length}` });\n  }\n}\n\n/** Verify a Dimension token is valid */\nexport function validateDimension($value: ValueNode, _node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  if ($value.type === 'Number' && $value.value === 0) {\n    return; // `0` is a valid number\n  }\n\n  const baseMessage = { group: 'parser' as const, label: 'validate', filename, node: $value, src };\n\n  // Give priority to object notation because it’s a faster code path\n  if ($value.type === 'Object') {\n    const { value, unit } = getObjMembers($value);\n    if (!value) {\n      logger.error({ ...baseMessage, message: 'Missing required property \"value\".' });\n    }\n    if (!unit) {\n      logger.error({ ...baseMessage, message: 'Missing required property \"unit\".' });\n    }\n    if (value!.type !== 'Number') {\n      logger.error({\n        ...baseMessage,\n        message: `Expected number, received ${value!.type}`,\n        node: value,\n      });\n    }\n    if (!['px', 'em', 'rem'].includes((unit as StringNode).value)) {\n      logger.error({\n        ...baseMessage,\n        message: `Expected unit \"px\", \"em\", or \"rem\", received ${print(unit as StringNode)}`,\n        node: unit,\n      });\n    }\n    return;\n  }\n\n  // Backwards compat: string\n  if ($value.type !== 'String') {\n    logger.error({ ...baseMessage, message: `Expected string, received ${$value.type}` });\n  }\n  const value = ($value as StringNode).value.match(/^-?[0-9.]+/)?.[0];\n  const unit = ($value as StringNode).value.replace(value!, '');\n  if (($value as StringNode).value === '') {\n    logger.error({ ...baseMessage, message: 'Expected dimension, received empty string' });\n  } else if (!['px', 'em', 'rem'].includes(unit)) {\n    logger.error({\n      ...baseMessage,\n      message: `Expected unit \"px\", \"em\", or \"rem\", received ${JSON.stringify(unit || ($value as StringNode).value)}`,\n    });\n  } else if (!Number.isFinite(Number.parseFloat(value!))) {\n    logger.error({ ...baseMessage, message: `Expected dimension with units, received ${print($value)}` });\n  }\n}\n\n/** Verify a Duration token is valid */\nexport function validateDuration($value: ValueNode, _node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  if ($value.type === 'Number' && $value.value === 0) {\n    return; // `0` is a valid number\n  }\n\n  const baseMessage = { group: 'parser' as const, label: 'validate', filename, node: $value, src };\n\n  // Give priority to object notation because it’s a faster code path\n  if ($value.type === 'Object') {\n    const { value, unit } = getObjMembers($value);\n    if (!value) {\n      logger.error({ ...baseMessage, message: 'Missing required property \"value\".' });\n    }\n    if (!unit) {\n      logger.error({ ...baseMessage, message: 'Missing required property \"unit\".' });\n    }\n    if (value?.type !== 'Number') {\n      logger.error({\n        ...baseMessage,\n        message: `Expected number, received ${value?.type}`,\n        node: value,\n      });\n    }\n    if (!['ms', 's'].includes((unit as StringNode).value)) {\n      logger.error({\n        ...baseMessage,\n        message: `Expected unit \"ms\" or \"s\", received ${print(unit!)}`,\n        node: unit,\n      });\n    }\n    return;\n  }\n\n  // Backwards compat: string\n  if ($value.type !== 'String') {\n    logger.error({ ...baseMessage, message: `Expected string, received ${$value.type}` });\n  }\n  const value = ($value as StringNode).value.match(/^-?[0-9.]+/)?.[0]!;\n  const unit = ($value as StringNode).value.replace(value, '');\n  if (($value as StringNode).value === '') {\n    logger.error({ ...baseMessage, message: 'Expected duration, received empty string' });\n  } else if (!['ms', 's'].includes(unit)) {\n    logger.error({\n      ...baseMessage,\n      message: `Expected unit \"ms\" or \"s\", received ${JSON.stringify(unit || ($value as StringNode).value)}`,\n    });\n  } else if (!Number.isFinite(Number.parseFloat(value))) {\n    logger.error({ ...baseMessage, message: `Expected duration with units, received ${print($value)}` });\n  }\n}\n\n/**  Verify a Font Family token is valid */\nexport function validateFontFamily($value: ValueNode, _node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  const baseMessage = { group: 'parser' as const, label: 'validate', filename, node: $value, src };\n  if ($value.type !== 'String' && $value.type !== 'Array') {\n    logger.error({ ...baseMessage, message: `Expected string or array of strings, received ${$value.type}` });\n  }\n  if ($value.type === 'String' && $value.value === '') {\n    logger.error({ ...baseMessage, message: 'Expected font family name, received empty string' });\n  }\n  if ($value.type === 'Array' && !$value.elements.every((e) => e.value.type === 'String' && e.value.value !== '')) {\n    logger.error({\n      ...baseMessage,\n      message: 'Expected an array of strings, received some non-strings or empty strings',\n    });\n  }\n}\n\n/** Verify a Font Weight token is valid */\nexport function validateFontWeight($value: ValueNode, _node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  const baseMessage = { group: 'parser' as const, label: 'validate', filename, node: $value, src };\n  if ($value.type !== 'String' && $value.type !== 'Number') {\n    logger.error({ ...baseMessage, message: `Expected a font weight name or number 0–1000, received ${$value.type}` });\n  }\n  if ($value.type === 'String' && !FONT_WEIGHT_VALUES.has($value.value)) {\n    logger.error({\n      ...baseMessage,\n      message: `Unknown font weight ${print($value)}. Expected one of: ${listFormat.format([...FONT_WEIGHT_VALUES])}.`,\n    });\n  }\n  if ($value.type === 'Number' && ($value.value < 0 || $value.value > 1000)) {\n    logger.error({ ...baseMessage, message: `Expected number 0–1000, received ${print($value)}` });\n  }\n}\n\n/** Verify a Gradient token is valid */\nexport function validateGradient($value: ValueNode, _node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  const baseMessage = { group: 'parser' as const, label: 'validate', filename, node: $value, src };\n\n  if ($value.type !== 'Array') {\n    logger.error({ ...baseMessage, message: `Expected array of gradient stops, received ${$value.type}` });\n  } else {\n    for (let i = 0; i < $value.elements.length; i++) {\n      const element = $value.elements[i]!;\n      if (element.value.type !== 'Object') {\n        logger.error({\n          ...baseMessage,\n          message: `Stop #${i + 1}: Expected gradient stop, received ${element.value.type}`,\n          node: element,\n        });\n        break;\n      }\n      validateMembersAs(\n        element.value,\n        {\n          color: { validator: validateColor, required: true },\n          position: { validator: validateNumber, required: true },\n        },\n        element,\n        { filename, src, logger },\n      );\n    }\n  }\n}\n\n/** Verify a Number token is valid */\nexport function validateNumber($value: ValueNode, _node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  if ($value.type !== 'Number') {\n    logger.error({\n      group: 'parser',\n      label: 'validate',\n      message: `Expected number, received ${$value.type}`,\n      filename,\n      node: $value,\n      src,\n    });\n  }\n}\n\n/** Verify a Boolean token is valid */\nexport function validateBoolean($value: ValueNode, _node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  if ($value.type !== 'Boolean') {\n    logger.error({\n      group: 'parser',\n      label: 'validate',\n      message: `Expected boolean, received ${$value.type}`,\n      filename,\n      node: $value,\n      src,\n    });\n  }\n}\n\n/** Verify a Shadow token’s value is valid */\nexport function validateShadowLayer($value: ValueNode, node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  if ($value.type !== 'Object') {\n    logger.error({\n      group: 'parser',\n      label: 'validate',\n      message: `Expected Object, received ${$value.type}`,\n      filename,\n      node: $value,\n      src,\n    });\n  } else {\n    validateMembersAs(\n      $value,\n      {\n        color: { validator: validateColor, required: true },\n        offsetX: { validator: validateDimension, required: true },\n        offsetY: { validator: validateDimension, required: true },\n        blur: { validator: validateDimension },\n        spread: { validator: validateDimension },\n        inset: { validator: validateBoolean },\n      },\n      node,\n      { filename, src, logger },\n    );\n  }\n}\n\n/** Verify a Stroke Style token is valid. */\nexport function validateStrokeStyle($value: ValueNode, node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  const baseMessage = { group: 'parser' as const, label: 'validate', filename, node: $value, src };\n\n  // note: strokeStyle’s values are NOT aliasable (unless by string, but that breaks validations)\n  if ($value.type === 'String') {\n    if (!STROKE_STYLE_VALUES.has($value.value)) {\n      logger.error({\n        ...baseMessage,\n        message: `Unknown stroke style ${print($value)}. Expected one of: ${listFormat.format([\n          ...STROKE_STYLE_VALUES,\n        ])}.`,\n      });\n    }\n  } else if ($value.type === 'Object') {\n    const strokeMembers = getObjMembers($value);\n    for (const property of ['dashArray', 'lineCap']) {\n      if (!strokeMembers[property]) {\n        logger.error({ ...baseMessage, message: `Missing required property \"${property}\"` });\n      }\n    }\n    const { lineCap, dashArray } = strokeMembers;\n    if (lineCap?.type !== 'String' || !STROKE_STYLE_LINE_CAP_VALUES.has(lineCap.value)) {\n      logger.error({\n        ...baseMessage,\n        message: `Unknown lineCap value ${print(lineCap!)}. Expected one of: ${listFormat.format([\n          ...STROKE_STYLE_LINE_CAP_VALUES,\n        ])}.`,\n        node,\n      });\n    }\n    if (dashArray?.type === 'Array') {\n      for (const element of dashArray.elements) {\n        if (element.value.type === 'String' && element.value.value !== '') {\n          if (isMaybeAlias(element.value)) {\n            validateAliasSyntax(element.value, node, { logger, src });\n          } else {\n            validateDimension(element.value, node, { logger, src });\n          }\n        } else if (element.value.type === 'Object') {\n          validateDimension(element.value, node, { logger, src });\n        } else {\n          logger.error({\n            ...baseMessage,\n            message: `Expected array of dimensions, received ${element.value.type}.`,\n            node: element,\n          });\n        }\n      }\n    } else {\n      logger.error({ ...baseMessage, message: `Expected array of strings, received ${dashArray!.type}` });\n    }\n  } else {\n    logger.error({ ...baseMessage, message: `Expected string or object, received ${$value.type}` });\n  }\n}\n\n/** Verify a Transition token is valid */\nexport function validateTransition($value: ValueNode, node: AnyNode, { filename, src, logger }: ValidateOptions) {\n  if ($value.type !== 'Object') {\n    logger.error({\n      group: 'parser',\n      label: 'validate',\n      message: `Expected object, received ${$value.type}`,\n      filename,\n      node: $value,\n      src,\n    });\n  } else {\n    validateMembersAs(\n      $value,\n      {\n        duration: { validator: validateDuration, required: true },\n        delay: { validator: validateDuration, required: false }, // note: spec says delay is required, but Terrazzo makes delay optional\n        timingFunction: { validator: validateCubicBezier, required: true },\n      },\n      node,\n      { filename, src, logger },\n    );\n  }\n}\n\n/**\n * Validate a MemberNode (the entire token object, plus its key in the parent\n * object) to see if it’s a valid DTCG token or not. Keeping the parent key\n * really helps in debug messages.\n */\nexport function validateTokenMemberNode(node: MemberNode, { filename, src, logger }: ValidateOptions) {\n  const baseMessage = { group: 'parser' as const, label: 'validate', filename, node, src };\n\n  if (node.type !== 'Member' && node.type !== 'Object') {\n    logger.error({\n      ...baseMessage,\n      message: `Expected Object, received ${JSON.stringify(node.type)}`,\n    });\n  }\n\n  const rootMembers = node.value.type === 'Object' ? getObjMembers(node.value) : {};\n  const $value = rootMembers.$value as ValueNode;\n  const $type = rootMembers.$type as StringNode;\n\n  if (!$value) {\n    logger.error({ ...baseMessage, message: 'Token missing $value' });\n  }\n  // If top-level value is a valid alias, this is valid (no need for $type)\n  // ⚠️ Important: ALL Object and Array nodes below will need to check for aliases within!\n  if (isMaybeAlias($value)) {\n    validateAliasSyntax($value, node, { logger, src });\n    return;\n  }\n\n  if (!$type) {\n    logger.error({ ...baseMessage, message: 'Token missing $type' });\n  }\n\n  switch ($type.value) {\n    case 'color': {\n      validateColor($value, node, { logger, src });\n      break;\n    }\n    case 'cubicBezier': {\n      validateCubicBezier($value, node, { logger, src });\n      break;\n    }\n    case 'dimension': {\n      validateDimension($value, node, { logger, src });\n      break;\n    }\n    case 'duration': {\n      validateDuration($value, node, { logger, src });\n      break;\n    }\n    case 'fontFamily': {\n      validateFontFamily($value, node, { logger, src });\n      break;\n    }\n    case 'fontWeight': {\n      validateFontWeight($value, node, { logger, src });\n      break;\n    }\n    case 'number': {\n      validateNumber($value, node, { logger, src });\n      break;\n    }\n    case 'shadow': {\n      if ($value.type === 'Object') {\n        validateShadowLayer($value, node, { logger, src });\n      } else if ($value.type === 'Array') {\n        for (const element of $value.elements) {\n          validateShadowLayer(element.value, $value, { logger, src });\n        }\n      } else {\n        logger.error({\n          ...baseMessage,\n          message: `Expected shadow object or array of shadow objects, received ${$value.type}`,\n          node: $value,\n        });\n      }\n      break;\n    }\n\n    // extensions\n    case 'boolean': {\n      if ($value.type !== 'Boolean') {\n        logger.error({\n          ...baseMessage,\n          message: `Expected boolean, received ${$value.type}`,\n          node: $value,\n        });\n      }\n      break;\n    }\n    case 'link': {\n      if ($value.type !== 'String') {\n        logger.error({\n          ...baseMessage,\n          message: `Expected string, received ${$value.type}`,\n          node: $value,\n        });\n      } else if ($value.value === '') {\n        logger.error({\n          ...baseMessage,\n          message: 'Expected URL, received empty string',\n          node: $value,\n        });\n      }\n      break;\n    }\n    case 'string': {\n      if ($value.type !== 'String') {\n        logger.error({\n          ...baseMessage,\n          message: `Expected string, received ${$value.type}`,\n          node: $value,\n        });\n      }\n      break;\n    }\n\n    // composite types\n    case 'border': {\n      validateBorder($value, node, { filename, src, logger });\n      break;\n    }\n    case 'gradient': {\n      validateGradient($value, node, { filename, src, logger });\n      break;\n    }\n    case 'strokeStyle': {\n      validateStrokeStyle($value, node, { filename, src, logger });\n      break;\n    }\n    case 'transition': {\n      validateTransition($value, node, { filename, src, logger });\n      break;\n    }\n    case 'typography': {\n      if ($value.type !== 'Object') {\n        logger.error({\n          ...baseMessage,\n          message: `Expected object, received ${$value.type}`,\n          node: $value,\n        });\n        break;\n      }\n      if ($value.members.length === 0) {\n        logger.error({\n          ...baseMessage,\n          message: 'Empty typography token. Must contain at least 1 property.',\n          node: $value,\n        });\n      }\n      validateMembersAs(\n        $value,\n        {\n          fontFamily: { validator: validateFontFamily },\n          fontWeight: { validator: validateFontWeight },\n        },\n        node,\n        { filename, src, logger },\n      );\n      break;\n    }\n\n    default: {\n      // noop\n      break;\n    }\n  }\n}\n\n/** Return whether a MemberNode is a group (has no `$value`).\n * Groups can have properties that their child nodes will inherit. */\nexport function isGroupNode(node: ObjectNode): boolean {\n  if (node.type !== 'Object') {\n    return false;\n  }\n\n  // check for $value\n  const has$value = node.members.some((m) => m.name.type === 'String' && m.name.value === '$value');\n  return !has$value;\n}\n\n/** Check if a token node has the specified property name, and if it does, stores\n * the value in the `inherited` object as a side effect for future use. If not,\n * traverses the `inherited` object to find the closest parent that has the property.\n *\n * Returns the property value if found locally or in a parent, otherwise undefined. */\nexport function computeInheritedProperty(\n  node: MemberNode,\n  propertyName: string,\n  { subpath, inherited }: { subpath: string[]; inherited?: Record<string, MemberNode> },\n): MemberNode | undefined {\n  if (node.value.type !== 'Object') {\n    return;\n  }\n\n  // if property exists locally in the token node, add it to the inherited tree\n  const property = node.value.members.find((m) => m.name.type === 'String' && m.name.value === propertyName);\n  if (inherited && property && isGroupNode(node.value)) {\n    // this is where the side effect occurs\n    inherited[subpath.join('.') || '.'] = property;\n\n    // We know this is the closest property, so return early\n    return property;\n  }\n\n  // get parent type by taking the closest-scoped $type (length === closer)\n  const id = subpath.join('.');\n  let parent$type: MemberNode | undefined;\n  let longestPath = '';\n  for (const [k, v] of Object.entries(inherited ?? {})) {\n    if (k === '.' || id.startsWith(k)) {\n      if (k.length > longestPath.length) {\n        parent$type = v;\n        longestPath = k;\n      }\n    }\n  }\n\n  return parent$type;\n}\n\nexport interface ValidateTokenNodeOptions {\n  subpath: string[];\n  src: string;\n  filename: URL;\n  config: ConfigInit;\n  logger: Logger;\n  parent: AnyNode | undefined;\n  transform?: Visitors;\n  inheritedDeprecatedNode?: MemberNode;\n  inheritedTypeNode?: MemberNode;\n}\n\n/**\n * Validate does a little more than validate; it also converts to TokenNormalized\n * and sets up the basic data structure. But aliases are unresolved, and we need\n * a 2nd normalization pass afterward.\n */\nexport default function validateTokenNode(\n  node: MemberNode,\n  {\n    config,\n    filename,\n    logger,\n    parent,\n    inheritedDeprecatedNode,\n    inheritedTypeNode,\n    src,\n    subpath,\n  }: ValidateTokenNodeOptions,\n): TokenNormalized | undefined {\n  // don’t validate $value\n  if (subpath.includes('$value') || node.value.type !== 'Object') {\n    return;\n  }\n\n  const members = getObjMembers(node.value);\n\n  // don’t validate $extensions or $defs\n  if (!members.$value || subpath.includes('$extensions') || subpath.includes('$deps')) {\n    return;\n  }\n\n  const id = subpath.join('.');\n\n  if (!subpath.includes('.$value') && members.value) {\n    logger.warn({\n      group: 'parser',\n      label: 'validate',\n      message: `Group ${id} has \"value\". Did you mean \"$value\"?`,\n      filename,\n      node,\n      src,\n    });\n  }\n\n  const nodeWithType = structuredClone(node);\n  // inject $type that can be inherited in the DTCG format\n  let $type = (members.$type?.type === 'String' && members.$type.value) || undefined;\n  if (inheritedTypeNode && !members.$type) {\n    injectObjMembers(nodeWithType.value as ObjectNode, [inheritedTypeNode]);\n    $type = (inheritedTypeNode.value as StringNode).value;\n  }\n\n  // inject $deprecated that can also be inherited\n  let $deprecated = members.$deprecated\n    ? members.$deprecated?.type === 'String'\n      ? (members.$deprecated as StringNode).value\n      : (members.$deprecated as BooleanNode).value\n    : undefined;\n  if (inheritedDeprecatedNode && !members.$deprecated) {\n    injectObjMembers(nodeWithType.value as ObjectNode, [inheritedDeprecatedNode]);\n    $deprecated =\n      inheritedDeprecatedNode.value.type === 'String'\n        ? (inheritedDeprecatedNode.value as StringNode).value\n        : (inheritedDeprecatedNode.value as BooleanNode).value;\n  }\n\n  // validate once after injecting all inherited properties\n  validateTokenMemberNode(nodeWithType, { filename, src, logger });\n\n  // All tokens must be valid, so we want to validate it up till this\n  // point. However, if we are ignoring this token (or respecting\n  // $deprecated, we can omit it from the output.\n  if ((config.ignore.deprecated && $deprecated) || (config.ignore.tokens && wcmatch(config.ignore.tokens)(id))) {\n    return;\n  }\n\n  const group: TokenNormalized['group'] = { id: splitID(id).group!, tokens: [] };\n  if (inheritedTypeNode && inheritedTypeNode.value.type === 'String') {\n    group.$type = inheritedTypeNode.value.value as Token['$type'];\n  }\n  // note: this will also include sibling tokens, so be selective about only accessing group-specific properties\n  const groupMembers = getObjMembers(parent as ObjectNode);\n  if (groupMembers.$description) {\n    group.$description = evaluate(groupMembers.$description) as string;\n  }\n  if (groupMembers.$extensions) {\n    group.$extensions = evaluate(groupMembers.$extensions) as Record<string, unknown>;\n  }\n  const $value = evaluate(members.$value!);\n  const token = {\n    $type,\n    $value,\n    $deprecated,\n    id,\n    mode: {},\n    originalValue: evaluate(node.value),\n    group,\n    source: {\n      loc: filename?.href,\n      node: nodeWithType.value as ObjectNode,\n    },\n  } as unknown as TokenNormalized;\n  if (members.$description?.type === 'String' && members.$description.value) {\n    token.$description = members.$description.value;\n  }\n\n  // handle modes\n  // note that circular refs are avoided here, such as not duplicating `modes`\n  const extensions = members.$extensions ? getObjMembers(members.$extensions as ObjectNode) : undefined;\n  const modeValues = extensions?.mode ? getObjMembers(extensions.mode as any) : {};\n  for (const mode of ['.', ...Object.keys(modeValues)]) {\n    const modeValue = mode === '.' ? token.$value : (evaluate((modeValues as any)[mode]) as any);\n    token.mode[mode] = {\n      $value: modeValue,\n      originalValue: modeValue,\n      source: {\n        loc: filename?.href,\n        node: modeValues[mode] as ObjectNode,\n      },\n    };\n  }\n\n  return token;\n}\n","import { type DocumentNode, evaluate, type MemberNode, type ObjectNode } from '@humanwhocodes/momoa';\nimport { pluralize, splitID, type Token, type TokenNormalized } from '@terrazzo/token-tools';\nimport type ytm from 'yaml-to-momoa';\nimport lintRunner from '../lint/index.js';\nimport Logger from '../logger.js';\nimport type { ConfigInit, InputSource } from '../types.js';\nimport applyAliases from './alias.js';\nimport { getObjMembers, parseJSON, replaceObjMembers, toMomoa, traverse } from './json.js';\nimport normalize from './normalize.js';\nimport validateTokenNode, { computeInheritedProperty, isGroupNode, type Visitors } from './validate.js';\n\nexport * from './alias.js';\nexport * from './json.js';\nexport * from './normalize.js';\nexport * from './validate.js';\nexport { normalize, validateTokenNode };\n\nexport interface ParseOptions {\n  logger?: Logger;\n  config: ConfigInit;\n  /**\n   * Skip lint step\n   * @default false\n   */\n  skipLint?: boolean;\n  /**\n   * Continue on error? (Useful for `tz check`)\n   * @default false\n   */\n  continueOnError?: boolean;\n  /** Provide yamlToMomoa module to parse YAML (by default, this isn’t shipped to cut down on package weight) */\n  yamlToMomoa?: typeof ytm;\n  /**\n   * Transform API\n   * @see https://terrazzo.app/docs/api/js#transform-api\n   */\n  transform?: Visitors;\n  /** (internal cache; do not use) */\n  _sources?: Record<string, InputSource>;\n}\n\nexport interface ParseResult {\n  tokens: Record<string, TokenNormalized>;\n  sources: InputSource[];\n}\n\n/** Parse */\nexport default async function parse(\n  _input: Omit<InputSource, 'document'> | Omit<InputSource, 'document'>[],\n  {\n    logger = new Logger(),\n    skipLint = false,\n    config = {} as ConfigInit,\n    continueOnError = false,\n    yamlToMomoa,\n    transform,\n    _sources = {},\n  }: ParseOptions = {} as ParseOptions,\n): Promise<ParseResult> {\n  const input = Array.isArray(_input) ? _input : [_input];\n  let tokensSet: Record<string, TokenNormalized> = {};\n\n  if (!Array.isArray(input)) {\n    logger.error({ group: 'parser', label: 'init', message: 'Input must be an array of input objects.' });\n  }\n  await Promise.all(\n    input.map(async (src, i) => {\n      if (!src || typeof src !== 'object') {\n        logger.error({ group: 'parser', label: 'init', message: `Input (${i}) must be an object.` });\n      }\n      if (!src.src || (typeof src.src !== 'string' && typeof src.src !== 'object')) {\n        logger.error({\n          message: `Input (${i}) missing \"src\" with a JSON/YAML string, or JSON object.`,\n          group: 'parser',\n          label: 'init',\n        });\n      }\n      if (src.filename) {\n        if (!(src.filename instanceof URL)) {\n          logger.error({\n            message: `Input (${i}) \"filename\" must be a URL (remote or file URL).`,\n            group: 'parser',\n            label: 'init',\n          });\n        }\n\n        // if already parsed/scanned, skip\n        if (_sources[src.filename.href]) {\n          return;\n        }\n      }\n\n      const result = await parseSingle(src.src, {\n        filename: src.filename!,\n        logger,\n        config,\n        skipLint,\n        continueOnError,\n        yamlToMomoa,\n        transform,\n      });\n      tokensSet = Object.assign(tokensSet, result.tokens);\n      if (src.filename) {\n        _sources[src.filename.href] = {\n          filename: src.filename,\n          src: result.src,\n          document: result.document,\n        };\n      }\n    }),\n  );\n\n  const totalStart = performance.now();\n\n  // 5. Resolve aliases and populate groups\n  const aliasesStart = performance.now();\n  let aliasCount = 0;\n  for (const [id, token] of Object.entries(tokensSet)) {\n    applyAliases(token, {\n      tokensSet,\n      filename: _sources[token.source.loc!]?.filename!,\n      src: _sources[token.source.loc!]?.src as string,\n      node: (getObjMembers(token.source.node).$value as any) || token.source.node,\n      logger,\n    });\n    aliasCount++;\n    const { group: parentGroup } = splitID(id);\n    if (parentGroup) {\n      for (const siblingID of Object.keys(tokensSet)) {\n        const { group: siblingGroup } = splitID(siblingID);\n        if (siblingGroup?.startsWith(parentGroup)) {\n          token.group.tokens.push(siblingID);\n        }\n      }\n    }\n  }\n  logger.debug({\n    message: `Resolved ${aliasCount} aliases`,\n    group: 'parser',\n    label: 'alias',\n    timing: performance.now() - aliasesStart,\n  });\n\n  logger.debug({\n    message: 'Finish all parser tasks',\n    group: 'parser',\n    label: 'core',\n    timing: performance.now() - totalStart,\n  });\n\n  if (continueOnError) {\n    const { errorCount } = logger.stats();\n    if (errorCount > 0) {\n      logger.error({\n        group: 'parser',\n        message: `Parser encountered ${errorCount} ${pluralize(errorCount, 'error', 'errors')}. Exiting.`,\n      });\n    }\n  }\n\n  return {\n    tokens: tokensSet,\n    sources: Object.values(_sources),\n  };\n}\n\n/** Parse a single input */\nasync function parseSingle(\n  input: string | Record<string, any>,\n  {\n    filename,\n    logger,\n    config,\n    skipLint,\n    continueOnError = false,\n    transform,\n    yamlToMomoa, // optional dependency, declared here so the parser itself doesn’t have to load a heavy dep in-browser\n  }: {\n    filename: URL;\n    logger: Logger;\n    config: ConfigInit;\n    skipLint: boolean;\n    continueOnError?: boolean;\n    transform: ParseOptions['transform'] | undefined;\n    yamlToMomoa?: typeof ytm;\n  },\n): Promise<{ tokens: Record<string, Token>; document: DocumentNode; src?: string }> {\n  // 1. Build AST\n  const startParsing = performance.now();\n  let { src, document } = toMomoa(input, { filename, logger, continueOnError, yamlToMomoa });\n  logger.debug({\n    group: 'parser',\n    label: 'json',\n    message: 'Finish JSON parsing',\n    timing: performance.now() - startParsing,\n  });\n  const tokensSet: Record<string, TokenNormalized> = {};\n\n  // 1a. if there’s a root() transformer, then re-parse\n  if (transform?.root) {\n    const json = typeof input === 'string' ? JSON.parse(input) : input;\n    const result = transform?.root(json, '.', document);\n    if (result) {\n      const reRunResult = toMomoa(result, { filename, logger, continueOnError /* YAML not needed in transform() */ });\n      src = reRunResult.src;\n      document = reRunResult.document;\n    }\n  }\n\n  // 2. Walk AST to validate tokens\n  let tokenCount = 0;\n  const startValidate = performance.now();\n  // $type and $deprecated can be applied at group level to target all child tokens,\n  // these two objects keep track of inherited prop values as we traverse the token tree\n  const $typeInheritance: Record<string, MemberNode> = {};\n  const $deprecatedInheritance: Record<string, MemberNode> = {};\n  traverse(document, {\n    enter(node, parent, subpath) {\n      // if $type appears at root of tokens.json, collect it\n      if (node.type === 'Document' && node.body.type === 'Object' && node.body.members) {\n        const { members: rootMembers } = node.body;\n        if (isGroupNode(node.body)) {\n          const root$type = rootMembers.find((m) => m.name.type === 'String' && m.name.value === '$type');\n          if (root$type) {\n            $typeInheritance['.'] = root$type;\n          }\n          const root$deprecated = rootMembers.find((m) => m.name.type === 'String' && m.name.value === '$deprecated');\n          if (root$deprecated) {\n            $deprecatedInheritance['.'] = root$deprecated;\n          }\n        }\n      }\n\n      // for transform() visitors, all non-tokens MUST be handled at this point (besides \"root\", which was handled above)\n      if (\n        node.type === 'Object' && // JSON object\n        subpath.length &&\n        !node.members.some((m) => m.name.type === 'String' && m.name.value === '$value') && // not the token node itself\n        !subpath.includes('$value') && // not a child of a token node, either\n        !subpath.includes('$extensions') // not metadata\n      ) {\n        if (transform?.group) {\n          const newJSON = transform?.group(evaluate(node), subpath.join('.'), node);\n          if (newJSON) {\n            replaceObjMembers(node, parseJSON(newJSON));\n          }\n        }\n      }\n\n      // handle tokens\n      if (node.type === 'Member') {\n        const inheritedDeprecatedNode = computeInheritedProperty(node, '$deprecated', {\n          subpath,\n          inherited: $deprecatedInheritance,\n        });\n        const inheritedTypeNode = computeInheritedProperty(node, '$type', { subpath, inherited: $typeInheritance });\n        if (node.value.type === 'Object') {\n          const $value = node.value.members.find((m) => m.name.type === 'String' && m.name.value === '$value');\n\n          // Call transform using either inherited type or token-level type\n          let typeNode = inheritedTypeNode;\n          if (!typeNode) {\n            const local$type = node.value.members.find((m) => m.name.type === 'String' && m.name.value === '$type');\n            if (local$type) {\n              typeNode = local$type as MemberNode;\n            }\n          }\n\n          if ($value && typeNode?.value.type === 'String' && transform?.[typeNode.value.value]) {\n            const result = transform[typeNode.value.value]?.(evaluate(node.value), subpath.join('.'), node);\n            if (result) {\n              node.value = parseJSON(result).body;\n            }\n          }\n\n          const token = validateTokenNode(node, {\n            filename,\n            src,\n            config,\n            logger,\n            parent,\n            subpath,\n            transform,\n            inheritedDeprecatedNode,\n            inheritedTypeNode,\n          });\n          if (token) {\n            tokensSet[token.id] = token;\n            tokenCount++;\n          }\n        }\n      }\n    },\n  });\n  logger.debug({\n    message: `Validated ${tokenCount} tokens`,\n    group: 'parser',\n    label: 'validate',\n    timing: performance.now() - startValidate,\n  });\n\n  // 3. normalize values\n  const normalizeStart = performance.now();\n  for (const [id, token] of Object.entries(tokensSet)) {\n    try {\n      tokensSet[id]!.$value = normalize(token);\n    } catch (err) {\n      let { node } = token.source;\n      const members = getObjMembers(node);\n      if (members.$value) {\n        node = members.$value as ObjectNode;\n      }\n      logger.error({\n        group: 'parser',\n        label: 'normalize',\n        message: (err as Error).message,\n        filename,\n        src,\n        node,\n        continueOnError,\n      });\n    }\n    for (const [mode, modeValue] of Object.entries(token.mode)) {\n      if (mode === '.') {\n        continue;\n      }\n      try {\n        tokensSet[id]!.mode[mode]!.$value = normalize({ $type: token.$type, ...modeValue });\n      } catch (err) {\n        let { node } = token.source;\n        const members = getObjMembers(node);\n        if (members.$value) {\n          node = members.$value as ObjectNode;\n        }\n        logger.error({\n          group: 'parser',\n          label: 'normalize',\n          message: (err as Error).message,\n          filename,\n          src,\n          node: modeValue.source.node,\n          continueOnError,\n        });\n      }\n    }\n  }\n  logger.debug({\n    message: `Normalized ${tokenCount} tokens`,\n    group: 'parser',\n    label: 'normalize',\n    timing: performance.now() - normalizeStart,\n  });\n\n  // 4. Execute lint runner with loaded plugins\n  if (!skipLint && config?.plugins?.length) {\n    const lintStart = performance.now();\n    await lintRunner({ tokens: tokensSet, src, config, logger });\n    logger.debug({\n      message: `Linted ${tokenCount} tokens`,\n      group: 'parser',\n      label: 'lint',\n      timing: performance.now() - lintStart,\n    });\n  } else {\n    logger.debug({ message: 'Linting skipped', group: 'parser', label: 'lint' });\n  }\n\n  return {\n    tokens: tokensSet,\n    document,\n    src,\n  };\n}\n"],"x_google_ignoreList":[7,18],"mappings":"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"}