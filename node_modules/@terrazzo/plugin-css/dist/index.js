//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseNumber.js
const parseNumber = (color, len) => {
	if (typeof color !== "number") return;
	if (len === 3) return {
		mode: "rgb",
		r: (color >> 8 & 15 | color >> 4 & 240) / 255,
		g: (color >> 4 & 15 | color & 240) / 255,
		b: (color & 15 | color << 4 & 240) / 255
	};
	if (len === 4) return {
		mode: "rgb",
		r: (color >> 12 & 15 | color >> 8 & 240) / 255,
		g: (color >> 8 & 15 | color >> 4 & 240) / 255,
		b: (color >> 4 & 15 | color & 240) / 255,
		alpha: (color & 15 | color << 4 & 240) / 255
	};
	if (len === 6) return {
		mode: "rgb",
		r: (color >> 16 & 255) / 255,
		g: (color >> 8 & 255) / 255,
		b: (color & 255) / 255
	};
	if (len === 8) return {
		mode: "rgb",
		r: (color >> 24 & 255) / 255,
		g: (color >> 16 & 255) / 255,
		b: (color >> 8 & 255) / 255,
		alpha: (color & 255) / 255
	};
};
var parseNumber_default = parseNumber;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/colors/named.js
const named = {
	aliceblue: 15792383,
	antiquewhite: 16444375,
	aqua: 65535,
	aquamarine: 8388564,
	azure: 15794175,
	beige: 16119260,
	bisque: 16770244,
	black: 0,
	blanchedalmond: 16772045,
	blue: 255,
	blueviolet: 9055202,
	brown: 10824234,
	burlywood: 14596231,
	cadetblue: 6266528,
	chartreuse: 8388352,
	chocolate: 13789470,
	coral: 16744272,
	cornflowerblue: 6591981,
	cornsilk: 16775388,
	crimson: 14423100,
	cyan: 65535,
	darkblue: 139,
	darkcyan: 35723,
	darkgoldenrod: 12092939,
	darkgray: 11119017,
	darkgreen: 25600,
	darkgrey: 11119017,
	darkkhaki: 12433259,
	darkmagenta: 9109643,
	darkolivegreen: 5597999,
	darkorange: 16747520,
	darkorchid: 10040012,
	darkred: 9109504,
	darksalmon: 15308410,
	darkseagreen: 9419919,
	darkslateblue: 4734347,
	darkslategray: 3100495,
	darkslategrey: 3100495,
	darkturquoise: 52945,
	darkviolet: 9699539,
	deeppink: 16716947,
	deepskyblue: 49151,
	dimgray: 6908265,
	dimgrey: 6908265,
	dodgerblue: 2003199,
	firebrick: 11674146,
	floralwhite: 16775920,
	forestgreen: 2263842,
	fuchsia: 16711935,
	gainsboro: 14474460,
	ghostwhite: 16316671,
	gold: 16766720,
	goldenrod: 14329120,
	gray: 8421504,
	green: 32768,
	greenyellow: 11403055,
	grey: 8421504,
	honeydew: 15794160,
	hotpink: 16738740,
	indianred: 13458524,
	indigo: 4915330,
	ivory: 16777200,
	khaki: 15787660,
	lavender: 15132410,
	lavenderblush: 16773365,
	lawngreen: 8190976,
	lemonchiffon: 16775885,
	lightblue: 11393254,
	lightcoral: 15761536,
	lightcyan: 14745599,
	lightgoldenrodyellow: 16448210,
	lightgray: 13882323,
	lightgreen: 9498256,
	lightgrey: 13882323,
	lightpink: 16758465,
	lightsalmon: 16752762,
	lightseagreen: 2142890,
	lightskyblue: 8900346,
	lightslategray: 7833753,
	lightslategrey: 7833753,
	lightsteelblue: 11584734,
	lightyellow: 16777184,
	lime: 65280,
	limegreen: 3329330,
	linen: 16445670,
	magenta: 16711935,
	maroon: 8388608,
	mediumaquamarine: 6737322,
	mediumblue: 205,
	mediumorchid: 12211667,
	mediumpurple: 9662683,
	mediumseagreen: 3978097,
	mediumslateblue: 8087790,
	mediumspringgreen: 64154,
	mediumturquoise: 4772300,
	mediumvioletred: 13047173,
	midnightblue: 1644912,
	mintcream: 16121850,
	mistyrose: 16770273,
	moccasin: 16770229,
	navajowhite: 16768685,
	navy: 128,
	oldlace: 16643558,
	olive: 8421376,
	olivedrab: 7048739,
	orange: 16753920,
	orangered: 16729344,
	orchid: 14315734,
	palegoldenrod: 15657130,
	palegreen: 10025880,
	paleturquoise: 11529966,
	palevioletred: 14381203,
	papayawhip: 16773077,
	peachpuff: 16767673,
	peru: 13468991,
	pink: 16761035,
	plum: 14524637,
	powderblue: 11591910,
	purple: 8388736,
	rebeccapurple: 6697881,
	red: 16711680,
	rosybrown: 12357519,
	royalblue: 4286945,
	saddlebrown: 9127187,
	salmon: 16416882,
	sandybrown: 16032864,
	seagreen: 3050327,
	seashell: 16774638,
	sienna: 10506797,
	silver: 12632256,
	skyblue: 8900331,
	slateblue: 6970061,
	slategray: 7372944,
	slategrey: 7372944,
	snow: 16775930,
	springgreen: 65407,
	steelblue: 4620980,
	tan: 13808780,
	teal: 32896,
	thistle: 14204888,
	tomato: 16737095,
	turquoise: 4251856,
	violet: 15631086,
	wheat: 16113331,
	white: 16777215,
	whitesmoke: 16119285,
	yellow: 16776960,
	yellowgreen: 10145074
};
var named_default = named;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseNamed.js
const parseNamed = (color) => {
	return parseNumber_default(named_default[color.toLowerCase()], 6);
};
var parseNamed_default = parseNamed;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseHex.js
const hex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
const parseHex = (color) => {
	let match;
	return (match = color.match(hex)) ? parseNumber_default(parseInt(match[1], 16), match[1].length) : void 0;
};
var parseHex_default = parseHex;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/util/regex.js
const num$1 = "([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)";
const num_none = `(?:${num$1}|none)`;
const per = `${num$1}%`;
const per_none = `(?:${num$1}%|none)`;
const num_per = `(?:${num$1}%|${num$1})`;
const num_per_none = `(?:${num$1}%|${num$1}|none)`;
const hue$1 = `(?:${num$1}(deg|grad|rad|turn)|${num$1})`;
const hue_none = `(?:${num$1}(deg|grad|rad|turn)|${num$1}|none)`;
const c = `\\s*,\\s*`;
const rx_num_per_none = /* @__PURE__ */ new RegExp("^" + num_per_none + "$");

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseRgbLegacy.js
const rgb_num_old = /* @__PURE__ */ new RegExp(`^rgba?\\(\\s*${num$1}${c}${num$1}${c}${num$1}\\s*(?:,\\s*${num_per}\\s*)?\\)$`);
const rgb_per_old = /* @__PURE__ */ new RegExp(`^rgba?\\(\\s*${per}${c}${per}${c}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`);
const parseRgbLegacy = (color) => {
	let res = { mode: "rgb" };
	let match;
	if (match = color.match(rgb_num_old)) {
		if (match[1] !== void 0) res.r = match[1] / 255;
		if (match[2] !== void 0) res.g = match[2] / 255;
		if (match[3] !== void 0) res.b = match[3] / 255;
	} else if (match = color.match(rgb_per_old)) {
		if (match[1] !== void 0) res.r = match[1] / 100;
		if (match[2] !== void 0) res.g = match[2] / 100;
		if (match[3] !== void 0) res.b = match[3] / 100;
	} else return;
	if (match[4] !== void 0) res.alpha = Math.max(0, Math.min(1, match[4] / 100));
	else if (match[5] !== void 0) res.alpha = Math.max(0, Math.min(1, +match[5]));
	return res;
};
var parseRgbLegacy_default = parseRgbLegacy;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/_prepare.js
const prepare = (color, mode) => color === void 0 ? void 0 : typeof color !== "object" ? parse_default(color) : color.mode !== void 0 ? color : mode ? {
	...color,
	mode
} : void 0;
var _prepare_default = prepare;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/converter.js
const converter = (target_mode = "rgb") => (color) => (color = _prepare_default(color, target_mode)) !== void 0 ? color.mode === target_mode ? color : converters$1[color.mode][target_mode] ? converters$1[color.mode][target_mode](color) : target_mode === "rgb" ? converters$1[color.mode].rgb(color) : converters$1.rgb[target_mode](converters$1[color.mode].rgb(color)) : void 0;
var converter_default = converter;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/modes.js
const converters$1 = {};
const modes = {};
const parsers = [];
const colorProfiles = {};
const identity = (v) => v;
const useMode = (definition$28) => {
	converters$1[definition$28.mode] = {
		...converters$1[definition$28.mode],
		...definition$28.toMode
	};
	Object.keys(definition$28.fromMode || {}).forEach((k$3) => {
		if (!converters$1[k$3]) converters$1[k$3] = {};
		converters$1[k$3][definition$28.mode] = definition$28.fromMode[k$3];
	});
	if (!definition$28.ranges) definition$28.ranges = {};
	if (!definition$28.difference) definition$28.difference = {};
	definition$28.channels.forEach((channel) => {
		if (definition$28.ranges[channel] === void 0) definition$28.ranges[channel] = [0, 1];
		if (!definition$28.interpolate[channel]) throw new Error(`Missing interpolator for: ${channel}`);
		if (typeof definition$28.interpolate[channel] === "function") definition$28.interpolate[channel] = { use: definition$28.interpolate[channel] };
		if (!definition$28.interpolate[channel].fixup) definition$28.interpolate[channel].fixup = identity;
	});
	modes[definition$28.mode] = definition$28;
	(definition$28.parse || []).forEach((parser) => {
		useParser(parser, definition$28.mode);
	});
	return converter_default(definition$28.mode);
};
const getMode = (mode) => modes[mode];
const useParser = (parser, mode) => {
	if (typeof parser === "string") {
		if (!mode) throw new Error(`'mode' required when 'parser' is a string`);
		colorProfiles[parser] = mode;
	} else if (typeof parser === "function") {
		if (parsers.indexOf(parser) < 0) parsers.push(parser);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/parse.js
const IdentStartCodePoint = /[^\x00-\x7F]|[a-zA-Z_]/;
const IdentCodePoint = /[^\x00-\x7F]|[-\w]/;
const Tok = {
	Function: "function",
	Ident: "ident",
	Number: "number",
	Percentage: "percentage",
	ParenClose: ")",
	None: "none",
	Hue: "hue",
	Alpha: "alpha"
};
let _i = 0;
function is_num(chars) {
	let ch = chars[_i];
	let ch1 = chars[_i + 1];
	if (ch === "-" || ch === "+") return /\d/.test(ch1) || ch1 === "." && /\d/.test(chars[_i + 2]);
	if (ch === ".") return /\d/.test(ch1);
	return /\d/.test(ch);
}
function is_ident(chars) {
	if (_i >= chars.length) return false;
	let ch = chars[_i];
	if (IdentStartCodePoint.test(ch)) return true;
	if (ch === "-") {
		if (chars.length - _i < 2) return false;
		let ch1 = chars[_i + 1];
		if (ch1 === "-" || IdentStartCodePoint.test(ch1)) return true;
		return false;
	}
	return false;
}
const huenits = {
	deg: 1,
	rad: 180 / Math.PI,
	grad: 9 / 10,
	turn: 360
};
function num(chars) {
	let value = "";
	if (chars[_i] === "-" || chars[_i] === "+") value += chars[_i++];
	value += digits(chars);
	if (chars[_i] === "." && /\d/.test(chars[_i + 1])) value += chars[_i++] + digits(chars);
	if (chars[_i] === "e" || chars[_i] === "E") {
		if ((chars[_i + 1] === "-" || chars[_i + 1] === "+") && /\d/.test(chars[_i + 2])) value += chars[_i++] + chars[_i++] + digits(chars);
		else if (/\d/.test(chars[_i + 1])) value += chars[_i++] + digits(chars);
	}
	if (is_ident(chars)) {
		let id = ident(chars);
		if (id === "deg" || id === "rad" || id === "turn" || id === "grad") return {
			type: Tok.Hue,
			value: value * huenits[id]
		};
		return;
	}
	if (chars[_i] === "%") {
		_i++;
		return {
			type: Tok.Percentage,
			value: +value
		};
	}
	return {
		type: Tok.Number,
		value: +value
	};
}
function digits(chars) {
	let v = "";
	while (/\d/.test(chars[_i])) v += chars[_i++];
	return v;
}
function ident(chars) {
	let v = "";
	while (_i < chars.length && IdentCodePoint.test(chars[_i])) v += chars[_i++];
	return v;
}
function identlike(chars) {
	let v = ident(chars);
	if (chars[_i] === "(") {
		_i++;
		return {
			type: Tok.Function,
			value: v
		};
	}
	if (v === "none") return {
		type: Tok.None,
		value: void 0
	};
	return {
		type: Tok.Ident,
		value: v
	};
}
function tokenize(str = "") {
	let chars = str.trim();
	let tokens = [];
	let ch;
	_i = 0;
	while (_i < chars.length) {
		ch = chars[_i++];
		if (ch === "\n" || ch === "	" || ch === " ") {
			while (_i < chars.length && (chars[_i] === "\n" || chars[_i] === "	" || chars[_i] === " ")) _i++;
			continue;
		}
		if (ch === ",") return;
		if (ch === ")") {
			tokens.push({ type: Tok.ParenClose });
			continue;
		}
		if (ch === "+") {
			_i--;
			if (is_num(chars)) {
				tokens.push(num(chars));
				continue;
			}
			return;
		}
		if (ch === "-") {
			_i--;
			if (is_num(chars)) {
				tokens.push(num(chars));
				continue;
			}
			if (is_ident(chars)) {
				tokens.push({
					type: Tok.Ident,
					value: ident(chars)
				});
				continue;
			}
			return;
		}
		if (ch === ".") {
			_i--;
			if (is_num(chars)) {
				tokens.push(num(chars));
				continue;
			}
			return;
		}
		if (ch === "/") {
			while (_i < chars.length && (chars[_i] === "\n" || chars[_i] === "	" || chars[_i] === " ")) _i++;
			let alpha;
			if (is_num(chars)) {
				alpha = num(chars);
				if (alpha.type !== Tok.Hue) {
					tokens.push({
						type: Tok.Alpha,
						value: alpha
					});
					continue;
				}
			}
			if (is_ident(chars)) {
				if (ident(chars) === "none") {
					tokens.push({
						type: Tok.Alpha,
						value: {
							type: Tok.None,
							value: void 0
						}
					});
					continue;
				}
			}
			return;
		}
		if (/\d/.test(ch)) {
			_i--;
			tokens.push(num(chars));
			continue;
		}
		if (IdentStartCodePoint.test(ch)) {
			_i--;
			tokens.push(identlike(chars));
			continue;
		}
		return;
	}
	return tokens;
}
function parseColorSyntax(tokens) {
	tokens._i = 0;
	let token = tokens[tokens._i++];
	if (!token || token.type !== Tok.Function || token.value !== "color") return;
	token = tokens[tokens._i++];
	if (token.type !== Tok.Ident) return;
	const mode = colorProfiles[token.value];
	if (!mode) return;
	const res = { mode };
	const coords = consumeCoords(tokens, false);
	if (!coords) return;
	const channels = getMode(mode).channels;
	for (let ii = 0, c$1, ch; ii < channels.length; ii++) {
		c$1 = coords[ii];
		ch = channels[ii];
		if (c$1.type !== Tok.None) {
			res[ch] = c$1.type === Tok.Number ? c$1.value : c$1.value / 100;
			if (ch === "alpha") res[ch] = Math.max(0, Math.min(1, res[ch]));
		}
	}
	return res;
}
function consumeCoords(tokens, includeHue) {
	const coords = [];
	let token;
	while (tokens._i < tokens.length) {
		token = tokens[tokens._i++];
		if (token.type === Tok.None || token.type === Tok.Number || token.type === Tok.Alpha || token.type === Tok.Percentage || includeHue && token.type === Tok.Hue) {
			coords.push(token);
			continue;
		}
		if (token.type === Tok.ParenClose) {
			if (tokens._i < tokens.length) return;
			continue;
		}
		return;
	}
	if (coords.length < 3 || coords.length > 4) return;
	if (coords.length === 4) {
		if (coords[3].type !== Tok.Alpha) return;
		coords[3] = coords[3].value;
	}
	if (coords.length === 3) coords.push({
		type: Tok.None,
		value: void 0
	});
	return coords.every((c$1) => c$1.type !== Tok.Alpha) ? coords : void 0;
}
function parseModernSyntax(tokens, includeHue) {
	tokens._i = 0;
	let token = tokens[tokens._i++];
	if (!token || token.type !== Tok.Function) return;
	let coords = consumeCoords(tokens, includeHue);
	if (!coords) return;
	coords.unshift(token.value);
	return coords;
}
const parse = (color) => {
	if (typeof color !== "string") return;
	const tokens = tokenize(color);
	const parsed = tokens ? parseModernSyntax(tokens, true) : void 0;
	let result = void 0;
	let i = 0;
	let len = parsers.length;
	while (i < len) if ((result = parsers[i++](color, parsed)) !== void 0) return result;
	return tokens ? parseColorSyntax(tokens) : void 0;
};
var parse_default = parse;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseRgb.js
function parseRgb(color, parsed) {
	if (!parsed || parsed[0] !== "rgb" && parsed[0] !== "rgba") return;
	const res = { mode: "rgb" };
	const [, r$1, g, b, alpha] = parsed;
	if (r$1.type === Tok.Hue || g.type === Tok.Hue || b.type === Tok.Hue) return;
	if (r$1.type !== Tok.None) res.r = r$1.type === Tok.Number ? r$1.value / 255 : r$1.value / 100;
	if (g.type !== Tok.None) res.g = g.type === Tok.Number ? g.value / 255 : g.value / 100;
	if (b.type !== Tok.None) res.b = b.type === Tok.Number ? b.value / 255 : b.value / 100;
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseRgb_default = parseRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/parseTransparent.js
const parseTransparent = (c$1) => c$1 === "transparent" ? {
	mode: "rgb",
	r: 0,
	g: 0,
	b: 0,
	alpha: 0
} : void 0;
var parseTransparent_default = parseTransparent;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/interpolate/lerp.js
const lerp = (a, b, t) => a + t * (b - a);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/interpolate/piecewise.js
const get_classes = (arr) => {
	let classes = [];
	for (let i = 0; i < arr.length - 1; i++) {
		let a = arr[i];
		let b = arr[i + 1];
		if (a === void 0 && b === void 0) classes.push(void 0);
		else if (a !== void 0 && b !== void 0) classes.push([a, b]);
		else classes.push(a !== void 0 ? [a, a] : [b, b]);
	}
	return classes;
};
const interpolatorPiecewise = (interpolator) => (arr) => {
	let classes = get_classes(arr);
	return (t) => {
		let cls = t * classes.length;
		let idx = t >= 1 ? classes.length - 1 : Math.max(Math.floor(cls), 0);
		let pair = classes[idx];
		return pair === void 0 ? void 0 : interpolator(pair[0], pair[1], cls - idx);
	};
};

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/interpolate/linear.js
const interpolatorLinear = interpolatorPiecewise(lerp);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/fixup/alpha.js
const fixupAlpha = (arr) => {
	let some_defined = false;
	let res = arr.map((v) => {
		if (v !== void 0) {
			some_defined = true;
			return v;
		}
		return 1;
	});
	return some_defined ? res : arr;
};

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rgb/definition.js
const definition$27 = {
	mode: "rgb",
	channels: [
		"r",
		"g",
		"b",
		"alpha"
	],
	parse: [
		parseRgb_default,
		parseHex_default,
		parseRgbLegacy_default,
		parseNamed_default,
		parseTransparent_default,
		"srgb"
	],
	serialize: "srgb",
	interpolate: {
		r: interpolatorLinear,
		g: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	gamut: true,
	white: {
		r: 1,
		g: 1,
		b: 1
	},
	black: {
		r: 0,
		g: 0,
		b: 0
	}
};
var definition_default$12 = definition$27;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/a98/convertA98ToXyz65.js
const linearize$2 = (v = 0) => Math.pow(Math.abs(v), 563 / 256) * Math.sign(v);
const convertA98ToXyz65 = (a98$2) => {
	let r$1 = linearize$2(a98$2.r);
	let g = linearize$2(a98$2.g);
	let b = linearize$2(a98$2.b);
	let res = {
		mode: "xyz65",
		x: .5766690429101305 * r$1 + .1855582379065463 * g + .1882286462349947 * b,
		y: .297344975250536 * r$1 + .6273635662554661 * g + .0752914584939979 * b,
		z: .0270313613864123 * r$1 + .0706888525358272 * g + .9913375368376386 * b
	};
	if (a98$2.alpha !== void 0) res.alpha = a98$2.alpha;
	return res;
};
var convertA98ToXyz65_default = convertA98ToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/a98/convertXyz65ToA98.js
const gamma$2 = (v) => Math.pow(Math.abs(v), 256 / 563) * Math.sign(v);
const convertXyz65ToA98 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "a98",
		r: gamma$2(x * 2.0415879038107465 - y * .5650069742788597 - .3447313507783297 * z),
		g: gamma$2(x * -.9692436362808798 + y * 1.8759675015077206 + .0415550574071756 * z),
		b: gamma$2(x * .0134442806320312 - y * .1183623922310184 + 1.0151749943912058 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToA98_default = convertXyz65ToA98;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lrgb/convertRgbToLrgb.js
const fn$3 = (c$1 = 0) => {
	const abs$1 = Math.abs(c$1);
	if (abs$1 <= .04045) return c$1 / 12.92;
	return (Math.sign(c$1) || 1) * Math.pow((abs$1 + .055) / 1.055, 2.4);
};
const convertRgbToLrgb = ({ r: r$1, g, b, alpha }) => {
	let res = {
		mode: "lrgb",
		r: fn$3(r$1),
		g: fn$3(g),
		b: fn$3(b)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToLrgb_default = convertRgbToLrgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/convertRgbToXyz65.js
const convertRgbToXyz65 = (rgb$4) => {
	let { r: r$1, g, b, alpha } = convertRgbToLrgb_default(rgb$4);
	let res = {
		mode: "xyz65",
		x: .4123907992659593 * r$1 + .357584339383878 * g + .1804807884018343 * b,
		y: .2126390058715102 * r$1 + .715168678767756 * g + .0721923153607337 * b,
		z: .0193308187155918 * r$1 + .119194779794626 * g + .9505321522496607 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyz65_default = convertRgbToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lrgb/convertLrgbToRgb.js
const fn$2 = (c$1 = 0) => {
	const abs$1 = Math.abs(c$1);
	if (abs$1 > .0031308) return (Math.sign(c$1) || 1) * (1.055 * Math.pow(abs$1, 1 / 2.4) - .055);
	return c$1 * 12.92;
};
const convertLrgbToRgb = ({ r: r$1, g, b, alpha }, mode = "rgb") => {
	let res = {
		mode,
		r: fn$2(r$1),
		g: fn$2(g),
		b: fn$2(b)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLrgbToRgb_default = convertLrgbToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/convertXyz65ToRgb.js
const convertXyz65ToRgb = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default({
		r: x * 3.2409699419045226 - y * 1.537383177570094 - .4986107602930034 * z,
		g: x * -.9692436362808796 + y * 1.8759675015077204 + .0415550574071756 * z,
		b: x * .0556300796969936 - y * .2039769588889765 + 1.0569715142428784 * z
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToRgb_default = convertXyz65ToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/a98/definition.js
const definition$26 = {
	...definition_default$12,
	mode: "a98",
	parse: ["a98-rgb"],
	serialize: "a98-rgb",
	fromMode: {
		rgb: (color) => convertXyz65ToA98_default(convertRgbToXyz65_default(color)),
		xyz65: convertXyz65ToA98_default
	},
	toMode: {
		rgb: (color) => convertXyz65ToRgb_default(convertA98ToXyz65_default(color)),
		xyz65: convertA98ToXyz65_default
	}
};
var definition_default = definition$26;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/util/normalizeHue.js
const normalizeHue = (hue$2) => (hue$2 = hue$2 % 360) < 0 ? hue$2 + 360 : hue$2;
var normalizeHue_default = normalizeHue;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsl/convertHslToRgb.js
function convertHslToRgb({ h, s, l, alpha }) {
	h = normalizeHue_default(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (l === void 0) l = 0;
	let m1 = l + s * (l < .5 ? l : 1 - l);
	let m2 = m1 - (m1 - l) * 2 * Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: m1,
				g: m2,
				b: 2 * l - m1
			};
			break;
		case 1:
			res = {
				r: m2,
				g: m1,
				b: 2 * l - m1
			};
			break;
		case 2:
			res = {
				r: 2 * l - m1,
				g: m1,
				b: m2
			};
			break;
		case 3:
			res = {
				r: 2 * l - m1,
				g: m2,
				b: m1
			};
			break;
		case 4:
			res = {
				r: m2,
				g: 2 * l - m1,
				b: m1
			};
			break;
		case 5:
			res = {
				r: m1,
				g: 2 * l - m1,
				b: m2
			};
			break;
		default: res = {
			r: 2 * l - m1,
			g: 2 * l - m1,
			b: 2 * l - m1
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsl/convertRgbToHsl.js
function convertRgbToHsl({ r: r$1, g, b, alpha }) {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$1 = Math.max(r$1, g, b), m = Math.min(r$1, g, b);
	let res = {
		mode: "hsl",
		s: M$1 === m ? 0 : (M$1 - m) / (1 - Math.abs(M$1 + m - 1)),
		l: .5 * (M$1 + m)
	};
	if (M$1 - m !== 0) res.h = (M$1 === r$1 ? (g - b) / (M$1 - m) + (g < b) * 6 : M$1 === g ? (b - r$1) / (M$1 - m) + 2 : (r$1 - g) / (M$1 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/util/hue.js
const hueToDeg = (val, unit) => {
	switch (unit) {
		case "deg": return +val;
		case "rad": return val / Math.PI * 180;
		case "grad": return val / 10 * 9;
		case "turn": return val * 360;
	}
};
var hue_default = hueToDeg;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsl/parseHslLegacy.js
const hsl_old = /* @__PURE__ */ new RegExp(`^hsla?\\(\\s*${hue$1}${c}${per}${c}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`);
const parseHslLegacy = (color) => {
	let match = color.match(hsl_old);
	if (!match) return;
	let res = { mode: "hsl" };
	if (match[3] !== void 0) res.h = +match[3];
	else if (match[1] !== void 0 && match[2] !== void 0) res.h = hue_default(match[1], match[2]);
	if (match[4] !== void 0) res.s = Math.min(Math.max(0, match[4] / 100), 1);
	if (match[5] !== void 0) res.l = Math.min(Math.max(0, match[5] / 100), 1);
	if (match[6] !== void 0) res.alpha = Math.max(0, Math.min(1, match[6] / 100));
	else if (match[7] !== void 0) res.alpha = Math.max(0, Math.min(1, +match[7]));
	return res;
};
var parseHslLegacy_default = parseHslLegacy;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsl/parseHsl.js
function parseHsl(color, parsed) {
	if (!parsed || parsed[0] !== "hsl" && parsed[0] !== "hsla") return;
	const res = { mode: "hsl" };
	const [, h, s, l, alpha] = parsed;
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (s.type !== Tok.None) {
		if (s.type === Tok.Hue) return;
		res.s = s.value / 100;
	}
	if (l.type !== Tok.None) {
		if (l.type === Tok.Hue) return;
		res.l = l.value / 100;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseHsl_default = parseHsl;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/fixup/hue.js
const hue = (hues, fn$4) => {
	return hues.map((hue$2, idx, arr) => {
		if (hue$2 === void 0) return hue$2;
		let normalized = normalizeHue_default(hue$2);
		if (idx === 0 || hues[idx - 1] === void 0) return normalized;
		return fn$4(normalized - normalizeHue_default(arr[idx - 1]));
	}).reduce((acc, curr) => {
		if (!acc.length || curr === void 0 || acc[acc.length - 1] === void 0) {
			acc.push(curr);
			return acc;
		}
		acc.push(curr + acc[acc.length - 1]);
		return acc;
	}, []);
};
const fixupHueShorter = (arr) => hue(arr, (d) => Math.abs(d) <= 180 ? d : d - 360 * Math.sign(d));

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/difference.js
const differenceHueSaturation = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0 || !std.s || !smp.s) return 0;
	let std_h = normalizeHue_default(std.h);
	let smp_h = normalizeHue_default(smp.h);
	let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
	return 2 * Math.sqrt(std.s * smp.s) * dH;
};
const differenceHueNaive = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0) return 0;
	let std_h = normalizeHue_default(std.h);
	let smp_h = normalizeHue_default(smp.h);
	if (Math.abs(smp_h - std_h) > 180) return std_h - (smp_h - 360 * Math.sign(smp_h - std_h));
	return smp_h - std_h;
};
const differenceHueChroma = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0 || !std.c || !smp.c) return 0;
	let std_h = normalizeHue_default(std.h);
	let smp_h = normalizeHue_default(smp.h);
	let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
	return 2 * Math.sqrt(std.c * smp.c) * dH;
};
const differenceEuclidean = (mode = "rgb", weights = [
	1,
	1,
	1,
	0
]) => {
	let def = getMode(mode);
	let channels = def.channels;
	let diffs = def.difference;
	let conv = converter_default(mode);
	return (std, smp) => {
		let ConvStd = conv(std);
		let ConvSmp = conv(smp);
		return Math.sqrt(channels.reduce((sum, k$3, idx) => {
			let delta = diffs[k$3] ? diffs[k$3](ConvStd, ConvSmp) : ConvStd[k$3] - ConvSmp[k$3];
			return sum + (weights[idx] || 0) * Math.pow(isNaN(delta) ? 0 : delta, 2);
		}, 0));
	};
};

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/average.js
const averageAngle = (val) => {
	let sum = val.reduce((sum$1, val$1) => {
		if (val$1 !== void 0) {
			let rad = val$1 * Math.PI / 180;
			sum$1.sin += Math.sin(rad);
			sum$1.cos += Math.cos(rad);
		}
		return sum$1;
	}, {
		sin: 0,
		cos: 0
	});
	let angle = Math.atan2(sum.sin, sum.cos) * 180 / Math.PI;
	return angle < 0 ? 360 + angle : angle;
};

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsl/definition.js
const definition$25 = {
	mode: "hsl",
	toMode: { rgb: convertHslToRgb },
	fromMode: { rgb: convertRgbToHsl },
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	parse: [parseHsl_default, parseHslLegacy_default],
	serialize: (c$1) => `hsl(${c$1.h !== void 0 ? c$1.h : "none"} ${c$1.s !== void 0 ? c$1.s * 100 + "%" : "none"} ${c$1.l !== void 0 ? c$1.l * 100 + "%" : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$1 = definition$25;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsv/convertHsvToRgb.js
function convertHsvToRgb({ h, s, v, alpha }) {
	h = normalizeHue_default(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (v === void 0) v = 0;
	let f$2 = Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: v,
				g: v * (1 - s * f$2),
				b: v * (1 - s)
			};
			break;
		case 1:
			res = {
				r: v * (1 - s * f$2),
				g: v,
				b: v * (1 - s)
			};
			break;
		case 2:
			res = {
				r: v * (1 - s),
				g: v,
				b: v * (1 - s * f$2)
			};
			break;
		case 3:
			res = {
				r: v * (1 - s),
				g: v * (1 - s * f$2),
				b: v
			};
			break;
		case 4:
			res = {
				r: v * (1 - s * f$2),
				g: v * (1 - s),
				b: v
			};
			break;
		case 5:
			res = {
				r: v,
				g: v * (1 - s),
				b: v * (1 - s * f$2)
			};
			break;
		default: res = {
			r: v * (1 - s),
			g: v * (1 - s),
			b: v * (1 - s)
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsv/convertRgbToHsv.js
function convertRgbToHsv({ r: r$1, g, b, alpha }) {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$1 = Math.max(r$1, g, b), m = Math.min(r$1, g, b);
	let res = {
		mode: "hsv",
		s: M$1 === 0 ? 0 : 1 - m / M$1,
		v: M$1
	};
	if (M$1 - m !== 0) res.h = (M$1 === r$1 ? (g - b) / (M$1 - m) + (g < b) * 6 : M$1 === g ? (b - r$1) / (M$1 - m) + 2 : (r$1 - g) / (M$1 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsv/definition.js
const definition$24 = {
	mode: "hsv",
	toMode: { rgb: convertHsvToRgb },
	parse: ["--hsv"],
	serialize: "--hsv",
	fromMode: { rgb: convertRgbToHsv },
	channels: [
		"h",
		"s",
		"v",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		v: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$19 = definition$24;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hwb/convertHwbToRgb.js
function convertHwbToRgb({ h, w, b, alpha }) {
	if (w === void 0) w = 0;
	if (b === void 0) b = 0;
	if (w + b > 1) {
		let s = w + b;
		w /= s;
		b /= s;
	}
	return convertHsvToRgb({
		h,
		s: b === 1 ? 1 : 1 - w / (1 - b),
		v: 1 - b,
		alpha
	});
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hwb/convertRgbToHwb.js
function convertRgbToHwb(rgba) {
	let hsv$2 = convertRgbToHsv(rgba);
	if (hsv$2 === void 0) return void 0;
	let s = hsv$2.s !== void 0 ? hsv$2.s : 0;
	let v = hsv$2.v !== void 0 ? hsv$2.v : 0;
	let res = {
		mode: "hwb",
		w: (1 - s) * v,
		b: 1 - v
	};
	if (hsv$2.h !== void 0) res.h = hsv$2.h;
	if (hsv$2.alpha !== void 0) res.alpha = hsv$2.alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hwb/parseHwb.js
function ParseHwb(color, parsed) {
	if (!parsed || parsed[0] !== "hwb") return;
	const res = { mode: "hwb" };
	const [, h, w, b, alpha] = parsed;
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (w.type !== Tok.None) {
		if (w.type === Tok.Hue) return;
		res.w = w.value / 100;
	}
	if (b.type !== Tok.None) {
		if (b.type === Tok.Hue) return;
		res.b = b.value / 100;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseHwb_default = ParseHwb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hwb/definition.js
const definition$23 = {
	mode: "hwb",
	toMode: { rgb: convertHwbToRgb },
	fromMode: { rgb: convertRgbToHwb },
	channels: [
		"h",
		"w",
		"b",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	parse: [parseHwb_default],
	serialize: (c$1) => `hwb(${c$1.h !== void 0 ? c$1.h : "none"} ${c$1.w !== void 0 ? c$1.w * 100 + "%" : "none"} ${c$1.b !== void 0 ? c$1.b * 100 + "%" : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		w: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueNaive },
	average: { h: averageAngle }
};
var definition_default$2 = definition$23;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz50/constants.js
const k = Math.pow(29, 3) / Math.pow(3, 3);
const e = Math.pow(6, 3) / Math.pow(29, 3);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/constants.js
const D50 = {
	X: .3457 / .3585,
	Y: 1,
	Z: .2958 / .3585
};
const D65 = {
	X: .3127 / .329,
	Y: 1,
	Z: .3583 / .329
};
const k$2 = Math.pow(29, 3) / Math.pow(3, 3);
const e$2 = Math.pow(6, 3) / Math.pow(29, 3);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/convertLabToXyz50.js
let fn$1 = (v) => Math.pow(v, 3) > e ? Math.pow(v, 3) : (116 * v - 16) / k;
const convertLabToXyz50 = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let fy = (l + 16) / 116;
	let fx = a / 500 + fy;
	let fz = fy - b / 200;
	let res = {
		mode: "xyz50",
		x: fn$1(fx) * D50.X,
		y: fn$1(fy) * D50.Y,
		z: fn$1(fz) * D50.Z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLabToXyz50_default = convertLabToXyz50;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz50/convertXyz50ToRgb.js
const convertXyz50ToRgb = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default({
		r: x * 3.1341359569958707 - y * 1.6173863321612538 - .4906619460083532 * z,
		g: x * -.978795502912089 + y * 1.916254567259524 + .03344273116131949 * z,
		b: x * .07195537988411677 - y * .2289768264158322 + 1.405386058324125 * z
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToRgb_default = convertXyz50ToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/convertLabToRgb.js
const convertLabToRgb = (lab$2) => convertXyz50ToRgb_default(convertLabToXyz50_default(lab$2));
var convertLabToRgb_default = convertLabToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz50/convertRgbToXyz50.js
const convertRgbToXyz50 = (rgb$4) => {
	let { r: r$1, g, b, alpha } = convertRgbToLrgb_default(rgb$4);
	let res = {
		mode: "xyz50",
		x: .436065742824811 * r$1 + .3851514688337912 * g + .14307845442264197 * b,
		y: .22249319175623702 * r$1 + .7168870538238823 * g + .06061979053616537 * b,
		z: .013923904500943465 * r$1 + .09708128566574634 * g + .7140993584005155 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyz50_default = convertRgbToXyz50;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/convertXyz50ToLab.js
const f$1 = (value) => value > e ? Math.cbrt(value) : (k * value + 16) / 116;
const convertXyz50ToLab = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let f0 = f$1(x / D50.X);
	let f1 = f$1(y / D50.Y);
	let f2 = f$1(z / D50.Z);
	let res = {
		mode: "lab",
		l: 116 * f1 - 16,
		a: 500 * (f0 - f1),
		b: 200 * (f1 - f2)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToLab_default = convertXyz50ToLab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/convertRgbToLab.js
const convertRgbToLab = (rgb$4) => {
	let res = convertXyz50ToLab_default(convertRgbToXyz50_default(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToLab_default = convertRgbToLab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/parseLab.js
function parseLab(color, parsed) {
	if (!parsed || parsed[0] !== "lab") return;
	const res = { mode: "lab" };
	const [, l, a, b, alpha] = parsed;
	if (l.type === Tok.Hue || a.type === Tok.Hue || b.type === Tok.Hue) return;
	if (l.type !== Tok.None) res.l = Math.min(Math.max(0, l.value), 100);
	if (a.type !== Tok.None) res.a = a.type === Tok.Number ? a.value : a.value * 125 / 100;
	if (b.type !== Tok.None) res.b = b.type === Tok.Number ? b.value : b.value * 125 / 100;
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseLab_default = parseLab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab/definition.js
const definition$22 = {
	mode: "lab",
	toMode: {
		xyz50: convertLabToXyz50_default,
		rgb: convertLabToRgb_default
	},
	fromMode: {
		xyz50: convertXyz50ToLab_default,
		rgb: convertRgbToLab_default
	},
	channels: [
		"l",
		"a",
		"b",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		a: [-125, 125],
		b: [-125, 125]
	},
	parse: [parseLab_default],
	serialize: (c$1) => `lab(${c$1.l !== void 0 ? c$1.l : "none"} ${c$1.a !== void 0 ? c$1.a : "none"} ${c$1.b !== void 0 ? c$1.b : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`,
	interpolate: {
		l: interpolatorLinear,
		a: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$3 = definition$22;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/constants.js
const k$1 = Math.pow(29, 3) / Math.pow(3, 3);
const e$1 = Math.pow(6, 3) / Math.pow(29, 3);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab65/convertLab65ToXyz65.js
let fn = (v) => Math.pow(v, 3) > e$1 ? Math.pow(v, 3) : (116 * v - 16) / k$1;
const convertLab65ToXyz65 = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let fy = (l + 16) / 116;
	let fx = a / 500 + fy;
	let fz = fy - b / 200;
	let res = {
		mode: "xyz65",
		x: fn(fx) * D65.X,
		y: fn(fy) * D65.Y,
		z: fn(fz) * D65.Z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLab65ToXyz65_default = convertLab65ToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab65/convertLab65ToRgb.js
const convertLab65ToRgb = (lab$2) => convertXyz65ToRgb_default(convertLab65ToXyz65_default(lab$2));
var convertLab65ToRgb_default = convertLab65ToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab65/convertXyz65ToLab65.js
const f = (value) => value > e$1 ? Math.cbrt(value) : (k$1 * value + 16) / 116;
const convertXyz65ToLab65 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let f0 = f(x / D65.X);
	let f1 = f(y / D65.Y);
	let f2 = f(z / D65.Z);
	let res = {
		mode: "lab65",
		l: 116 * f1 - 16,
		a: 500 * (f0 - f1),
		b: 200 * (f1 - f2)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToLab65_default = convertXyz65ToLab65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab65/convertRgbToLab65.js
const convertRgbToLab65 = (rgb$4) => {
	let res = convertXyz65ToLab65_default(convertRgbToXyz65_default(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToLab65_default = convertRgbToLab65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lab65/definition.js
const definition$21 = {
	...definition_default$3,
	mode: "lab65",
	parse: ["--lab-d65"],
	serialize: "--lab-d65",
	toMode: {
		xyz65: convertLab65ToXyz65_default,
		rgb: convertLab65ToRgb_default
	},
	fromMode: {
		xyz65: convertXyz65ToLab65_default,
		rgb: convertRgbToLab65_default
	},
	ranges: {
		l: [0, 100],
		a: [-125, 125],
		b: [-125, 125]
	}
};
var definition_default$4 = definition$21;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lch/convertLabToLch.js
const convertLabToLch = ({ l, a, b, alpha }, mode = "lch") => {
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let c$1 = Math.sqrt(a * a + b * b);
	let res = {
		mode,
		l,
		c: c$1
	};
	if (c$1) res.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLabToLch_default = convertLabToLch;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lch/convertLchToLab.js
const convertLchToLab = ({ l, c: c$1, h, alpha }, mode = "lab") => {
	if (h === void 0) h = 0;
	let res = {
		mode,
		l,
		a: c$1 ? c$1 * Math.cos(h / 180 * Math.PI) : 0,
		b: c$1 ? c$1 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLchToLab_default = convertLchToLab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lch/parseLch.js
function parseLch(color, parsed) {
	if (!parsed || parsed[0] !== "lch") return;
	const res = { mode: "lch" };
	const [, l, c$1, h, alpha] = parsed;
	if (l.type !== Tok.None) {
		if (l.type === Tok.Hue) return;
		res.l = Math.min(Math.max(0, l.value), 100);
	}
	if (c$1.type !== Tok.None) res.c = Math.max(0, c$1.type === Tok.Number ? c$1.value : c$1.value * 150 / 100);
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseLch_default = parseLch;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lch/definition.js
const definition$20 = {
	mode: "lch",
	toMode: {
		lab: convertLchToLab_default,
		rgb: (c$1) => convertLabToRgb_default(convertLchToLab_default(c$1))
	},
	fromMode: {
		rgb: (c$1) => convertLabToLch_default(convertRgbToLab_default(c$1)),
		lab: convertLabToLch_default
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		c: [0, 150],
		h: [0, 360]
	},
	parse: [parseLch_default],
	serialize: (c$1) => `lch(${c$1.l !== void 0 ? c$1.l : "none"} ${c$1.c !== void 0 ? c$1.c : "none"} ${c$1.h !== void 0 ? c$1.h : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		c: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$5 = definition$20;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lch65/definition.js
const definition$19 = {
	...definition_default$5,
	mode: "lch65",
	parse: ["--lch-d65"],
	serialize: "--lch-d65",
	toMode: {
		lab65: (c$1) => convertLchToLab_default(c$1, "lab65"),
		rgb: (c$1) => convertLab65ToRgb_default(convertLchToLab_default(c$1, "lab65"))
	},
	fromMode: {
		rgb: (c$1) => convertLabToLch_default(convertRgbToLab65_default(c$1), "lch65"),
		lab65: (c$1) => convertLabToLch_default(c$1, "lch65")
	},
	ranges: {
		l: [0, 100],
		c: [0, 150],
		h: [0, 360]
	}
};
var definition_default$23 = definition$19;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lrgb/definition.js
const definition$18 = {
	...definition_default$12,
	mode: "lrgb",
	toMode: { rgb: convertLrgbToRgb_default },
	fromMode: { rgb: convertRgbToLrgb_default },
	parse: ["srgb-linear"],
	serialize: "srgb-linear"
};
var definition_default$6 = definition$18;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/convertOklabToLrgb.js
const convertOklabToLrgb = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let L = Math.pow(l + .3963377773761749 * a + .2158037573099136 * b, 3);
	let M$1 = Math.pow(l - .1055613458156586 * a - .0638541728258133 * b, 3);
	let S = Math.pow(l - .0894841775298119 * a - 1.2914855480194092 * b, 3);
	let res = {
		mode: "lrgb",
		r: 4.076741636075957 * L - 3.3077115392580616 * M$1 + .2309699031821044 * S,
		g: -1.2684379732850317 * L + 2.6097573492876887 * M$1 - .3413193760026573 * S,
		b: -.0041960761386756 * L - .7034186179359362 * M$1 + 1.7076146940746117 * S
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertOklabToLrgb_default = convertOklabToLrgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/convertLrgbToOklab.js
const convertLrgbToOklab = ({ r: r$1, g, b, alpha }) => {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let L = Math.cbrt(.412221469470763 * r$1 + .5363325372617348 * g + .0514459932675022 * b);
	let M$1 = Math.cbrt(.2119034958178252 * r$1 + .6806995506452344 * g + .1073969535369406 * b);
	let S = Math.cbrt(.0883024591900564 * r$1 + .2817188391361215 * g + .6299787016738222 * b);
	let res = {
		mode: "oklab",
		l: .210454268309314 * L + .7936177747023054 * M$1 - .0040720430116193 * S,
		a: 1.9779985324311684 * L - 2.42859224204858 * M$1 + .450593709617411 * S,
		b: .0259040424655478 * L + .7827717124575296 * M$1 - .8086757549230774 * S
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLrgbToOklab_default = convertLrgbToOklab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/convertRgbToOklab.js
const convertRgbToOklab = (rgb$4) => {
	let res = convertLrgbToOklab_default(convertRgbToLrgb_default(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToOklab_default = convertRgbToOklab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/convertOklabToRgb.js
const convertOklabToRgb = (c$1) => convertLrgbToRgb_default(convertOklabToLrgb_default(c$1));
var convertOklabToRgb_default = convertOklabToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/parseOklab.js
function parseOklab(color, parsed) {
	if (!parsed || parsed[0] !== "oklab") return;
	const res = { mode: "oklab" };
	const [, l, a, b, alpha] = parsed;
	if (l.type === Tok.Hue || a.type === Tok.Hue || b.type === Tok.Hue) return;
	if (l.type !== Tok.None) res.l = Math.min(Math.max(0, l.type === Tok.Number ? l.value : l.value / 100), 1);
	if (a.type !== Tok.None) res.a = a.type === Tok.Number ? a.value : a.value * .4 / 100;
	if (b.type !== Tok.None) res.b = b.type === Tok.Number ? b.value : b.value * .4 / 100;
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseOklab_default = parseOklab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklab/definition.js
const definition$17 = {
	...definition_default$3,
	mode: "oklab",
	toMode: {
		lrgb: convertOklabToLrgb_default,
		rgb: convertOklabToRgb_default
	},
	fromMode: {
		lrgb: convertLrgbToOklab_default,
		rgb: convertRgbToOklab_default
	},
	ranges: {
		l: [0, 1],
		a: [-.4, .4],
		b: [-.4, .4]
	},
	parse: [parseOklab_default],
	serialize: (c$1) => `oklab(${c$1.l !== void 0 ? c$1.l : "none"} ${c$1.a !== void 0 ? c$1.a : "none"} ${c$1.b !== void 0 ? c$1.b : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`
};
var definition_default$7 = definition$17;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklch/parseOklch.js
function parseOklch(color, parsed) {
	if (!parsed || parsed[0] !== "oklch") return;
	const res = { mode: "oklch" };
	const [, l, c$1, h, alpha] = parsed;
	if (l.type !== Tok.None) {
		if (l.type === Tok.Hue) return;
		res.l = Math.min(Math.max(0, l.type === Tok.Number ? l.value : l.value / 100), 1);
	}
	if (c$1.type !== Tok.None) res.c = Math.max(0, c$1.type === Tok.Number ? c$1.value : c$1.value * .4 / 100);
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseOklch_default = parseOklch;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/oklch/definition.js
const definition$16 = {
	...definition_default$5,
	mode: "oklch",
	toMode: {
		oklab: (c$1) => convertLchToLab_default(c$1, "oklab"),
		rgb: (c$1) => convertOklabToRgb_default(convertLchToLab_default(c$1, "oklab"))
	},
	fromMode: {
		rgb: (c$1) => convertLabToLch_default(convertRgbToOklab_default(c$1), "oklch"),
		oklab: (c$1) => convertLabToLch_default(c$1, "oklch")
	},
	parse: [parseOklch_default],
	serialize: (c$1) => `oklch(${c$1.l !== void 0 ? c$1.l : "none"} ${c$1.c !== void 0 ? c$1.c : "none"} ${c$1.h !== void 0 ? c$1.h : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`,
	ranges: {
		l: [0, 1],
		c: [0, .4],
		h: [0, 360]
	}
};
var definition_default$8 = definition$16;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/p3/convertP3ToXyz65.js
const convertP3ToXyz65 = (rgb$4) => {
	let { r: r$1, g, b, alpha } = convertRgbToLrgb_default(rgb$4);
	let res = {
		mode: "xyz65",
		x: .486570948648216 * r$1 + .265667693169093 * g + .1982172852343625 * b,
		y: .2289745640697487 * r$1 + .6917385218365062 * g + .079286914093745 * b,
		z: 0 * r$1 + .0451133818589026 * g + 1.043944368900976 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertP3ToXyz65_default = convertP3ToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/p3/convertXyz65ToP3.js
const convertXyz65ToP3 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default({
		r: x * 2.4934969119414263 - y * .9313836179191242 - .402710784450717 * z,
		g: x * -.8294889695615749 + y * 1.7626640603183465 + .0236246858419436 * z,
		b: x * .0358458302437845 - y * .0761723892680418 + .9568845240076871 * z
	}, "p3");
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToP3_default = convertXyz65ToP3;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/p3/definition.js
const definition$15 = {
	...definition_default$12,
	mode: "p3",
	parse: ["display-p3"],
	serialize: "display-p3",
	fromMode: {
		rgb: (color) => convertXyz65ToP3_default(convertRgbToXyz65_default(color)),
		xyz65: convertXyz65ToP3_default
	},
	toMode: {
		rgb: (color) => convertXyz65ToRgb_default(convertP3ToXyz65_default(color)),
		xyz65: convertP3ToXyz65_default
	}
};
var definition_default$9 = definition$15;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/prophoto/convertXyz50ToProphoto.js
const gamma$1 = (v) => {
	let abs$1 = Math.abs(v);
	if (abs$1 >= 1 / 512) return Math.sign(v) * Math.pow(abs$1, 1 / 1.8);
	return 16 * v;
};
const convertXyz50ToProphoto = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "prophoto",
		r: gamma$1(x * 1.3457868816471585 - y * .2555720873797946 - .0511018649755453 * z),
		g: gamma$1(x * -.5446307051249019 + y * 1.5082477428451466 + .0205274474364214 * z),
		b: gamma$1(x * 0 + y * 0 + 1.2119675456389452 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToProphoto_default = convertXyz50ToProphoto;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/prophoto/convertProphotoToXyz50.js
const linearize$1 = (v = 0) => {
	let abs$1 = Math.abs(v);
	if (abs$1 >= 16 / 512) return Math.sign(v) * Math.pow(abs$1, 1.8);
	return v / 16;
};
const convertProphotoToXyz50 = (prophoto$2) => {
	let r$1 = linearize$1(prophoto$2.r);
	let g = linearize$1(prophoto$2.g);
	let b = linearize$1(prophoto$2.b);
	let res = {
		mode: "xyz50",
		x: .7977666449006423 * r$1 + .1351812974005331 * g + .0313477341283922 * b,
		y: .2880748288194013 * r$1 + .7118352342418731 * g + 899369387256e-16 * b,
		z: 0 * r$1 + 0 * g + .8251046025104602 * b
	};
	if (prophoto$2.alpha !== void 0) res.alpha = prophoto$2.alpha;
	return res;
};
var convertProphotoToXyz50_default = convertProphotoToXyz50;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/prophoto/definition.js
const definition$14 = {
	...definition_default$12,
	mode: "prophoto",
	parse: ["prophoto-rgb"],
	serialize: "prophoto-rgb",
	fromMode: {
		xyz50: convertXyz50ToProphoto_default,
		rgb: (color) => convertXyz50ToProphoto_default(convertRgbToXyz50_default(color))
	},
	toMode: {
		xyz50: convertProphotoToXyz50_default,
		rgb: (color) => convertXyz50ToRgb_default(convertProphotoToXyz50_default(color))
	}
};
var definition_default$10 = definition$14;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rec2020/convertXyz65ToRec2020.js
const $1 = 1.09929682680944;
const $1 = .018053968510807;
const gamma = (v) => {
	const abs$1 = Math.abs(v);
	if (abs$1 > $1) return (Math.sign(v) || 1) * ($1 * Math.pow(abs$1, .45) - ($1 - 1));
	return 4.5 * v;
};
const convertXyz65ToRec2020 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "rec2020",
		r: gamma(x * 1.7166511879712683 - y * .3556707837763925 - .2533662813736599 * z),
		g: gamma(x * -.6666843518324893 + y * 1.6164812366349395 + .0157685458139111 * z),
		b: gamma(x * .0176398574453108 - y * .0427706132578085 + .9421031212354739 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToRec2020_default = convertXyz65ToRec2020;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rec2020/convertRec2020ToXyz65.js
const  = 1.09929682680944;
const  = .018053968510807;
const linearize = (v = 0) => {
	let abs$1 = Math.abs(v);
	if (abs$1 <  * 4.5) return v / 4.5;
	return (Math.sign(v) || 1) * Math.pow((abs$1 +  - 1) / , 1 / .45);
};
const convertRec2020ToXyz65 = (rec2020$2) => {
	let r$1 = linearize(rec2020$2.r);
	let g = linearize(rec2020$2.g);
	let b = linearize(rec2020$2.b);
	let res = {
		mode: "xyz65",
		x: .6369580483012911 * r$1 + .1446169035862083 * g + .1688809751641721 * b,
		y: .262700212011267 * r$1 + .6779980715188708 * g + .059301716469862 * b,
		z: 0 * r$1 + .0280726930490874 * g + 1.0609850577107909 * b
	};
	if (rec2020$2.alpha !== void 0) res.alpha = rec2020$2.alpha;
	return res;
};
var convertRec2020ToXyz65_default = convertRec2020ToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/rec2020/definition.js
const definition$13 = {
	...definition_default$12,
	mode: "rec2020",
	fromMode: {
		xyz65: convertXyz65ToRec2020_default,
		rgb: (color) => convertXyz65ToRec2020_default(convertRgbToXyz65_default(color))
	},
	toMode: {
		xyz65: convertRec2020ToXyz65_default,
		rgb: (color) => convertXyz65ToRgb_default(convertRec2020ToXyz65_default(color))
	},
	parse: ["rec2020"],
	serialize: "rec2020"
};
var definition_default$11 = definition$13;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz50/definition.js
const definition$12 = {
	mode: "xyz50",
	parse: ["xyz-d50"],
	serialize: "xyz-d50",
	toMode: {
		rgb: convertXyz50ToRgb_default,
		lab: convertXyz50ToLab_default
	},
	fromMode: {
		rgb: convertRgbToXyz50_default,
		lab: convertLabToXyz50_default
	},
	channels: [
		"x",
		"y",
		"z",
		"alpha"
	],
	ranges: {
		x: [0, .964],
		y: [0, .999],
		z: [0, .825]
	},
	interpolate: {
		x: interpolatorLinear,
		y: interpolatorLinear,
		z: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$13 = definition$12;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/convertXyz65ToXyz50.js
const convertXyz65ToXyz50 = (xyz65$2) => {
	let { x, y, z, alpha } = xyz65$2;
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "xyz50",
		x: 1.0479298208405488 * x + .0229467933410191 * y - .0501922295431356 * z,
		y: .0296278156881593 * x + .990434484573249 * y - .0170738250293851 * z,
		z: -.0092430581525912 * x + .0150551448965779 * y + .7518742899580008 * z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToXyz50_default = convertXyz65ToXyz50;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/convertXyz50ToXyz65.js
const convertXyz50ToXyz65 = (xyz50$2) => {
	let { x, y, z, alpha } = xyz50$2;
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "xyz65",
		x: .9554734527042182 * x - .0230985368742614 * y + .0632593086610217 * z,
		y: -.0283697069632081 * x + 1.0099954580058226 * y + .021041398966943 * z,
		z: .0123140016883199 * x - .0205076964334779 * y + 1.3303659366080753 * z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToXyz65_default = convertXyz50ToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyz65/definition.js
const definition$11 = {
	mode: "xyz65",
	toMode: {
		rgb: convertXyz65ToRgb_default,
		xyz50: convertXyz65ToXyz50_default
	},
	fromMode: {
		rgb: convertRgbToXyz65_default,
		xyz50: convertXyz50ToXyz65_default
	},
	ranges: {
		x: [0, .95],
		y: [0, 1],
		z: [0, 1.088]
	},
	channels: [
		"x",
		"y",
		"z",
		"alpha"
	],
	parse: ["xyz", "xyz-d65"],
	serialize: "xyz-d65",
	interpolate: {
		x: interpolatorLinear,
		y: interpolatorLinear,
		z: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$14 = definition$11;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/bootstrap/css.js
const a98$1 = useMode(definition_default);
const hsl$2 = useMode(definition_default$1);
const hsv$1 = useMode(definition_default$19);
const hwb$1 = useMode(definition_default$2);
const lab$1 = useMode(definition_default$3);
const lab65$1 = useMode(definition_default$4);
const lch$1 = useMode(definition_default$5);
const lch65$1 = useMode(definition_default$23);
const lrgb$1 = useMode(definition_default$6);
const oklab$1 = useMode(definition_default$7);
const oklch$1 = useMode(definition_default$8);
const p3$1 = useMode(definition_default$9);
const prophoto$1 = useMode(definition_default$10);
const rec2020$1 = useMode(definition_default$11);
const rgb$3 = useMode(definition_default$12);
const xyz50$1 = useMode(definition_default$13);
const xyz65$1 = useMode(definition_default$14);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/cubehelix/constants.js
const M = [
	-.14861,
	1.78277,
	-.29227,
	-.90649,
	1.97294,
	0
];
const degToRad = Math.PI / 180;
const radToDeg = 180 / Math.PI;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/cubehelix/convertRgbToCubehelix.js
let DE = M[3] * M[4];
let BE = M[1] * M[4];
let BCAD = M[1] * M[2] - M[0] * M[3];
const convertRgbToCubehelix = ({ r: r$1, g, b, alpha }) => {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let l = (BCAD * b + r$1 * DE - g * BE) / (BCAD + DE - BE);
	let x = b - l;
	let y = (M[4] * (g - l) - M[2] * x) / M[3];
	let res = {
		mode: "cubehelix",
		l,
		s: l === 0 || l === 1 ? void 0 : Math.sqrt(x * x + y * y) / (M[4] * l * (1 - l))
	};
	if (res.s) res.h = Math.atan2(y, x) * radToDeg - 120;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToCubehelix_default = convertRgbToCubehelix;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/cubehelix/convertCubehelixToRgb.js
const convertCubehelixToRgb = ({ h, s, l, alpha }) => {
	let res = { mode: "rgb" };
	h = (h === void 0 ? 0 : h + 120) * degToRad;
	if (l === void 0) l = 0;
	let amp = s === void 0 ? 0 : s * l * (1 - l);
	let cosh = Math.cos(h);
	let sinh = Math.sin(h);
	res.r = l + amp * (M[0] * cosh + M[1] * sinh);
	res.g = l + amp * (M[2] * cosh + M[3] * sinh);
	res.b = l + amp * (M[4] * cosh + M[5] * sinh);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertCubehelixToRgb_default = convertCubehelixToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/cubehelix/definition.js
const definition$10 = {
	mode: "cubehelix",
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	parse: ["--cubehelix"],
	serialize: "--cubehelix",
	ranges: {
		h: [0, 360],
		s: [0, 4.614],
		l: [0, 1]
	},
	fromMode: { rgb: convertRgbToCubehelix_default },
	toMode: { rgb: convertCubehelixToRgb_default },
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$15 = definition$10;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/dlch/constants.js
const kE = 1;
const kCH = 1;
const  = 26 / 180 * Math.PI;
const cos = Math.cos();
const sin = Math.sin();
const factor = 100 / Math.log(139 / 100);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/dlch/convertDlchToLab65.js
const convertDlchToLab65 = ({ l, c: c$1, h, alpha }) => {
	if (l === void 0) l = 0;
	if (c$1 === void 0) c$1 = 0;
	if (h === void 0) h = 0;
	let res = {
		mode: "lab65",
		l: (Math.exp(l * kE / factor) - 1) / .0039
	};
	let G = (Math.exp(.0435 * c$1 * kCH * kE) - 1) / .075;
	let e$3 = G * Math.cos(h / 180 * Math.PI - );
	let f$2 = G * Math.sin(h / 180 * Math.PI - );
	res.a = e$3 * cos - f$2 / .83 * sin;
	res.b = e$3 * sin + f$2 / .83 * cos;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertDlchToLab65_default = convertDlchToLab65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/dlch/convertLab65ToDlch.js
const convertLab65ToDlch = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let e$3 = a * cos + b * sin;
	let f$2 = .83 * (b * cos - a * sin);
	let G = Math.sqrt(e$3 * e$3 + f$2 * f$2);
	let res = {
		mode: "dlch",
		l: factor / kE * Math.log(1 + .0039 * l),
		c: Math.log(1 + .075 * G) / (.0435 * kCH * kE)
	};
	if (res.c) res.h = normalizeHue_default((Math.atan2(f$2, e$3) + ) / Math.PI * 180);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLab65ToDlch_default = convertLab65ToDlch;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/dlab/definition.js
const convertDlabToLab65 = (c$1) => convertDlchToLab65_default(convertLabToLch_default(c$1, "dlch"));
const convertLab65ToDlab = (c$1) => convertLchToLab_default(convertLab65ToDlch_default(c$1), "dlab");
const definition$9 = {
	mode: "dlab",
	parse: ["--din99o-lab"],
	serialize: "--din99o-lab",
	toMode: {
		lab65: convertDlabToLab65,
		rgb: (c$1) => convertLab65ToRgb_default(convertDlabToLab65(c$1))
	},
	fromMode: {
		lab65: convertLab65ToDlab,
		rgb: (c$1) => convertLab65ToDlab(convertRgbToLab65_default(c$1))
	},
	channels: [
		"l",
		"a",
		"b",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		a: [-40.09, 45.501],
		b: [-40.469, 44.344]
	},
	interpolate: {
		l: interpolatorLinear,
		a: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$16 = definition$9;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/dlch/definition.js
const definition$8 = {
	mode: "dlch",
	parse: ["--din99o-lch"],
	serialize: "--din99o-lch",
	toMode: {
		lab65: convertDlchToLab65_default,
		dlab: (c$1) => convertLchToLab_default(c$1, "dlab"),
		rgb: (c$1) => convertLab65ToRgb_default(convertDlchToLab65_default(c$1))
	},
	fromMode: {
		lab65: convertLab65ToDlch_default,
		dlab: (c$1) => convertLabToLch_default(c$1, "dlch"),
		rgb: (c$1) => convertLab65ToDlch_default(convertRgbToLab65_default(c$1))
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		c: [0, 51.484],
		h: [0, 360]
	},
	interpolate: {
		l: interpolatorLinear,
		c: interpolatorLinear,
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$17 = definition$8;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsi/convertHsiToRgb.js
function convertHsiToRgb({ h, s, i, alpha }) {
	h = normalizeHue_default(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (i === void 0) i = 0;
	let f$2 = Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: i * (1 + s * (3 / (2 - f$2) - 1)),
				g: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1)),
				b: i * (1 - s)
			};
			break;
		case 1:
			res = {
				r: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1)),
				g: i * (1 + s * (3 / (2 - f$2) - 1)),
				b: i * (1 - s)
			};
			break;
		case 2:
			res = {
				r: i * (1 - s),
				g: i * (1 + s * (3 / (2 - f$2) - 1)),
				b: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1))
			};
			break;
		case 3:
			res = {
				r: i * (1 - s),
				g: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1)),
				b: i * (1 + s * (3 / (2 - f$2) - 1))
			};
			break;
		case 4:
			res = {
				r: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1)),
				g: i * (1 - s),
				b: i * (1 + s * (3 / (2 - f$2) - 1))
			};
			break;
		case 5:
			res = {
				r: i * (1 + s * (3 / (2 - f$2) - 1)),
				g: i * (1 - s),
				b: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1))
			};
			break;
		default: res = {
			r: i * (1 - s),
			g: i * (1 - s),
			b: i * (1 - s)
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsi/convertRgbToHsi.js
function convertRgbToHsi({ r: r$1, g, b, alpha }) {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$1 = Math.max(r$1, g, b), m = Math.min(r$1, g, b);
	let res = {
		mode: "hsi",
		s: r$1 + g + b === 0 ? 0 : 1 - 3 * m / (r$1 + g + b),
		i: (r$1 + g + b) / 3
	};
	if (M$1 - m !== 0) res.h = (M$1 === r$1 ? (g - b) / (M$1 - m) + (g < b) * 6 : M$1 === g ? (b - r$1) / (M$1 - m) + 2 : (r$1 - g) / (M$1 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hsi/definition.js
const definition$7 = {
	mode: "hsi",
	toMode: { rgb: convertHsiToRgb },
	parse: ["--hsi"],
	serialize: "--hsi",
	fromMode: { rgb: convertRgbToHsi },
	channels: [
		"h",
		"s",
		"i",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		i: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$18 = definition$7;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hdr/constants.js
const YW = 203;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/hdr/transfer.js
const M1 = .1593017578125;
const M2 = 78.84375;
const C1 = .8359375;
const C2 = 18.8515625;
const C3 = 18.6875;
function transferPqDecode(v) {
	if (v < 0) return 0;
	const c$1 = Math.pow(v, 1 / M2);
	return 1e4 * Math.pow(Math.max(0, c$1 - C1) / (C2 - C3 * c$1), 1 / M1);
}
function transferPqEncode(v) {
	if (v < 0) return 0;
	const c$1 = Math.pow(v / 1e4, M1);
	return Math.pow((C1 + C2 * c$1) / (1 + C3 * c$1), M2);
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/itp/convertItpToXyz65.js
const toRel = (c$1) => Math.max(c$1 / YW, 0);
const convertItpToXyz65 = ({ i, t, p: p$2, alpha }) => {
	if (i === void 0) i = 0;
	if (t === void 0) t = 0;
	if (p$2 === void 0) p$2 = 0;
	const l = transferPqDecode(i + .008609037037932761 * t + .11102962500302593 * p$2);
	const m = transferPqDecode(i - .00860903703793275 * t - .11102962500302599 * p$2);
	const s = transferPqDecode(i + .5600313357106791 * t - .32062717498731885 * p$2);
	const res = {
		mode: "xyz65",
		x: toRel(2.070152218389422 * l - 1.3263473389671556 * m + .2066510476294051 * s),
		y: toRel(.3647385209748074 * l + .680566024947227 * m - .0453045459220346 * s),
		z: toRel(-.049747207535812 * l - .0492609666966138 * m + 1.1880659249923042 * s)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertItpToXyz65_default = convertItpToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/itp/convertXyz65ToItp.js
const toAbs = (c$1 = 0) => Math.max(c$1 * YW, 0);
const convertXyz65ToItp = ({ x, y, z, alpha }) => {
	const absX = toAbs(x);
	const absY = toAbs(y);
	const absZ = toAbs(z);
	const l = transferPqEncode(.3592832590121217 * absX + .6976051147779502 * absY - .0358915932320289 * absZ);
	const m = transferPqEncode(-.1920808463704995 * absX + 1.1004767970374323 * absY + .0753748658519118 * absZ);
	const s = transferPqEncode(.0070797844607477 * absX + .0748396662186366 * absY + .8433265453898765 * absZ);
	const i = .5 * l + .5 * m;
	const t = 1.61376953125 * l - 3.323486328125 * m + 1.709716796875 * s;
	const p$2 = 4.378173828125 * l - 4.24560546875 * m - .132568359375 * s;
	const res = {
		mode: "itp",
		i,
		t,
		p: p$2
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToItp_default = convertXyz65ToItp;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/itp/definition.js
const definition$6 = {
	mode: "itp",
	channels: [
		"i",
		"t",
		"p",
		"alpha"
	],
	parse: ["--ictcp"],
	serialize: "--ictcp",
	toMode: {
		xyz65: convertItpToXyz65_default,
		rgb: (color) => convertXyz65ToRgb_default(convertItpToXyz65_default(color))
	},
	fromMode: {
		xyz65: convertXyz65ToItp_default,
		rgb: (color) => convertXyz65ToItp_default(convertRgbToXyz65_default(color))
	},
	ranges: {
		i: [0, .581],
		t: [-.369, .272],
		p: [-.164, .331]
	},
	interpolate: {
		i: interpolatorLinear,
		t: interpolatorLinear,
		p: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$20 = definition$6;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jab/convertXyz65ToJab.js
const p$1 = 134.03437499999998;
const d0$1 = 16295499532821565e-27;
const jabPqEncode = (v) => {
	if (v < 0) return 0;
	let vn$2 = Math.pow(v / 1e4, M1);
	return Math.pow((C1 + C2 * vn$2) / (1 + C3 * vn$2), p$1);
};
const abs = (v = 0) => Math.max(v * 203, 0);
const convertXyz65ToJab = ({ x, y, z, alpha }) => {
	x = abs(x);
	y = abs(y);
	z = abs(z);
	let xp = 1.15 * x - .15 * z;
	let yp = .66 * y + .34 * x;
	let l = jabPqEncode(.41478972 * xp + .579999 * yp + .014648 * z);
	let m = jabPqEncode(-.20151 * xp + 1.120649 * yp + .0531008 * z);
	let s = jabPqEncode(-.0166008 * xp + .2648 * yp + .6684799 * z);
	let i = (l + m) / 2;
	let res = {
		mode: "jab",
		j: .44 * i / (1 - .56 * i) - d0$1,
		a: 3.524 * l - 4.066708 * m + .542708 * s,
		b: .199076 * l + 1.096799 * m - 1.295875 * s
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToJab_default = convertXyz65ToJab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jab/convertJabToXyz65.js
const p = 134.03437499999998;
const d0 = 16295499532821565e-27;
const jabPqDecode = (v) => {
	if (v < 0) return 0;
	let vp = Math.pow(v, 1 / p);
	return 1e4 * Math.pow((C1 - vp) / (C3 * vp - C2), 1 / M1);
};
const rel = (v) => v / 203;
const convertJabToXyz65 = ({ j, a, b, alpha }) => {
	if (j === void 0) j = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let i = (j + d0) / (.44 + .56 * (j + d0));
	let l = jabPqDecode(i + .13860504 * a + .058047316 * b);
	let m = jabPqDecode(i - .13860504 * a - .058047316 * b);
	let s = jabPqDecode(i - .096019242 * a - .8118919 * b);
	let res = {
		mode: "xyz65",
		x: rel(1.661373024652174 * l - .914523081304348 * m + .23136208173913045 * s),
		y: rel(-.3250758611844533 * l + 1.571847026732543 * m - .21825383453227928 * s),
		z: rel(-.090982811 * l - .31272829 * m + 1.5227666 * s)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJabToXyz65_default = convertJabToXyz65;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jab/convertRgbToJab.js
const convertRgbToJab = (rgb$4) => {
	let res = convertXyz65ToJab_default(convertRgbToXyz65_default(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToJab_default = convertRgbToJab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jab/convertJabToRgb.js
const convertJabToRgb = (color) => convertXyz65ToRgb_default(convertJabToXyz65_default(color));
var convertJabToRgb_default = convertJabToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jab/definition.js
const definition$5 = {
	mode: "jab",
	channels: [
		"j",
		"a",
		"b",
		"alpha"
	],
	parse: ["--jzazbz"],
	serialize: "--jzazbz",
	fromMode: {
		rgb: convertRgbToJab_default,
		xyz65: convertXyz65ToJab_default
	},
	toMode: {
		rgb: convertJabToRgb_default,
		xyz65: convertJabToXyz65_default
	},
	ranges: {
		j: [0, .222],
		a: [-.109, .129],
		b: [-.185, .134]
	},
	interpolate: {
		j: interpolatorLinear,
		a: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$21 = definition$5;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jch/convertJabToJch.js
const convertJabToJch = ({ j, a, b, alpha }) => {
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let c$1 = Math.sqrt(a * a + b * b);
	let res = {
		mode: "jch",
		j,
		c: c$1
	};
	if (c$1) res.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJabToJch_default = convertJabToJch;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jch/convertJchToJab.js
const convertJchToJab = ({ j, c: c$1, h, alpha }) => {
	if (h === void 0) h = 0;
	let res = {
		mode: "jab",
		j,
		a: c$1 ? c$1 * Math.cos(h / 180 * Math.PI) : 0,
		b: c$1 ? c$1 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJchToJab_default = convertJchToJab;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/jch/definition.js
const definition$4 = {
	mode: "jch",
	parse: ["--jzczhz"],
	serialize: "--jzczhz",
	toMode: {
		jab: convertJchToJab_default,
		rgb: (c$1) => convertJabToRgb_default(convertJchToJab_default(c$1))
	},
	fromMode: {
		rgb: (c$1) => convertJabToJch_default(convertRgbToJab_default(c$1)),
		jab: convertJabToJch_default
	},
	channels: [
		"j",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		j: [0, .221],
		c: [0, .19],
		h: [0, 360]
	},
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		c: interpolatorLinear,
		j: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$22 = definition$4;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lchuv/convertLuvToLchuv.js
const convertLuvToLchuv = ({ l, u, v, alpha }) => {
	if (u === void 0) u = 0;
	if (v === void 0) v = 0;
	let c$1 = Math.sqrt(u * u + v * v);
	let res = {
		mode: "lchuv",
		l,
		c: c$1
	};
	if (c$1) res.h = normalizeHue_default(Math.atan2(v, u) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLuvToLchuv_default = convertLuvToLchuv;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lchuv/convertLchuvToLuv.js
const convertLchuvToLuv = ({ l, c: c$1, h, alpha }) => {
	if (h === void 0) h = 0;
	let res = {
		mode: "luv",
		l,
		u: c$1 ? c$1 * Math.cos(h / 180 * Math.PI) : 0,
		v: c$1 ? c$1 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLchuvToLuv_default = convertLchuvToLuv;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/luv/convertXyz50ToLuv.js
const u_fn$1 = (x, y, z) => 4 * x / (x + 15 * y + 3 * z);
const v_fn$1 = (x, y, z) => 9 * y / (x + 15 * y + 3 * z);
const un$1 = u_fn$1(D50.X, D50.Y, D50.Z);
const vn$1 = v_fn$1(D50.X, D50.Y, D50.Z);
const l_fn = (value) => value <= e ? k * value : 116 * Math.cbrt(value) - 16;
const convertXyz50ToLuv = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let l = l_fn(y / D50.Y);
	let u = u_fn$1(x, y, z);
	let v = v_fn$1(x, y, z);
	if (!isFinite(u) || !isFinite(v)) l = u = v = 0;
	else {
		u = 13 * l * (u - un$1);
		v = 13 * l * (v - vn$1);
	}
	let res = {
		mode: "luv",
		l,
		u,
		v
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToLuv_default = convertXyz50ToLuv;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/luv/convertLuvToXyz50.js
const u_fn = (x, y, z) => 4 * x / (x + 15 * y + 3 * z);
const v_fn = (x, y, z) => 9 * y / (x + 15 * y + 3 * z);
const un = u_fn(D50.X, D50.Y, D50.Z);
const vn = v_fn(D50.X, D50.Y, D50.Z);
const convertLuvToXyz50 = ({ l, u, v, alpha }) => {
	if (l === void 0) l = 0;
	if (l === 0) return {
		mode: "xyz50",
		x: 0,
		y: 0,
		z: 0
	};
	if (u === void 0) u = 0;
	if (v === void 0) v = 0;
	let up = u / (13 * l) + un;
	let vp = v / (13 * l) + vn;
	let y = D50.Y * (l <= 8 ? l / k : Math.pow((l + 16) / 116, 3));
	let x = y * (9 * up) / (4 * vp);
	let z = y * (12 - 3 * up - 20 * vp) / (4 * vp);
	let res = {
		mode: "xyz50",
		x,
		y,
		z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLuvToXyz50_default = convertLuvToXyz50;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/lchuv/definition.js
const convertRgbToLchuv = (rgb$4) => convertLuvToLchuv_default(convertXyz50ToLuv_default(convertRgbToXyz50_default(rgb$4)));
const convertLchuvToRgb = (lchuv$1) => convertXyz50ToRgb_default(convertLuvToXyz50_default(convertLchuvToLuv_default(lchuv$1)));
const definition$3 = {
	mode: "lchuv",
	toMode: {
		luv: convertLchuvToLuv_default,
		rgb: convertLchuvToRgb
	},
	fromMode: {
		rgb: convertRgbToLchuv,
		luv: convertLuvToLchuv_default
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	parse: ["--lchuv"],
	serialize: "--lchuv",
	ranges: {
		l: [0, 100],
		c: [0, 176.956],
		h: [0, 360]
	},
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		c: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$24 = definition$3;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/luv/definition.js
const definition$2 = {
	mode: "luv",
	toMode: {
		xyz50: convertLuvToXyz50_default,
		rgb: (luv$1) => convertXyz50ToRgb_default(convertLuvToXyz50_default(luv$1))
	},
	fromMode: {
		xyz50: convertXyz50ToLuv_default,
		rgb: (rgb$4) => convertXyz50ToLuv_default(convertRgbToXyz50_default(rgb$4))
	},
	channels: [
		"l",
		"u",
		"v",
		"alpha"
	],
	parse: ["--luv"],
	serialize: "--luv",
	ranges: {
		l: [0, 100],
		u: [-84.936, 175.042],
		v: [-125.882, 87.243]
	},
	interpolate: {
		l: interpolatorLinear,
		u: interpolatorLinear,
		v: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$25 = definition$2;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsl/helpers.js
function toe(x) {
	const k_1 = .206;
	const k_2 = .03;
	const k_3 = (1 + k_1) / (1 + k_2);
	return .5 * (k_3 * x - k_1 + Math.sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4 * k_2 * k_3 * x));
}
function toe_inv(x) {
	const k_1 = .206;
	const k_2 = .03;
	const k_3 = (1 + k_1) / (1 + k_2);
	return (x * x + k_1 * x) / (k_3 * (x + k_2));
}
function compute_max_saturation(a, b) {
	let k0, k1, k2, k3, k4, wl, wm, ws;
	if (-1.88170328 * a - .80936493 * b > 1) {
		k0 = 1.19086277;
		k1 = 1.76576728;
		k2 = .59662641;
		k3 = .75515197;
		k4 = .56771245;
		wl = 4.0767416621;
		wm = -3.3077115913;
		ws = .2309699292;
	} else if (1.81444104 * a - 1.19445276 * b > 1) {
		k0 = .73956515;
		k1 = -.45954404;
		k2 = .08285427;
		k3 = .1254107;
		k4 = .14503204;
		wl = -1.2684380046;
		wm = 2.6097574011;
		ws = -.3413193965;
	} else {
		k0 = 1.35733652;
		k1 = -.00915799;
		k2 = -1.1513021;
		k3 = -.50559606;
		k4 = .00692167;
		wl = -.0041960863;
		wm = -.7034186147;
		ws = 1.707614701;
	}
	let S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;
	let k_l = .3963377774 * a + .2158037573 * b;
	let k_m = -.1055613458 * a - .0638541728 * b;
	let k_s = -.0894841775 * a - 1.291485548 * b;
	{
		let l_ = 1 + S * k_l;
		let m_ = 1 + S * k_m;
		let s_ = 1 + S * k_s;
		let l = l_ * l_ * l_;
		let m = m_ * m_ * m_;
		let s = s_ * s_ * s_;
		let l_dS = 3 * k_l * l_ * l_;
		let m_dS = 3 * k_m * m_ * m_;
		let s_dS = 3 * k_s * s_ * s_;
		let l_dS2 = 6 * k_l * k_l * l_;
		let m_dS2 = 6 * k_m * k_m * m_;
		let s_dS2 = 6 * k_s * k_s * s_;
		let f$2 = wl * l + wm * m + ws * s;
		let f1 = wl * l_dS + wm * m_dS + ws * s_dS;
		let f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;
		S = S - f$2 * f1 / (f1 * f1 - .5 * f$2 * f2);
	}
	return S;
}
function find_cusp(a, b) {
	let S_cusp = compute_max_saturation(a, b);
	let rgb$4 = convertOklabToLrgb_default({
		l: 1,
		a: S_cusp * a,
		b: S_cusp * b
	});
	let L_cusp = Math.cbrt(1 / Math.max(rgb$4.r, rgb$4.g, rgb$4.b));
	let C_cusp = L_cusp * S_cusp;
	return [L_cusp, C_cusp];
}
function find_gamut_intersection(a, b, L1, C1$1, L0, cusp = null) {
	if (!cusp) cusp = find_cusp(a, b);
	let t;
	if ((L1 - L0) * cusp[1] - (cusp[0] - L0) * C1$1 <= 0) t = cusp[1] * L0 / (C1$1 * cusp[0] + cusp[1] * (L0 - L1));
	else {
		t = cusp[1] * (L0 - 1) / (C1$1 * (cusp[0] - 1) + cusp[1] * (L0 - L1));
		{
			let dL = L1 - L0;
			let dC = C1$1;
			let k_l = .3963377774 * a + .2158037573 * b;
			let k_m = -.1055613458 * a - .0638541728 * b;
			let k_s = -.0894841775 * a - 1.291485548 * b;
			let l_dt = dL + dC * k_l;
			let m_dt = dL + dC * k_m;
			let s_dt = dL + dC * k_s;
			{
				let L = L0 * (1 - t) + t * L1;
				let C = t * C1$1;
				let l_ = L + C * k_l;
				let m_ = L + C * k_m;
				let s_ = L + C * k_s;
				let l = l_ * l_ * l_;
				let m = m_ * m_ * m_;
				let s = s_ * s_ * s_;
				let ldt = 3 * l_dt * l_ * l_;
				let mdt = 3 * m_dt * m_ * m_;
				let sdt = 3 * s_dt * s_ * s_;
				let ldt2 = 6 * l_dt * l_dt * l_;
				let mdt2 = 6 * m_dt * m_dt * m_;
				let sdt2 = 6 * s_dt * s_dt * s_;
				let r$1 = 4.0767416621 * l - 3.3077115913 * m + .2309699292 * s - 1;
				let r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + .2309699292 * sdt;
				let r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + .2309699292 * sdt2;
				let u_r = r1 / (r1 * r1 - .5 * r$1 * r2);
				let t_r = -r$1 * u_r;
				let g = -1.2684380046 * l + 2.6097574011 * m - .3413193965 * s - 1;
				let g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - .3413193965 * sdt;
				let g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - .3413193965 * sdt2;
				let u_g = g1 / (g1 * g1 - .5 * g * g2);
				let t_g = -g * u_g;
				let b$1 = -.0041960863 * l - .7034186147 * m + 1.707614701 * s - 1;
				let b1 = -.0041960863 * ldt - .7034186147 * mdt + 1.707614701 * sdt;
				let b2 = -.0041960863 * ldt2 - .7034186147 * mdt2 + 1.707614701 * sdt2;
				let u_b = b1 / (b1 * b1 - .5 * b$1 * b2);
				let t_b = -b$1 * u_b;
				t_r = u_r >= 0 ? t_r : 1e6;
				t_g = u_g >= 0 ? t_g : 1e6;
				t_b = u_b >= 0 ? t_b : 1e6;
				t += Math.min(t_r, Math.min(t_g, t_b));
			}
		}
	}
	return t;
}
function get_ST_max(a_, b_, cusp = null) {
	if (!cusp) cusp = find_cusp(a_, b_);
	let L = cusp[0];
	let C = cusp[1];
	return [C / L, C / (1 - L)];
}
function get_Cs(L, a_, b_) {
	let cusp = find_cusp(a_, b_);
	let C_max = find_gamut_intersection(a_, b_, L, 1, L, cusp);
	let ST_max = get_ST_max(a_, b_, cusp);
	let S_mid = .11516993 + 1 / (7.4477897 + 4.1590124 * b_ + a_ * (-2.19557347 + 1.75198401 * b_ + a_ * (-2.13704948 - 10.02301043 * b_ + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_))));
	let T_mid = .11239642 + 1 / (1.6132032 - .68124379 * b_ + a_ * (.40370612 + .90148123 * b_ + a_ * (-.27087943 + .6122399 * b_ + a_ * (.00299215 - .45399568 * b_ - .14661872 * a_))));
	let k$3 = C_max / Math.min(L * ST_max[0], (1 - L) * ST_max[1]);
	let C_a = L * S_mid;
	let C_b = (1 - L) * T_mid;
	let C_mid = .9 * k$3 * Math.sqrt(Math.sqrt(1 / (1 / (C_a * C_a * C_a * C_a) + 1 / (C_b * C_b * C_b * C_b))));
	C_a = L * .4;
	C_b = (1 - L) * .8;
	return [
		Math.sqrt(1 / (1 / (C_a * C_a) + 1 / (C_b * C_b))),
		C_mid,
		C_max
	];
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsl/convertOklabToOkhsl.js
function convertOklabToOkhsl(lab$2) {
	const l = lab$2.l !== void 0 ? lab$2.l : 0;
	const a = lab$2.a !== void 0 ? lab$2.a : 0;
	const b = lab$2.b !== void 0 ? lab$2.b : 0;
	const ret = {
		mode: "okhsl",
		l: toe(l)
	};
	if (lab$2.alpha !== void 0) ret.alpha = lab$2.alpha;
	let c$1 = Math.sqrt(a * a + b * b);
	if (!c$1) {
		ret.s = 0;
		return ret;
	}
	let [C_0, C_mid, C_max] = get_Cs(l, a / c$1, b / c$1);
	let s;
	if (c$1 < C_mid) {
		let k_0 = 0;
		let k_1 = .8 * C_0;
		let k_2 = 1 - k_1 / C_mid;
		s = (c$1 - k_0) / (k_1 + k_2 * (c$1 - k_0)) * .8;
	} else {
		let k_0 = C_mid;
		let k_1 = .2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
		let k_2 = 1 - k_1 / (C_max - C_mid);
		s = .8 + .2 * ((c$1 - k_0) / (k_1 + k_2 * (c$1 - k_0)));
	}
	if (s) {
		ret.s = s;
		ret.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	}
	return ret;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsl/convertOkhslToOklab.js
function convertOkhslToOklab(hsl$3) {
	let h = hsl$3.h !== void 0 ? hsl$3.h : 0;
	let s = hsl$3.s !== void 0 ? hsl$3.s : 0;
	let l = hsl$3.l !== void 0 ? hsl$3.l : 0;
	const ret = {
		mode: "oklab",
		l: toe_inv(l)
	};
	if (hsl$3.alpha !== void 0) ret.alpha = hsl$3.alpha;
	if (!s || l === 1) {
		ret.a = ret.b = 0;
		return ret;
	}
	let a_ = Math.cos(h / 180 * Math.PI);
	let b_ = Math.sin(h / 180 * Math.PI);
	let [C_0, C_mid, C_max] = get_Cs(ret.l, a_, b_);
	let t, k_0, k_1, k_2;
	if (s < .8) {
		t = 1.25 * s;
		k_0 = 0;
		k_1 = .8 * C_0;
		k_2 = 1 - k_1 / C_mid;
	} else {
		t = 5 * (s - .8);
		k_0 = C_mid;
		k_1 = .2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
		k_2 = 1 - k_1 / (C_max - C_mid);
	}
	let C = k_0 + t * k_1 / (1 - k_2 * t);
	ret.a = C * a_;
	ret.b = C * b_;
	return ret;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsl/modeOkhsl.js
const modeOkhsl = {
	...definition_default$1,
	mode: "okhsl",
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	parse: ["--okhsl"],
	serialize: "--okhsl",
	fromMode: {
		oklab: convertOklabToOkhsl,
		rgb: (c$1) => convertOklabToOkhsl(convertRgbToOklab_default(c$1))
	},
	toMode: {
		oklab: convertOkhslToOklab,
		rgb: (c$1) => convertOklabToRgb_default(convertOkhslToOklab(c$1))
	}
};
var modeOkhsl_default = modeOkhsl;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsv/convertOklabToOkhsv.js
function convertOklabToOkhsv(lab$2) {
	let l = lab$2.l !== void 0 ? lab$2.l : 0;
	let a = lab$2.a !== void 0 ? lab$2.a : 0;
	let b = lab$2.b !== void 0 ? lab$2.b : 0;
	let c$1 = Math.sqrt(a * a + b * b);
	let a_ = c$1 ? a / c$1 : 1;
	let b_ = c$1 ? b / c$1 : 1;
	let [S_max, T] = get_ST_max(a_, b_);
	let S_0 = .5;
	let k$3 = 1 - S_0 / S_max;
	let t = T / (c$1 + l * T);
	let L_v = t * l;
	let C_v = t * c$1;
	let L_vt = toe_inv(L_v);
	let C_vt = C_v * L_vt / L_v;
	let rgb_scale = convertOklabToLrgb_default({
		l: L_vt,
		a: a_ * C_vt,
		b: b_ * C_vt
	});
	let scale_L = Math.cbrt(1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0));
	l = l / scale_L;
	c$1 = c$1 / scale_L * toe(l) / l;
	l = toe(l);
	const ret = {
		mode: "okhsv",
		s: c$1 ? (S_0 + T) * C_v / (T * S_0 + T * k$3 * C_v) : 0,
		v: l ? l / L_v : 0
	};
	if (ret.s) ret.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	if (lab$2.alpha !== void 0) ret.alpha = lab$2.alpha;
	return ret;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsv/convertOkhsvToOklab.js
function convertOkhsvToOklab(hsv$2) {
	const ret = { mode: "oklab" };
	if (hsv$2.alpha !== void 0) ret.alpha = hsv$2.alpha;
	const h = hsv$2.h !== void 0 ? hsv$2.h : 0;
	const s = hsv$2.s !== void 0 ? hsv$2.s : 0;
	const v = hsv$2.v !== void 0 ? hsv$2.v : 0;
	const a_ = Math.cos(h / 180 * Math.PI);
	const b_ = Math.sin(h / 180 * Math.PI);
	const [S_max, T] = get_ST_max(a_, b_);
	const S_0 = .5;
	const k$3 = 1 - S_0 / S_max;
	const L_v = 1 - s * S_0 / (S_0 + T - T * k$3 * s);
	const C_v = s * T * S_0 / (S_0 + T - T * k$3 * s);
	const L_vt = toe_inv(L_v);
	const C_vt = C_v * L_vt / L_v;
	const rgb_scale = convertOklabToLrgb_default({
		l: L_vt,
		a: a_ * C_vt,
		b: b_ * C_vt
	});
	const scale_L = Math.cbrt(1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0));
	const L_new = toe_inv(v * L_v);
	const C = C_v * L_new / L_v;
	ret.l = L_new * scale_L;
	ret.a = C * a_ * scale_L;
	ret.b = C * b_ * scale_L;
	return ret;
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/okhsv/modeOkhsv.js
const modeOkhsv = {
	...definition_default$19,
	mode: "okhsv",
	channels: [
		"h",
		"s",
		"v",
		"alpha"
	],
	parse: ["--okhsv"],
	serialize: "--okhsv",
	fromMode: {
		oklab: convertOklabToOkhsv,
		rgb: (c$1) => convertOklabToOkhsv(convertRgbToOklab_default(c$1))
	},
	toMode: {
		oklab: convertOkhsvToOklab,
		rgb: (c$1) => convertOklabToRgb_default(convertOkhsvToOklab(c$1))
	}
};
var modeOkhsv_default = modeOkhsv;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyb/constants.js
const bias = .0037930732552754493;
const bias_cbrt = Math.cbrt(bias);

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyb/convertRgbToXyb.js
const transfer$1 = (v) => Math.cbrt(v) - bias_cbrt;
const convertRgbToXyb = (color) => {
	const { r: r$1, g, b, alpha } = convertRgbToLrgb_default(color);
	const l = transfer$1(.3 * r$1 + .622 * g + .078 * b + bias);
	const m = transfer$1(.23 * r$1 + .692 * g + .078 * b + bias);
	const s = transfer$1(.2434226892454782 * r$1 + .2047674442449682 * g + .5518098665095535 * b + bias);
	const res = {
		mode: "xyb",
		x: (l - m) / 2,
		y: (l + m) / 2,
		b: s - (l + m) / 2
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyb_default = convertRgbToXyb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyb/convertXybToRgb.js
const transfer = (v) => Math.pow(v + bias_cbrt, 3);
const convertXybToRgb = ({ x, y, b, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (b === void 0) b = 0;
	const l = transfer(x + y) - bias;
	const m = transfer(y - x) - bias;
	const s = transfer(b + y) - bias;
	const res = convertLrgbToRgb_default({
		r: 11.031566904639861 * l - 9.866943908131562 * m - .16462299650829934 * s,
		g: -3.2541473810744237 * l + 4.418770377582723 * m - .16462299650829934 * s,
		b: -3.6588512867136815 * l + 2.7129230459360922 * m + 1.9459282407775895 * s
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXybToRgb_default = convertXybToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/xyb/definition.js
const definition$1 = {
	mode: "xyb",
	channels: [
		"x",
		"y",
		"b",
		"alpha"
	],
	parse: ["--xyb"],
	serialize: "--xyb",
	toMode: { rgb: convertXybToRgb_default },
	fromMode: { rgb: convertRgbToXyb_default },
	ranges: {
		x: [-.0154, .0281],
		y: [0, .8453],
		b: [-.2778, .388]
	},
	interpolate: {
		x: interpolatorLinear,
		y: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$26 = definition$1;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/yiq/convertRgbToYiq.js
const convertRgbToYiq = ({ r: r$1, g, b, alpha }) => {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	const res = {
		mode: "yiq",
		y: .29889531 * r$1 + .58662247 * g + .11448223 * b,
		i: .59597799 * r$1 - .2741761 * g - .32180189 * b,
		q: .21147017 * r$1 - .52261711 * g + .31114694 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToYiq_default = convertRgbToYiq;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/yiq/convertYiqToRgb.js
const convertYiqToRgb = ({ y, i, q, alpha }) => {
	if (y === void 0) y = 0;
	if (i === void 0) i = 0;
	if (q === void 0) q = 0;
	const res = {
		mode: "rgb",
		r: y + .95608445 * i + .6208885 * q,
		g: y - .27137664 * i - .6486059 * q,
		b: y - 1.10561724 * i + 1.70250126 * q
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertYiqToRgb_default = convertYiqToRgb;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/yiq/definition.js
const definition = {
	mode: "yiq",
	toMode: { rgb: convertYiqToRgb_default },
	fromMode: { rgb: convertRgbToYiq_default },
	channels: [
		"y",
		"i",
		"q",
		"alpha"
	],
	parse: ["--yiq"],
	serialize: "--yiq",
	ranges: {
		i: [-.595, .595],
		q: [-.522, .522]
	},
	interpolate: {
		y: interpolatorLinear,
		i: interpolatorLinear,
		q: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$27 = definition;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/round.js
const r = (value, precision) => Math.round(value * (precision = Math.pow(10, precision))) / precision;
const round = (precision = 4) => (value) => typeof value === "number" ? r(value, precision) : value;
var round_default = round;

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/formatter.js
let twoDecimals = round_default(2);
const clamp = (value) => Math.max(0, Math.min(1, value || 0));
const fixup = (value) => Math.round(clamp(value) * 255);
const rgb$2 = converter_default("rgb");
const hsl$1 = converter_default("hsl");
const serializeHex = (color) => {
	if (color === void 0) return;
	let r$1 = fixup(color.r);
	let g = fixup(color.g);
	let b = fixup(color.b);
	return "#" + (1 << 24 | r$1 << 16 | g << 8 | b).toString(16).slice(1);
};
const serializeHex8 = (color) => {
	if (color === void 0) return;
	let a = fixup(color.alpha !== void 0 ? color.alpha : 1);
	return serializeHex(color) + (256 | a).toString(16).slice(1);
};
const formatCss = (c$1) => {
	const color = _prepare_default(c$1);
	if (!color) return;
	const def = getMode(color.mode);
	if (!def.serialize || typeof def.serialize === "string") {
		let res = `color(${def.serialize || `--${color.mode}`} `;
		def.channels.forEach((ch, i) => {
			if (ch !== "alpha") res += (i ? " " : "") + (color[ch] !== void 0 ? color[ch] : "none");
		});
		if (color.alpha !== void 0 && color.alpha < 1) res += ` / ${color.alpha}`;
		return res + ")";
	}
	if (typeof def.serialize === "function") return def.serialize(color);
};
const formatHex = (c$1) => serializeHex(rgb$2(c$1));
const formatHex8 = (c$1) => serializeHex8(rgb$2(c$1));

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/clamp.js
const rgb$1 = converter_default("rgb");
const fixup_rgb = (c$1) => {
	const res = {
		mode: c$1.mode,
		r: Math.max(0, Math.min(c$1.r !== void 0 ? c$1.r : 0, 1)),
		g: Math.max(0, Math.min(c$1.g !== void 0 ? c$1.g : 0, 1)),
		b: Math.max(0, Math.min(c$1.b !== void 0 ? c$1.b : 0, 1))
	};
	if (c$1.alpha !== void 0) res.alpha = c$1.alpha;
	return res;
};
const inrange_rgb = (c$1) => {
	return c$1 !== void 0 && (c$1.r === void 0 || c$1.r >= 0 && c$1.r <= 1) && (c$1.g === void 0 || c$1.g >= 0 && c$1.g <= 1) && (c$1.b === void 0 || c$1.b >= 0 && c$1.b <= 1);
};
function displayable(color) {
	return inrange_rgb(rgb$1(color));
}
function inGamut(mode = "rgb") {
	const { gamut } = getMode(mode);
	if (!gamut) return (color) => true;
	const conv = converter_default(typeof gamut === "string" ? gamut : mode);
	return (color) => inrange_rgb(conv(color));
}
function clampGamut(mode = "rgb") {
	const { gamut } = getMode(mode);
	if (!gamut) return (color) => _prepare_default(color);
	const destMode = typeof gamut === "string" ? gamut : mode;
	const destConv = converter_default(destMode);
	const inDestGamut = inGamut(destMode);
	return (color) => {
		const original = _prepare_default(color);
		if (!original) return;
		const converted = destConv(original);
		if (inDestGamut(converted)) return original;
		const clamped = fixup_rgb(converted);
		if (original.mode === clamped.mode) return clamped;
		return converter_default(original.mode)(clamped);
	};
}
function toGamut(dest = "rgb", mode = "oklch", delta = differenceEuclidean("oklch"), jnd = .02) {
	const destConv = converter_default(dest);
	const destMode = getMode(dest);
	if (!destMode.gamut) return (color) => destConv(color);
	const inDestinationGamut = inGamut(dest);
	const clipToGamut = clampGamut(dest);
	const ucs = converter_default(mode);
	const { ranges } = getMode(mode);
	if (!ranges.l || !ranges.c) throw new Error("LCH-like space expected");
	return (color) => {
		color = _prepare_default(color);
		if (color === void 0) return;
		const candidate = { ...ucs(color) };
		if (candidate.l === void 0) candidate.l = 0;
		if (candidate.c === void 0) candidate.c = 0;
		if (candidate.l >= ranges.l[1]) {
			const res = {
				...destMode.white,
				mode: dest
			};
			if (color.alpha !== void 0) res.alpha = color.alpha;
			return res;
		}
		if (candidate.l <= ranges.l[0]) {
			const res = {
				...destMode.black,
				mode: dest
			};
			if (color.alpha !== void 0) res.alpha = color.alpha;
			return res;
		}
		if (inDestinationGamut(candidate)) return destConv(candidate);
		let start = 0;
		let end = candidate.c;
		let epsilon = (ranges.c[1] - ranges.c[0]) / 4e3;
		let clipped = clipToGamut(candidate);
		while (end - start > epsilon) {
			candidate.c = (start + end) * .5;
			clipped = clipToGamut(candidate);
			if (inDestinationGamut(candidate) || delta && jnd > 0 && delta(candidate, clipped) <= jnd) start = candidate.c;
			else end = candidate.c;
		}
		return destConv(inDestinationGamut(candidate) ? candidate : clipped);
	};
}

//#endregion
//#region ../token-tools/dist/string-Dpqb78jQ.js
const HEX_RE = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
const CULORI_TO_CSS = {
	a98: "a98-rgb",
	hsl: "hsl",
	hwb: "hwb",
	lab: "lab",
	lab65: "lab-d65",
	lch: "lch",
	lrgb: "srgb-linear",
	oklab: "oklab",
	oklch: "oklch",
	okhsv: "okhsv",
	p3: "display-p3",
	prophoto: "prophoto-rgb",
	rec2020: "rec2020",
	rgb: "srgb",
	xyz50: "xyz-d50",
	xyz65: "xyz-d65"
};
const CSS_TO_CULORI = {
	"a98-rgb": "a98",
	"display-p3": "p3",
	hsl: "hsl",
	hwb: "hwb",
	lab: "lab",
	"lab-d65": "lab65",
	lch: "lch",
	oklab: "oklab",
	oklch: "oklch",
	okhsv: "okhsv",
	"prophoto-rgb": "prophoto",
	rec2020: "rec2020",
	srgb: "rgb",
	"srgb-linear": "lrgb",
	xyz: "xyz65",
	"xyz-d50": "xyz50",
	"xyz-d65": "xyz65"
};
/** Parse any color */
function parseColor(color) {
	const result = parse_default(color);
	if (!result) throw new Error(`Unable to parse color "${color}"`);
	if (!(result.mode in CULORI_TO_CSS)) throw new Error(`Unsupported color space: ${result.mode}`);
	const colorSpace = CULORI_TO_CSS[result.mode];
	let components = [
		0,
		0,
		0
	];
	switch (result.mode) {
		case "a98":
		case "rec2020":
		case "p3":
		case "prophoto":
		case "lrgb":
		case "rgb":
			components = [
				result.r,
				result.g,
				result.b
			];
			break;
		case "hsl": {
			const maxS = COLORSPACE[colorSpace].ranges[1]?.[1] ?? 1;
			const maxL = COLORSPACE[colorSpace].ranges[2]?.[1] ?? 1;
			components = [
				result.h ?? 0,
				result.s * maxS,
				result.l * maxL
			];
			break;
		}
		case "hwb": {
			const maxW = COLORSPACE[colorSpace].ranges[1]?.[1] ?? 1;
			const maxB = COLORSPACE[colorSpace].ranges[2]?.[1] ?? 1;
			components = [
				result.h ?? 0,
				result.w * maxW,
				result.b * maxB
			];
			break;
		}
		case "lab":
		case "lab65":
		case "oklab":
			components = [
				result.l,
				result.a,
				result.b
			];
			break;
		case "lch":
		case "oklch":
			components = [
				result.l,
				result.c,
				result.h ?? 0
			];
			break;
		case "okhsv":
			components = [
				result.h ?? 0,
				result.s,
				result.v
			];
			break;
		case "xyz50":
		case "xyz65":
			components = [
				result.x,
				result.y,
				result.z
			];
			break;
	}
	const value = {
		colorSpace,
		components,
		alpha: result.alpha ?? 1
	};
	if (HEX_RE.test(color)) value.hex = formatHex(result);
	return value;
}
/** Convert a color token to a Culori color */
function tokenToCulori(value) {
	switch (value.colorSpace) {
		case "a98-rgb":
		case "display-p3":
		case "prophoto-rgb":
		case "rec2020":
		case "srgb":
		case "srgb-linear": {
			const [r$1, g, b] = value.components;
			return {
				mode: CSS_TO_CULORI[value.colorSpace] || value.colorSpace,
				r: r$1,
				g,
				b,
				alpha: value.alpha
			};
		}
		case "hsl": {
			const [h, s, l] = value.components;
			const maxS = COLORSPACE[value.colorSpace].ranges[1]?.[1] ?? 1;
			const maxL = COLORSPACE[value.colorSpace].ranges[2]?.[1] ?? 1;
			return {
				mode: "hsl",
				h,
				s: s / maxS,
				l: l / maxL,
				alpha: value.alpha
			};
		}
		case "hwb": {
			const [h, w, b] = value.components;
			const maxW = COLORSPACE[value.colorSpace].ranges[1]?.[1] ?? 1;
			const maxB = COLORSPACE[value.colorSpace].ranges[2]?.[1] ?? 1;
			return {
				mode: "hwb",
				h,
				w: w / maxW,
				b: b / maxB,
				alpha: value.alpha
			};
		}
		case "lab":
		case "lab-d65":
		case "oklab": {
			const [l, a, b] = value.components;
			return {
				mode: value.colorSpace === "lab-d65" ? "lab65" : value.colorSpace,
				l,
				a,
				b,
				alpha: value.alpha
			};
		}
		case "lch":
		case "oklch": {
			const [l, c$1, h] = value.components;
			return {
				mode: value.colorSpace,
				l,
				c: c$1,
				h,
				alpha: value.alpha
			};
		}
		case "okhsv": {
			const [h, s, v] = value.components;
			return {
				mode: value.colorSpace,
				h,
				s,
				v,
				alpha: value.alpha
			};
		}
		case "xyz":
		case "xyz-d50":
		case "xyz-d65": {
			const [x, y, z] = value.components;
			return {
				mode: CSS_TO_CULORI[value.colorSpace],
				x,
				y,
				z,
				alpha: value.alpha
			};
		}
		default: throw new Error(`Invalid colorSpace "${value.colorSpace}". Expected one of ${Object.keys(CSS_TO_CULORI).join(", ")}`);
	}
}
/** Complete list of CSS Module 4 Colorspaces */
const COLORSPACE = {
	"a98-rgb": { ranges: [
		[0, 1],
		[0, 1],
		[0, 1]
	] },
	"display-p3": { ranges: [
		[0, 1],
		[0, 1],
		[0, 1]
	] },
	hsl: { ranges: [
		[0, 360],
		[0, 100],
		[0, 100]
	] },
	hwb: { ranges: [
		[0, 360],
		[0, 100],
		[0, 100]
	] },
	lab: { ranges: [
		[0, 100],
		[-125, 125],
		[-125, 125]
	] },
	"lab-d65": { ranges: [
		[0, 100],
		[-125, 125],
		[-125, 125]
	] },
	lch: { ranges: [
		[0, 100],
		[0, 150],
		[0, 360]
	] },
	oklab: { ranges: [
		[0, 1],
		[-.4, .4],
		[-.4, .4]
	] },
	oklch: { ranges: [
		[0, 1],
		[0, .4],
		[0, 360]
	] },
	okhsv: { ranges: [
		[0, 360],
		[0, 1],
		[0, 1]
	] },
	"prophoto-rgb": { ranges: [
		[0, 1],
		[0, 1],
		[0, 1]
	] },
	rec2020: { ranges: [
		[0, 1],
		[0, 1],
		[0, 1]
	] },
	srgb: { ranges: [
		[0, 1],
		[0, 1],
		[0, 1]
	] },
	"srgb-linear": { ranges: [
		[0, 1],
		[0, 1],
		[0, 1]
	] },
	"xyz-d50": { ranges: [
		[0, 1],
		[0, 1],
		[0, 1]
	] },
	xyz: { ranges: [
		[0, 1],
		[0, 1],
		[0, 1]
	] },
	"xyz-d65": { ranges: [
		[0, 1],
		[0, 1],
		[0, 1]
	] }
};
/** Turn a string into kebab-case */
function kebabCase(str) {
	let output = "";
	for (const c$1 of str.split("")) {
		if (c$1 === ".") {
			output += "-";
			continue;
		}
		let isFirstUppercase = true;
		if (isFirstUppercase && /\p{Uppercase_Letter}/u.test(c$1)) {
			output += `-${c$1.toLocaleLowerCase()}`;
			isFirstUppercase = false;
			continue;
		} else isFirstUppercase = true;
		output += c$1;
	}
	return output;
}

//#endregion
//#region ../../node_modules/.pnpm/wildcard-match@5.1.4/node_modules/wildcard-match/build/index.es.mjs
/**
* Escapes a character if it has a special meaning in regular expressions
* and returns the character as is if it doesn't
*/
function escapeRegExpChar(char) {
	if (char === "-" || char === "^" || char === "$" || char === "+" || char === "." || char === "(" || char === ")" || char === "|" || char === "[" || char === "]" || char === "{" || char === "}" || char === "*" || char === "?" || char === "\\") return "\\".concat(char);
	else return char;
}
/**
* Escapes all characters in a given string that have a special meaning in regular expressions
*/
function escapeRegExpString(str) {
	var result = "";
	for (var i = 0; i < str.length; i++) result += escapeRegExpChar(str[i]);
	return result;
}
/**
* Transforms one or more glob patterns into a RegExp pattern
*/
function transform(pattern, separator) {
	if (separator === void 0) separator = true;
	if (Array.isArray(pattern)) {
		var regExpPatterns = pattern.map(function(p$2) {
			return "^".concat(transform(p$2, separator), "$");
		});
		return "(?:".concat(regExpPatterns.join("|"), ")");
	}
	var separatorSplitter = "";
	var separatorMatcher = "";
	var wildcard = ".";
	if (separator === true) {
		separatorSplitter = "/";
		separatorMatcher = "[/\\\\]";
		wildcard = "[^/\\\\]";
	} else if (separator) {
		separatorSplitter = separator;
		separatorMatcher = escapeRegExpString(separatorSplitter);
		if (separatorMatcher.length > 1) {
			separatorMatcher = "(?:".concat(separatorMatcher, ")");
			wildcard = "((?!".concat(separatorMatcher, ").)");
		} else wildcard = "[^".concat(separatorMatcher, "]");
	}
	var requiredSeparator = separator ? "".concat(separatorMatcher, "+?") : "";
	var optionalSeparator = separator ? "".concat(separatorMatcher, "*?") : "";
	var segments = separator ? pattern.split(separatorSplitter) : [pattern];
	var result = "";
	for (var s = 0; s < segments.length; s++) {
		var segment = segments[s];
		var nextSegment = segments[s + 1];
		var currentSeparator = "";
		if (!segment && s > 0) continue;
		if (separator) if (s === segments.length - 1) currentSeparator = optionalSeparator;
		else if (nextSegment !== "**") currentSeparator = requiredSeparator;
		else currentSeparator = "";
		if (separator && segment === "**") {
			if (currentSeparator) {
				result += s === 0 ? "" : s === segments.length - 1 ? "(?:".concat(requiredSeparator, "|$)") : requiredSeparator;
				result += "(?:".concat(wildcard, "*?").concat(currentSeparator, ")*?");
			}
			continue;
		}
		for (var c$1 = 0; c$1 < segment.length; c$1++) {
			var char = segment[c$1];
			if (char === "\\") {
				if (c$1 < segment.length - 1) {
					result += escapeRegExpChar(segment[c$1 + 1]);
					c$1++;
				}
			} else if (char === "?") result += wildcard;
			else if (char === "*") result += "".concat(wildcard, "*?");
			else result += escapeRegExpChar(char);
		}
		result += currentSeparator;
	}
	return result;
}
function isMatch(regexp, sample) {
	if (typeof sample !== "string") throw new TypeError("Sample must be a string, but ".concat(typeof sample, " given"));
	return regexp.test(sample);
}
/**
* Compiles one or more glob patterns into a RegExp and returns an isMatch function.
* The isMatch function takes a sample string as its only argument and returns `true`
* if the string matches the pattern(s).
*
* ```js
* wildcardMatch('src/*.js')('src/index.js') //=> true
* ```
*
* ```js
* const isMatch = wildcardMatch('*.example.com', '.')
* isMatch('foo.example.com') //=> true
* isMatch('foo.bar.com') //=> false
* ```
*/
function wildcardMatch(pattern, options) {
	if (typeof pattern !== "string" && !Array.isArray(pattern)) throw new TypeError("The first argument must be a single pattern string or an array of patterns, but ".concat(typeof pattern, " given"));
	if (typeof options === "string" || typeof options === "boolean") options = { separator: options };
	if (arguments.length === 2 && !(typeof options === "undefined" || typeof options === "object" && options !== null && !Array.isArray(options))) throw new TypeError("The second argument must be an options object or a string/boolean separator, but ".concat(typeof options, " given"));
	options = options || {};
	if (options.separator === "\\") throw new Error("\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead");
	var regexpPattern = transform(pattern, options.separator);
	var regexp = new RegExp("^".concat(regexpPattern, "$"), options.flags);
	var fn$4 = isMatch.bind(null, regexp);
	fn$4.options = options;
	fn$4.pattern = pattern;
	fn$4.regexp = regexp;
	return fn$4;
}

//#endregion
//#region ../token-tools/dist/index.js
/** Give a user pertinent feedback if they override a transform incorrectly */
function validateCustomTransform(value, { $type }) {
	if (value) {
		if (typeof value !== "string" && typeof value !== "object" || Array.isArray(value)) throw new Error(`transform(): expected string or Object of strings, received ${Array.isArray(value) ? "Array" : typeof value}`);
		switch ($type) {
			case "typography":
				if (typeof value !== "object") throw new Error("transform(): typography tokens must be an object of keys");
				break;
		}
	}
}

//#endregion
//#region ../../node_modules/.pnpm/culori@4.0.2/node_modules/culori/src/index.js
const a98 = useMode(definition_default);
const cubehelix = useMode(definition_default$15);
const dlab = useMode(definition_default$16);
const dlch = useMode(definition_default$17);
const hsi = useMode(definition_default$18);
const hsl = useMode(definition_default$1);
const hsv = useMode(definition_default$19);
const hwb = useMode(definition_default$2);
const itp = useMode(definition_default$20);
const jab = useMode(definition_default$21);
const jch = useMode(definition_default$22);
const lab = useMode(definition_default$3);
const lab65 = useMode(definition_default$4);
const lch = useMode(definition_default$5);
const lch65 = useMode(definition_default$23);
const lchuv = useMode(definition_default$24);
const lrgb = useMode(definition_default$6);
const luv = useMode(definition_default$25);
const okhsl = useMode(modeOkhsl_default);
const okhsv = useMode(modeOkhsv_default);
const oklab = useMode(definition_default$7);
const oklch = useMode(definition_default$8);
const p3 = useMode(definition_default$9);
const prophoto = useMode(definition_default$10);
const rec2020 = useMode(definition_default$11);
const rgb = useMode(definition_default$12);
const xyb = useMode(definition_default$26);
const xyz50 = useMode(definition_default$13);
const xyz65 = useMode(definition_default$14);
const yiq = useMode(definition_default$27);

//#endregion
//#region ../token-tools/dist/css.js
function defaultAliasTransform(token) {
	if (!token) throw new Error("Undefined token");
	return `var(${makeCSSVar(token.id)})`;
}
/** Generate shorthand CSS for select token types */
function generateShorthand({ $type, localID }) {
	switch ($type) {
		case "transition": return [
			"duration",
			"delay",
			"timing-function"
		].map((p$2) => makeCSSVar(`${localID}-${p$2}`, { wrapVar: true })).join(" ");
	}
}
const CSS_VAR_RE = /(?:(\p{Uppercase_Letter}?[\p{Lowercase_Letter}\p{Number}]+|[\p{Uppercase_Letter}\p{Number}]+|[\u{80}-\u{10FFFF}\p{Number}]+)|.)/u;
/**
* Generate a valid CSS variable from any string
* Code by @dfrankland
*/
function makeCSSVar(name, { prefix, wrapVar = false } = {}) {
	if (typeof name !== "string") throw new Error(`makeCSSVar() Expected string, received ${name}`);
	let property = name.split(CSS_VAR_RE).filter(Boolean).join("-");
	if (prefix && !property.startsWith(`${prefix}-`)) property = `${prefix}-${property}`;
	const finalProperty = `--${property}`.toLocaleLowerCase();
	return wrapVar ? `var(${finalProperty})` : finalProperty;
}
/** Convert boolean value to CSS string */
function transformBoolean(token, { tokensSet, transformAlias = defaultAliasTransform }) {
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	return token.$value === true ? "1" : "0";
}
/** Convert color value to CSS string */
function transformColor(token, options) {
	const { transformAlias = defaultAliasTransform, tokensSet } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	const { colorSpace, components, alpha = 1 } = typeof token.$value === "string" ? parseColor(token.$value) : token.$value;
	const color = tokenToCulori({
		colorSpace,
		components,
		alpha
	});
	if (!color) throw new Error(`Cant convert color ${JSON.stringify(token.$value)} to Culori color`);
	let formatColor = formatCss;
	if (options.color?.legacyHex) formatColor = color.alpha !== 1 ? formatHex8 : formatHex;
	return displayable(color) ? formatColor(color) : downsample({
		colorSpace,
		components,
		alpha
	}, color, options.color?.depth);
}
const converters = {
	a98: useMode(definition_default),
	hsl: useMode(definition_default$1),
	hwb: useMode(definition_default$2),
	lab: useMode(definition_default$3),
	lab65: useMode(definition_default$4),
	lch: useMode(definition_default$5),
	lrgb: useMode(definition_default$6),
	oklab: useMode(definition_default$7),
	oklch: useMode(definition_default$8),
	okhsv: useMode(modeOkhsv_default),
	p3: useMode(definition_default$9),
	prophoto: useMode(definition_default$10),
	rec2020: useMode(definition_default$11),
	rgb: useMode(definition_default$12),
	xyz50: useMode(definition_default$13),
	xyz65: useMode(definition_default$14)
};
const DEPTH_ROUNDING = {
	24: round_default(4),
	30: round_default(4),
	36: round_default(5),
	48: round_default(6)
};
/**
* Downsample color to sRGB/Display P3/Rec2020 colorspaces.
* Note: because Culori tends to convert to RGB color spaces to ensure the operation,
* we have to do an additional step of converting back. So were not really converting;
* were just preserving the original colorspace.
*/
function downsample($value, culoriColor, depth = 30) {
	if (!($value.colorSpace in CSS_TO_CULORI)) throw new Error(`Invalid colorSpace "${$value.colorSpace}". Expected one of: ${Object.keys(CSS_TO_CULORI).join(", ")}`);
	const conversionSpace = CSS_TO_CULORI[$value.colorSpace] || "oklab";
	let gamutSpace = conversionSpace;
	if (gamutSpace === "lab" || gamutSpace === "lab65") gamutSpace = "lch";
	else if (gamutSpace === "oklab") gamutSpace = "oklch";
	let srgb = converters[conversionSpace](toGamut("rgb", gamutSpace)(culoriColor));
	let p3$2 = converters[conversionSpace](toGamut("p3", gamutSpace)(culoriColor));
	let rec2020$2 = converters[conversionSpace](toGamut("rec2020", gamutSpace)(culoriColor));
	if (typeof depth === "number") {
		if (!DEPTH_ROUNDING[depth]) throw new Error(`Invalid bit depth: ${depth}. Supported values: ${Object.keys(DEPTH_ROUNDING).join(", ")}`);
		srgb = roundColor(srgb, depth);
		p3$2 = roundColor(p3$2, depth);
		rec2020$2 = roundColor(rec2020$2, depth);
	}
	return {
		".": formatCss(culoriColor),
		srgb: formatCss(srgb),
		p3: formatCss(p3$2),
		rec2020: formatCss(rec2020$2)
	};
}
/** Round color to certain depth. */
function roundColor(color, depth = 30) {
	if (depth === "unlimited") return color;
	const newColor = { ...color };
	for (const [k$3, v] of Object.entries(color)) {
		if (typeof v !== "number" || k$3 === "mode") continue;
		newColor[k$3] = DEPTH_ROUNDING[depth](v);
	}
	return newColor;
}
/** Convert dimension value to CSS */
function transformDimension(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	return token.$value.value === 0 ? "0" : `${token.$value.value}${token.$value.unit}`;
}
/** Convert strokeStyle value to CSS */
function transformStrokeStyle(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	return typeof token.$value === "string" ? token.$value : "dashed";
}
/** Convert border value to multiple CSS values */
function transformBorder(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	const width = token.partialAliasOf?.width ? transformAlias(tokensSet[token.partialAliasOf.width]) : transformDimension({ $value: token.$value.width }, options);
	const color = token.partialAliasOf?.color ? transformAlias(tokensSet[token.partialAliasOf.color]) : transformColor({ $value: token.$value.color }, options);
	const style = token.partialAliasOf?.style ? transformAlias(tokensSet[token.partialAliasOf.style]) : transformStrokeStyle({ $value: token.$value.style }, options);
	const formatBorder = (colorKey) => [
		width,
		style,
		typeof color === "string" ? color : color[colorKey]
	].join(" ");
	return typeof color === "string" || displayable(color.p3) ? formatBorder(".") : {
		".": formatBorder("."),
		srgb: formatBorder("srgb"),
		p3: formatBorder("p3"),
		rec2020: formatBorder("rec2020")
	};
}
/** Convert cubicBezier value to CSS */
function transformCubicBezier(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	return `cubic-bezier(${token.$value.map((v, i) => token.partialAliasOf?.[i] ? transformAlias(tokensSet[token.partialAliasOf[i]]) : v).join(", ")})`;
}
/** Convert duration value to CSS */
function transformDuration(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	return `${token.$value.value}${token.$value.unit}`;
}
const FONT_NAME_KEYWORD = /^[a-z-]+$/;
function transformFontFamily(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	return token.$value.map((fontName) => FONT_NAME_KEYWORD.test(fontName) ? fontName : `"${fontName}"`).join(", ");
}
/** Convert fontWeight value to CSS */
function transformFontWeight(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	return String(token.$value);
}
/** Convert gradient value to CSS */
function transformGradient(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	let isHDR = false;
	const colors = [];
	const positions = [];
	for (let i = 0; i < token.$value.length; i++) {
		const { color, position } = token.$value[i];
		const colorValue = token.partialAliasOf?.[i]?.color ? transformAlias(tokensSet[token.partialAliasOf[i].color]) : transformColor({ $value: color }, options);
		if (typeof colorValue !== "string") isHDR = true;
		colors.push(colorValue);
		positions.push(token.partialAliasOf?.[i]?.position ? transformAlias(tokensSet[token.partialAliasOf[i].position]) : `${100 * position}%`);
	}
	function formatStop(i, colorKey = ".") {
		return `${typeof colors[i] === "string" ? colors[i] : colors[i][colorKey]} ${positions[i]}`;
	}
	return !isHDR ? token.$value.map((_, i) => formatStop(i, positions[i])).join(", ") : {
		".": token.$value.map((_, i) => formatStop(i, ".")).join(", "),
		srgb: token.$value.map((_, i) => formatStop(i, "srgb")).join(", "),
		p3: token.$value.map((_, i) => formatStop(i, "p3")).join(", "),
		rec2020: token.$value.map((_, i) => formatStop(i, "rec2020")).join(", ")
	};
}
/** Convert link value to CSS */
function transformLink(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	return `url("${token.$value}")`;
}
/** Convert number value to CSS */
function transformNumber(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	return String(token.$value);
}
/** Convert shadow subvalue to CSS */
function transformShadowLayer(value, options) {
	const { tokensSet, colorValue, partialAliasOf, transformAlias = defaultAliasTransform } = options;
	const offsetX = partialAliasOf?.offsetX ? transformAlias(tokensSet[partialAliasOf.offsetX]) : transformDimension({ $value: value.offsetX }, options);
	const offsetY = partialAliasOf?.offsetY ? transformAlias(tokensSet[partialAliasOf.offsetY]) : transformDimension({ $value: value.offsetY }, options);
	const blur = partialAliasOf?.blur ? transformAlias(tokensSet[partialAliasOf.blur]) : transformDimension({ $value: value.blur }, options);
	const spread = partialAliasOf?.spread ? transformAlias(tokensSet[partialAliasOf.spread]) : transformDimension({ $value: value.spread }, options);
	return [
		value?.inset === true ? "inset" : void 0,
		offsetX,
		offsetY,
		blur,
		spread,
		colorValue
	].filter(Boolean).join(" ");
}
/** Convert shadow value to CSS */
function transformShadow(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	const colors = token.$value.map((v, i) => token.partialAliasOf?.[i]?.color ? transformAlias(tokensSet[token.partialAliasOf[i].color]) : transformColor({ $value: v.color }, options));
	const isHDR = colors.some((c$1) => typeof c$1 === "object");
	const formatShadow = (colorKey) => token.$value.map((v, i) => transformShadowLayer(v, {
		tokensSet,
		colorValue: typeof colors[i] === "string" ? colors[i] : colors[i][colorKey],
		partialAliasOf: token.partialAliasOf?.[i],
		transformAlias
	})).join(", ");
	return !isHDR ? formatShadow(".") : {
		".": formatShadow("."),
		srgb: formatShadow("srgb"),
		p3: formatShadow("p3"),
		rec2020: formatShadow("rec2020")
	};
}
/** Convert string value to CSS */
function transformString(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	return String(token.$value);
}
/** Convert transition value to shorthand */
function transformTransition(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	if (token.aliasChain?.[0]) return transformAlias(tokensSet[token.aliasChain[0]]);
	const duration = token.partialAliasOf?.duration ? transformAlias(tokensSet[token.partialAliasOf.duration]) : transformDuration({ $value: token.$value.duration }, options);
	const delay = token.partialAliasOf?.delay ? transformAlias(tokensSet[token.partialAliasOf.delay]) : transformDuration({ $value: token.$value.delay }, options);
	const timingFunction = token.partialAliasOf?.timingFunction ? transformAlias(tokensSet[token.partialAliasOf.timingFunction]) : transformCubicBezier({ $value: token.$value.timingFunction }, options);
	return `${duration} ${delay} ${timingFunction}`;
}
/** Convert typography value to multiple CSS values */
function transformTypography(token, options) {
	const { tokensSet, transformAlias = defaultAliasTransform } = options;
	const output = {};
	for (const [property, subvalue] of Object.entries(token.$value)) {
		let transformedValue;
		const aliasedID = token.aliasChain?.[0] ?? token.partialAliasOf?.[property];
		if (aliasedID) {
			const resolvedToken = tokensSet[aliasedID];
			transformedValue = transformAlias(resolvedToken.$type === "typography" ? { id: `${aliasedID}-${property}` } : resolvedToken);
		} else switch (property) {
			case "fontFamily":
				transformedValue = transformFontFamily({ $value: subvalue }, options);
				break;
			case "fontSize":
			case "letterSpacing":
				transformedValue = transformDimension({ $value: subvalue }, options);
				break;
			case "fontWeight":
				transformedValue = transformFontWeight({ $value: subvalue }, options);
				break;
			case "lineHeight":
				if (typeof subvalue === "number") transformedValue = transformNumber({ $value: subvalue }, options);
				else transformedValue = transformDimension({ $value: subvalue }, options);
				break;
			default:
				transformedValue = transformString({ $value: subvalue }, options);
				break;
		}
		output[kebabCase(property)] = transformedValue;
	}
	return output;
}
/** Main CSS Transform */
function transformCSSValue(token, { mode,...options }) {
	const selectedMode = token.mode[mode];
	if (!selectedMode) return;
	const tokenWithModeValue = {
		id: token.id,
		$type: token.$type,
		...selectedMode
	};
	switch (tokenWithModeValue.$type) {
		case "boolean": return transformBoolean(tokenWithModeValue, options);
		case "border": return transformBorder(tokenWithModeValue, options);
		case "color": return transformColor(tokenWithModeValue, options);
		case "cubicBezier": return transformCubicBezier(tokenWithModeValue, options);
		case "dimension": return transformDimension(tokenWithModeValue, options);
		case "duration": return transformDuration(tokenWithModeValue, options);
		case "fontFamily": return transformFontFamily(tokenWithModeValue, options);
		case "fontWeight": return transformFontWeight(tokenWithModeValue, options);
		case "gradient": return transformGradient(tokenWithModeValue, options);
		case "link": return transformLink(tokenWithModeValue, options);
		case "number": return transformNumber(tokenWithModeValue, options);
		case "shadow": return transformShadow(tokenWithModeValue, options);
		case "string": return transformString(tokenWithModeValue, options);
		case "strokeStyle": return transformStrokeStyle(tokenWithModeValue, options);
		case "transition": return transformTransition(tokenWithModeValue, options);
		case "typography": return transformTypography(tokenWithModeValue, options);
	}
}

//#endregion
//#region src/lib.ts
const FORMAT_ID = "css";
const FILE_PREFIX = `/* -------------------------------------------
 *  Autogenerated by  Terrazzo. DO NOT EDIT!
 * ------------------------------------------- */`;
/** Convert CSSRules into a formatted, indented CSS string */
function printRules(rules) {
	const output = [];
	for (const rule of rules) {
		if (!rule.selectors.length || !Object.keys(rule.declarations).length) continue;
		const mqSelectors = [];
		const joinableSelectors = [];
		for (const s of rule.selectors) (s.startsWith("@") ? mqSelectors : joinableSelectors).push(s);
		for (const s of mqSelectors) output.push(_printRule({
			...rule,
			selectors: [s]
		}));
		if (joinableSelectors.length) output.push(_printRule({
			...rule,
			selectors: joinableSelectors
		}));
	}
	return output.join("\n\n");
}
function _printRule(rule) {
	const output = [];
	const isMediaQuery = rule.selectors.some((s) => s.startsWith("@"));
	let indent = "";
	if (rule.nestedQuery && isMediaQuery) {
		output.push(`${indent}${rule.selectors.join(`,\n${indent}`)} {`);
		indent += "  ";
		output.push(`${indent}${rule.nestedQuery} {`);
	} else if (rule.nestedQuery && !isMediaQuery) {
		output.push(`${indent}${rule.nestedQuery} {`);
		indent += "  ";
		output.push(`${indent}${rule.selectors.join(`,\n${indent}`)} {`);
	} else output.push(`${indent}${rule.selectors.join(`,\n${indent}`)} {`);
	indent += "  ";
	if (isMediaQuery) {
		output.push(`${indent}:root {`);
		indent += "  ";
	}
	const declarations = Object.entries(rule.declarations);
	declarations.sort((a, b) => a[0].localeCompare(b[0], "en-us", { numeric: true }));
	for (const [k$3, d] of declarations) output.push(`${indent}${k$3}: ${d.value};${d.description ? ` /* ${d.description} */` : ""}`);
	while (indent !== "") {
		indent = indent.substring(0, indent.length - 2);
		output.push(`${indent}}`);
	}
	return output.join("\n");
}

//#endregion
//#region src/build/utility-css.ts
const GROUP_REGEX = {
	bg: /(^bg-|-bg-)/,
	border: /(^border-|-border-)/,
	font: /(^font-|-font-)/,
	gap: /(^gap-|-gap-)/,
	m: /(^margin-|-margin-|)/,
	p: /(^padding-|-padding-|)/,
	shadow: /(^shadow-|-shadow-)/,
	text: /(^text-|-text-)/
};
/** Make CSS class name from transformed token */
function makeSelector(token, prefix, subgroup) {
	return `.${prefix}${subgroup || ""}-${kebabCase(token.token.id).replace(GROUP_REGEX[prefix], "")}`;
}
function makeVarValue(token) {
	return { value: makeCSSVar(token.localID ?? token.token.id, { wrapVar: true }) };
}
function generateUtilityCSS(groups, tokens) {
	const output = [];
	const groupEntries = Object.entries(groups);
	groupEntries.sort((a, b) => a[0].localeCompare(b[0]));
	for (const [group, selectors] of groupEntries) {
		const selectorMatcher = wildcardMatch(selectors);
		const matchingTokens = tokens.filter((token) => selectorMatcher(token.token.id));
		if (!matchingTokens.length) {
			console.warn(`[@terrazzo/plugin-css] utility group "${group}" matched 0 tokens: ${JSON.stringify(selectors)}`);
			break;
		}
		switch (group) {
			case "bg":
				for (const token of matchingTokens) {
					const selector = makeSelector(token, "bg");
					switch (token.token.$type) {
						case "color":
							output.push({
								selectors: [selector],
								declarations: { "background-color": makeVarValue(token) }
							});
							break;
						case "gradient": output.push({
							selectors: [selector],
							declarations: { "background-image": { value: `linear-gradient(${makeCSSVar(token.localID ?? token.token.id, { wrapVar: true })})` } }
						});
					}
				}
				break;
			case "border":
				for (const token of matchingTokens) {
					const property = {
						border: "border",
						color: "border-color",
						dimension: "border-width",
						strokeStyle: "border-style"
					}[token.token.$type];
					if (property) output.push({
						selectors: [makeSelector(token, "border")],
						declarations: { [property]: makeVarValue(token) }
					});
				}
				for (const token of matchingTokens) for (const side of [
					"top",
					"right",
					"bottom",
					"left"
				]) {
					const property = {
						border: `border-${side}`,
						color: `border-${side}-color`,
						dimension: `border-${side}-width`,
						strokeStyle: `border-${side}-style`
					}[token.token.$type];
					if (property) output.push({
						selectors: [makeSelector(token, "border", `-${side}`)],
						declarations: { [property]: makeVarValue(token) }
					});
				}
				break;
			case "font":
				for (const token of matchingTokens) {
					const selector = makeSelector(token, "font");
					if (token.token.$type === "typography" && token.type === "MULTI_VALUE") {
						const declarations = {};
						for (const k$3 of Object.keys(token.value)) declarations[k$3] = { value: makeCSSVar(`${token.localID ?? token.token.id}-${k$3}`, { wrapVar: true }) };
						output.push({
							selectors: [selector],
							declarations
						});
					} else {
						const property = {
							dimension: "font-size",
							fontFamily: "font-family",
							fontWeight: "font-weight"
						}[token.token.$type];
						if (property) output.push({
							selectors: [selector],
							declarations: { [property]: makeVarValue(token) }
						});
					}
				}
				break;
			case "layout": {
				const filteredTokens = matchingTokens.filter((t) => t.token.$type === "dimension");
				for (const token of filteredTokens) output.push({
					selectors: [makeSelector(token, "gap")],
					declarations: { gap: makeVarValue(token) }
				});
				for (const token of filteredTokens) output.push({
					selectors: [makeSelector(token, "gap", "-col")],
					declarations: { "column-gap": makeVarValue(token) }
				});
				for (const token of filteredTokens) output.push({
					selectors: [makeSelector(token, "gap", "-row")],
					declarations: { "row-gap": makeVarValue(token) }
				});
				for (const prefix of ["m", "p"]) {
					const property = prefix === "m" ? "margin" : "padding";
					for (const token of filteredTokens) output.push({
						selectors: [makeSelector(token, prefix, "a")],
						declarations: { [property]: makeVarValue(token) }
					});
					for (const token of filteredTokens) {
						const value = makeVarValue(token);
						output.push({
							selectors: [makeSelector(token, prefix, "x")],
							declarations: {
								[`${property}-left`]: value,
								[`${property}-right`]: value
							}
						}, {
							selectors: [makeSelector(token, prefix, "y")],
							declarations: {
								[`${property}-bottom`]: value,
								[`${property}-top`]: value
							}
						});
					}
					for (const side of [
						"top",
						"right",
						"bottom",
						"left"
					]) for (const token of filteredTokens) output.push({
						selectors: [makeSelector(token, prefix, side[0])],
						declarations: { [`${property}-${side}`]: makeVarValue(token) }
					});
					for (const token of filteredTokens) {
						const value = makeVarValue(token);
						output.push({
							selectors: [makeSelector(token, prefix, "s")],
							declarations: { [`${property}-inline-start`]: value }
						}, {
							selectors: [makeSelector(token, prefix, "e")],
							declarations: { [`${property}-inline-end`]: value }
						});
					}
				}
				break;
			}
			case "shadow":
				for (const token of matchingTokens) if (token.token.$type === "shadow") output.push({
					selectors: [makeSelector(token, "shadow")],
					declarations: { "box-shadow": makeVarValue(token) }
				});
				break;
			case "text":
				for (const token of matchingTokens) {
					const selector = makeSelector(token, "text");
					const value = makeVarValue(token);
					switch (token.token.$type) {
						case "color":
							output.push({
								selectors: [selector],
								declarations: { color: value }
							});
							break;
						case "gradient":
							output.push({
								selectors: [selector],
								declarations: {
									background: { value: `-webkit-linear-gradient(${value.value})` },
									"-webkit-background-clip": { value: "text" },
									"-webkit-text-fill-color": { value: "transparent" }
								}
							});
							break;
					}
				}
				break;
			default:
				console.warn(`[@terrazzo/plugin-css] unknown utility CSS group "${group}", ignoring`);
				break;
		}
	}
	return output;
}

//#endregion
//#region src/build/index.ts
const P3_MQ = "@media (color-gamut: p3)";
const REC2020_MQ = "@media (color-gamut: rec2020)";
function buildFormat({ getTransforms, exclude, utility, modeSelectors, baseSelector, baseScheme }) {
	const rules = [];
	const rootTokens = getTransforms({
		format: FORMAT_ID,
		mode: "."
	});
	if (rootTokens.length) {
		const rootRule = {
			selectors: [baseSelector],
			declarations: {}
		};
		const p3Rule = {
			selectors: [baseSelector],
			nestedQuery: P3_MQ,
			declarations: {}
		};
		const rec2020Rule = {
			selectors: [baseSelector],
			nestedQuery: REC2020_MQ,
			declarations: {}
		};
		rules.push(rootRule, p3Rule, rec2020Rule);
		const shouldExclude = wildcardMatch(exclude ?? []);
		if (baseScheme) rootRule.declarations["color-scheme"] = { value: baseScheme };
		for (const token of rootTokens) {
			if (shouldExclude(token.token.id)) continue;
			const localID = token.localID ?? token.token.id;
			const aliasTokens = token.token.aliasedBy?.length ? getTransforms({
				format: FORMAT_ID,
				id: token.token.aliasedBy
			}) : [];
			if (token.type === "SINGLE_VALUE") rootRule.declarations[localID] = {
				value: token.value,
				description: token.token.$description
			};
			else if (token.value.srgb && token.value.p3 && token.value.rec2020) {
				rootRule.declarations[localID] = {
					value: token.value.srgb,
					description: token.token.$description
				};
				if (token.value.p3 !== token.value.srgb) {
					p3Rule.declarations[localID] = {
						value: token.value.p3,
						description: token.token.$description
					};
					rec2020Rule.declarations[localID] = {
						value: token.value.rec2020,
						description: token.token.$description
					};
					for (const alias of aliasTokens) if (alias.localID && typeof alias.value === "string") {
						p3Rule.declarations[alias.localID] ??= {
							value: alias.value,
							description: token.token.$description
						};
						rec2020Rule.declarations[alias.localID] ??= {
							value: alias.value,
							description: token.token.$description
						};
					}
				}
			} else if (token.type === "MULTI_VALUE") {
				const shorthand = generateShorthand({
					$type: token.token.$type,
					localID
				});
				if (shorthand) rootRule.declarations[token.localID ?? token.token.id] = {
					value: shorthand,
					description: token.token.$description
				};
				for (const [name, value] of Object.entries(token.value)) rootRule.declarations[name === "." ? localID : [localID, name].join("-")] = {
					value,
					description: token.token.$description
				};
			}
		}
	}
	for (const { selectors, tokens, mode, scheme } of modeSelectors ?? []) {
		if (!selectors.length) continue;
		const selectorTokens = getTransforms({
			format: FORMAT_ID,
			id: tokens,
			mode
		});
		if (!selectorTokens.length) continue;
		const selectorRule = {
			selectors,
			declarations: {}
		};
		const selectorP3Rule = {
			selectors,
			nestedQuery: P3_MQ,
			declarations: {}
		};
		const selectorRec2020Rule = {
			selectors,
			nestedQuery: REC2020_MQ,
			declarations: {}
		};
		const selectorAliasDeclarations = {};
		rules.push(selectorRule, selectorP3Rule, selectorRec2020Rule);
		if (scheme) selectorRule.declarations["color-scheme"] = { value: scheme };
		for (const token of selectorTokens) {
			const localID = token.localID ?? token.token.id;
			const aliasTokens = token.token.aliasedBy?.length ? getTransforms({
				format: FORMAT_ID,
				id: token.token.aliasedBy
			}) : [];
			if (token.type === "SINGLE_VALUE") selectorRule.declarations[localID] = {
				value: token.value,
				description: token.token.$description
			};
			else if (token.value.srgb && token.value.p3 && token.value.rec2020) {
				selectorRule.declarations[localID] = {
					value: token.value.srgb,
					description: token.token.$description
				};
				if (token.value.p3 !== token.value.srgb) {
					selectorP3Rule.declarations[localID] = {
						value: token.value.p3,
						description: token.token.$description
					};
					selectorRec2020Rule.declarations[localID] = {
						value: token.value.rec2020,
						description: token.token.$description
					};
					for (const alias of aliasTokens) if (alias.localID && typeof alias.value === "string") {
						selectorP3Rule.declarations[alias.localID] ??= {
							value: alias.value,
							description: token.token.$description
						};
						selectorRec2020Rule.declarations[alias.localID] ??= {
							value: alias.value,
							description: token.token.$description
						};
					}
				}
			} else {
				const shorthand = generateShorthand({
					$type: token.token.$type,
					localID
				});
				if (shorthand) selectorRule.declarations[localID] = {
					value: shorthand,
					description: token.token.$description
				};
				for (const [name, subvalue] of Object.entries(token.value)) selectorRule.declarations[`${localID}-${name}`] = {
					value: subvalue,
					description: token.token.$description
				};
			}
			for (const alias of aliasTokens) if (alias.localID && typeof alias.value === "string") selectorAliasDeclarations[alias.localID] = {
				value: alias.value,
				description: token.token.$description
			};
		}
		for (const [name, { value, description }] of Object.entries(selectorAliasDeclarations)) selectorRule.declarations[name] ??= {
			value,
			description
		};
	}
	if (utility && Object.keys(utility).length) rules.push(...generateUtilityCSS(utility, getTransforms({
		format: FORMAT_ID,
		mode: "."
	})));
	return printRules(rules);
}

//#endregion
//#region src/index.ts
function cssPlugin(options) {
	const { exclude, variableName, modeSelectors, transform: customTransform, utility, legacyHex, skipBuild, baseScheme } = options ?? {};
	const filename = options?.filename ?? options?.fileName ?? "index.css";
	const baseSelector = options?.baseSelector ?? ":root";
	function transformName(token) {
		const customName = variableName?.(token);
		if (customName !== void 0) {
			if (typeof customName !== "string") throw new Error(`variableName() must return a string; received ${customName}`);
			return customName;
		}
		return makeCSSVar(token.id);
	}
	const transformAlias = (token) => `var(${transformName(token)})`;
	return {
		name: "@terrazzo/plugin-css",
		async transform({ tokens, getTransforms, setTransform }) {
			if (getTransforms({
				format: FORMAT_ID,
				id: "*",
				mode: "*"
			}).length) return;
			for (const [id, token] of Object.entries(tokens)) {
				const localID = transformName(token);
				for (const mode of Object.keys(token.mode)) {
					if (customTransform) {
						const value = customTransform(token, mode);
						if (value !== void 0 && value !== null) {
							validateCustomTransform(value, { $type: token.$type });
							setTransform(id, {
								format: FORMAT_ID,
								localID,
								value,
								mode
							});
							continue;
						}
					}
					const transformedValue = transformCSSValue(token, {
						mode,
						tokensSet: tokens,
						transformAlias,
						color: { legacyHex }
					});
					if (transformedValue !== void 0) setTransform(id, {
						format: FORMAT_ID,
						localID,
						value: transformedValue,
						mode
					});
				}
			}
		},
		async build({ getTransforms, outputFile }) {
			if (skipBuild === true) return;
			const output = [FILE_PREFIX, ""];
			output.push(buildFormat({
				exclude,
				getTransforms,
				modeSelectors,
				utility,
				baseSelector,
				baseScheme
			}), "\n");
			outputFile(filename, output.join("\n"));
		}
	};
}

//#endregion
export { FILE_PREFIX, FORMAT_ID, cssPlugin as default, printRules };
//# sourceMappingURL=index.js.map