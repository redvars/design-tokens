{"version":3,"file":"css.js","names":["token: TokenNormalized","name: string","token: BooleanTokenNormalized","token: ColorTokenNormalized","options: TransformCSSValueOptions","formatColor: (color: Color) => string","converters: Record<keyof typeof CULORI_TO_CSS, (color: Color) => Color>","$value: ColorTokenNormalized['$value']","culoriColor: Color","depth: Depth","color: T","token: DimensionTokenNormalized","options: TransformCSSValueOptions","token: StrokeStyleTokenNormalized","options: TransformCSSValueOptions","token: BorderTokenNormalized","options: TransformCSSValueOptions","colorKey: string","token: CubicBezierTokenNormalized","options: TransformCSSValueOptions","token: DurationTokenNormalized","options: TransformCSSValueOptions","token: FontFamilyTokenNormalized","options: TransformCSSValueOptions","token: FontWeightTokenNormalized","options: TransformCSSValueOptions","token: GradientTokenNormalized","options: TransformCSSValueOptions","colors: (string | WideGamutColorValue)[]","positions: string[]","i: number","token: LinkTokenNormalized","options: TransformCSSValueOptions","token: NumberTokenNormalized","options: TransformCSSValueOptions","value: ShadowValueNormalized","options: TransformCSSValueOptions & {\n    colorValue: string;\n    partialAliasOf?: Partial<Record<keyof typeof value, string>>;\n  }","token: ShadowTokenNormalized","options: TransformCSSValueOptions","colorKey: string","token: StringTokenNormalized","options: TransformCSSValueOptions","token: TransitionTokenNormalized","options: TransformCSSValueOptions","token: TypographyTokenNormalized","options: TransformCSSValueOptions","output: Record<string, string>","transformedValue: string","token: T","tokenWithModeValue: T"],"sources":["../src/css/lib.ts","../src/css/boolean.ts","../src/css/color.ts","../src/css/dimension.ts","../src/css/stroke-style.ts","../src/css/border.ts","../src/css/cubic-bezier.ts","../src/css/duration.ts","../src/css/font-family.ts","../src/css/font-weight.ts","../src/css/gradient.ts","../src/css/link.ts","../src/css/number.ts","../src/css/shadow.ts","../src/css/string.ts","../src/css/transition.ts","../src/css/typography.ts","../src/css/index.ts"],"sourcesContent":["import type { TokenNormalized } from '../types.js';\n\n/** Function that generates a var(…) statement */\nexport type IDGenerator<T = TokenNormalized> = (token: T) => string;\n\nexport function defaultAliasTransform(token: TokenNormalized) {\n  if (!token) {\n    throw new Error('Undefined token');\n  }\n  return `var(${makeCSSVar(token.id)})`;\n}\n\n/** Generate shorthand CSS for select token types */\nexport function generateShorthand({ $type, localID }: { $type: string; localID: string }): string | undefined {\n  switch ($type) {\n    case 'transition': {\n      return ['duration', 'delay', 'timing-function']\n        .map((p) => makeCSSVar(`${localID}-${p}`, { wrapVar: true }))\n        .join(' ');\n    }\n    // note: \"typography\" is not set in shorthand because it can often unset values unintentionally.\n    // @see https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  }\n}\n\nconst CSS_VAR_RE =\n  /(?:(\\p{Uppercase_Letter}?[\\p{Lowercase_Letter}\\p{Number}]+|[\\p{Uppercase_Letter}\\p{Number}]+|[\\u{80}-\\u{10FFFF}\\p{Number}]+)|.)/u;\n\nexport interface MakeCSSVarOptions {\n  /** Prefix with string */\n  prefix?: string;\n  /**\n   * Wrap with `var(…)`\n   * @default false\n   */\n  wrapVar?: boolean;\n}\n\n/**\n * Generate a valid CSS variable from any string\n * Code by @dfrankland\n */\nexport function makeCSSVar(name: string, { prefix, wrapVar = false }: MakeCSSVarOptions = {}): string {\n  if (typeof name !== 'string') {\n    throw new Error(`makeCSSVar() Expected string, received ${name}`);\n  }\n\n  let property = name.split(CSS_VAR_RE).filter(Boolean).join('-');\n  if (prefix && !property.startsWith(`${prefix}-`)) {\n    property = `${prefix}-${property}`;\n  }\n  const finalProperty = `--${property}`.toLocaleLowerCase();\n  return wrapVar ? `var(${finalProperty})` : finalProperty;\n}\n","import type { BooleanTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert boolean value to CSS string */\nexport function transformBoolean(\n  token: BooleanTokenNormalized,\n  { tokensSet, transformAlias = defaultAliasTransform }: TransformCSSValueOptions,\n): string {\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n  return token.$value === true ? '1' : '0';\n}\n","import {\n  type Color,\n  displayable,\n  formatCss,\n  formatHex,\n  formatHex8,\n  modeA98,\n  modeHsl,\n  modeHwb,\n  modeLab,\n  modeLab65,\n  modeLch,\n  modeLrgb,\n  modeOkhsv,\n  modeOklab,\n  modeOklch,\n  modeP3,\n  modeProphoto,\n  modeRec2020,\n  modeRgb,\n  modeXyz50,\n  modeXyz65,\n  round,\n  toGamut,\n  useMode,\n} from 'culori/fn';\nimport { CSS_TO_CULORI, type CULORI_TO_CSS, parseColor, tokenToCulori } from '../color.js';\nimport type { ColorTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\nexport type WideGamutColorValue = {\n  '.': string;\n  srgb: string;\n  p3: string;\n  rec2020: string;\n};\n\n/** Convert color value to CSS string */\nexport function transformColor(\n  token: ColorTokenNormalized,\n  options: TransformCSSValueOptions,\n): string | WideGamutColorValue {\n  const { transformAlias = defaultAliasTransform, tokensSet } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n\n  const {\n    colorSpace,\n    components,\n    alpha = 1,\n  } = typeof token.$value === 'string' ? parseColor(token.$value) : token.$value;\n  const color = tokenToCulori({ colorSpace, components, alpha });\n\n  if (!color) {\n    throw new Error(`Can’t convert color ${JSON.stringify(token.$value)} to Culori color`);\n  }\n\n  let formatColor: (color: Color) => string = formatCss;\n  if (options.color?.legacyHex) {\n    formatColor = color.alpha !== 1 ? formatHex8 : formatHex;\n  }\n\n  return displayable(color)\n    ? formatColor(color)\n    : downsample({ colorSpace, components, alpha }, color, options.color?.depth);\n}\n\nconst converters: Record<keyof typeof CULORI_TO_CSS, (color: Color) => Color> = {\n  a98: useMode(modeA98),\n  hsl: useMode(modeHsl),\n  hwb: useMode(modeHwb),\n  lab: useMode(modeLab),\n  lab65: useMode(modeLab65),\n  lch: useMode(modeLch),\n  lrgb: useMode(modeLrgb),\n  oklab: useMode(modeOklab),\n  oklch: useMode(modeOklch),\n  okhsv: useMode(modeOkhsv),\n  p3: useMode(modeP3),\n  prophoto: useMode(modeProphoto),\n  rec2020: useMode(modeRec2020),\n  rgb: useMode(modeRgb),\n  xyz50: useMode(modeXyz50),\n  xyz65: useMode(modeXyz65),\n};\n\nexport const DEPTH_ROUNDING = {\n  24: round(4), // 24-bit almost fits into 3 decimal places, but not quite\n  30: round(4),\n  36: round(5),\n  48: round(6),\n};\n\nexport type Depth = keyof typeof DEPTH_ROUNDING | 'unlimited';\n\n/**\n * Downsample color to sRGB/Display P3/Rec2020 colorspaces.\n * Note: because Culori tends to convert to RGB color spaces to ensure the operation,\n * we have to do an additional step of converting back. So we’re not really converting;\n * we’re just preserving the original colorspace.\n */\nfunction downsample($value: ColorTokenNormalized['$value'], culoriColor: Color, depth: Depth = 30) {\n  if (!($value.colorSpace in CSS_TO_CULORI)) {\n    throw new Error(\n      `Invalid colorSpace \"${$value.colorSpace}\". Expected one of: ${Object.keys(CSS_TO_CULORI).join(', ')}`,\n    );\n  }\n  const conversionSpace = CSS_TO_CULORI[$value.colorSpace] || 'oklab';\n  let gamutSpace = conversionSpace;\n  // bugfix. \"lab\" and \"oklab\" have a bug in Culori\n  // https://github.com/Evercoder/culori/issues/261\n  if (gamutSpace === 'lab' || gamutSpace === 'lab65') {\n    gamutSpace = 'lch';\n  } else if (gamutSpace === 'oklab') {\n    gamutSpace = 'oklch';\n  }\n  let srgb = converters[conversionSpace](toGamut('rgb', gamutSpace)(culoriColor));\n  let p3 = converters[conversionSpace](toGamut('p3', gamutSpace)(culoriColor));\n  let rec2020 = converters[conversionSpace](toGamut('rec2020', gamutSpace)(culoriColor));\n  if (typeof depth === 'number') {\n    if (!DEPTH_ROUNDING[depth]) {\n      throw new Error(`Invalid bit depth: ${depth}. Supported values: ${Object.keys(DEPTH_ROUNDING).join(', ')}`);\n    }\n    srgb = roundColor(srgb, depth);\n    p3 = roundColor(p3, depth);\n    rec2020 = roundColor(rec2020, depth);\n  }\n  return {\n    '.': formatCss(culoriColor),\n    srgb: formatCss(srgb),\n    p3: formatCss(p3),\n    rec2020: formatCss(rec2020),\n  };\n}\n\n/** Round color to certain depth. */\nexport function roundColor<T extends Color = Color>(color: T, depth: Depth = 30): T {\n  if (depth === 'unlimited') {\n    return color;\n  }\n  const newColor = { ...color };\n  for (const [k, v] of Object.entries(color)) {\n    if (typeof v !== 'number' || k === 'mode') {\n      continue;\n    }\n    newColor[k as keyof T] = DEPTH_ROUNDING[depth](v) as T[keyof T];\n  }\n  return newColor;\n}\n","import type { DimensionTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert dimension value to CSS */\nexport function transformDimension(token: DimensionTokenNormalized, options: TransformCSSValueOptions): string {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n\n  return token.$value.value === 0 ? '0' : `${token.$value.value}${token.$value.unit}`;\n}\n","import type { StrokeStyleTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert strokeStyle value to CSS */\nexport function transformStrokeStyle(token: StrokeStyleTokenNormalized, options: TransformCSSValueOptions): string {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n  return typeof token.$value === 'string' ? token.$value : 'dashed'; // CSS doesn’t have `dash-array`; it’s just \"dashed\"\n}\n","import { displayable } from 'culori';\nimport type {\n  BorderTokenNormalized,\n  ColorTokenNormalized,\n  DimensionTokenNormalized,\n  StrokeStyleTokenNormalized,\n} from '../types.js';\nimport { transformColor } from './color.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { transformDimension } from './dimension.js';\nimport { defaultAliasTransform } from './lib.js';\nimport { transformStrokeStyle } from './stroke-style.js';\n\n/** Convert border value to multiple CSS values */\nexport function transformBorder(token: BorderTokenNormalized, options: TransformCSSValueOptions) {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n\n  const width = token.partialAliasOf?.width\n    ? transformAlias(tokensSet[token.partialAliasOf.width]!)\n    : transformDimension({ $value: token.$value.width } as DimensionTokenNormalized, options);\n  const color = token.partialAliasOf?.color\n    ? transformAlias(tokensSet[token.partialAliasOf.color]!)\n    : transformColor({ $value: token.$value.color } as ColorTokenNormalized, options);\n  const style = token.partialAliasOf?.style\n    ? transformAlias(tokensSet[token.partialAliasOf.style]!)\n    : transformStrokeStyle({ $value: token.$value.style } as StrokeStyleTokenNormalized, options);\n\n  const formatBorder = (colorKey: string) =>\n    [width, style, typeof color === 'string' ? color : color[colorKey as keyof typeof color]].join(' ');\n\n  return typeof color === 'string' || displayable(color.p3)\n    ? formatBorder('.')\n    : {\n        '.': formatBorder('.'),\n        srgb: formatBorder('srgb'),\n        p3: formatBorder('p3'),\n        rec2020: formatBorder('rec2020'),\n      };\n}\n","import type { CubicBezierTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert cubicBezier value to CSS */\nexport function transformCubicBezier(token: CubicBezierTokenNormalized, options: TransformCSSValueOptions): string {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n  return `cubic-bezier(${token.$value\n    .map((v, i) => (token.partialAliasOf?.[i] ? transformAlias(tokensSet[token.partialAliasOf[i]]!) : v))\n    .join(', ')})`;\n}\n","import type { DurationTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert duration value to CSS */\nexport function transformDuration(token: DurationTokenNormalized, options: TransformCSSValueOptions): string {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n\n  return `${token.$value.value}${token.$value.unit}`;\n}\n","import type { FontFamilyTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\nconst FONT_NAME_KEYWORD = /^[a-z-]+$/;\n\nexport function transformFontFamily(token: FontFamilyTokenNormalized, options: TransformCSSValueOptions): string {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n  return token.$value.map((fontName) => (FONT_NAME_KEYWORD.test(fontName) ? fontName : `\"${fontName}\"`)).join(', ');\n}\n","import type { FontWeightTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert fontWeight value to CSS */\nexport function transformFontWeight(token: FontWeightTokenNormalized, options: TransformCSSValueOptions): string {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n  return String(token.$value);\n}\n","import type { ColorTokenNormalized, GradientTokenNormalized } from '../types.js';\nimport { transformColor, type WideGamutColorValue } from './color.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert gradient value to CSS */\nexport function transformGradient(\n  token: GradientTokenNormalized,\n  options: TransformCSSValueOptions,\n): string | WideGamutColorValue {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n\n  let isHDR = false;\n\n  const colors: (string | WideGamutColorValue)[] = [];\n  const positions: string[] = [];\n\n  for (let i = 0; i < token.$value.length; i++) {\n    const { color, position } = token.$value[i]!;\n    const colorValue = token.partialAliasOf?.[i]?.color\n      ? transformAlias(tokensSet[token.partialAliasOf[i]!.color!]!)\n      : transformColor({ $value: color } as ColorTokenNormalized, options);\n    if (typeof colorValue !== 'string') {\n      isHDR = true;\n    }\n    colors.push(colorValue);\n    positions.push(\n      token.partialAliasOf?.[i]?.position\n        ? transformAlias(tokensSet[token.partialAliasOf[i]!.position!]!)\n        : `${100 * position}%`,\n    );\n  }\n\n  function formatStop(i: number, colorKey = '.') {\n    return `${typeof colors[i] === 'string' ? colors[i] : colors[i]![colorKey as keyof (typeof colors)[number]]} ${positions[i]}`;\n  }\n\n  return !isHDR\n    ? token.$value.map((_, i) => formatStop(i, positions[i]!)).join(', ')\n    : {\n        '.': token.$value.map((_, i) => formatStop(i, '.')).join(', '),\n        srgb: token.$value.map((_, i) => formatStop(i, 'srgb')).join(', '),\n        p3: token.$value.map((_, i) => formatStop(i, 'p3')).join(', '),\n        rec2020: token.$value.map((_, i) => formatStop(i, 'rec2020')).join(', '),\n      };\n}\n","import type { LinkTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert link value to CSS */\nexport function transformLink(token: LinkTokenNormalized, options: TransformCSSValueOptions): string {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n  return `url(\"${token.$value}\")`;\n}\n","import type { NumberTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert number value to CSS */\nexport function transformNumber(token: NumberTokenNormalized, options: TransformCSSValueOptions): string {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n  return String(token.$value);\n}\n","import type {\n  ColorTokenNormalized,\n  DimensionTokenNormalized,\n  ShadowTokenNormalized,\n  ShadowValueNormalized,\n} from '../types.js';\nimport { transformColor } from './color.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { transformDimension } from './dimension.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert shadow subvalue to CSS */\nexport function transformShadowLayer(\n  value: ShadowValueNormalized,\n  options: TransformCSSValueOptions & {\n    colorValue: string;\n    partialAliasOf?: Partial<Record<keyof typeof value, string>>;\n  },\n): string | Record<string, string> {\n  const { tokensSet, colorValue, partialAliasOf, transformAlias = defaultAliasTransform } = options;\n  const offsetX = partialAliasOf?.offsetX\n    ? transformAlias(tokensSet[partialAliasOf.offsetX]!)\n    : transformDimension({ $value: value.offsetX } as DimensionTokenNormalized, options);\n  const offsetY = partialAliasOf?.offsetY\n    ? transformAlias(tokensSet[partialAliasOf.offsetY]!)\n    : transformDimension({ $value: value.offsetY } as DimensionTokenNormalized, options);\n  const blur = partialAliasOf?.blur\n    ? transformAlias(tokensSet[partialAliasOf.blur]!)\n    : transformDimension({ $value: value.blur } as DimensionTokenNormalized, options);\n  const spread = partialAliasOf?.spread\n    ? transformAlias(tokensSet[partialAliasOf.spread]!)\n    : transformDimension({ $value: value.spread } as DimensionTokenNormalized, options);\n  const inset = value?.inset === true ? 'inset' : undefined;\n\n  return [inset, offsetX, offsetY, blur, spread, colorValue].filter(Boolean).join(' ');\n}\n\n/** Convert shadow value to CSS */\nexport function transformShadow(\n  token: ShadowTokenNormalized,\n  options: TransformCSSValueOptions,\n): string | Record<string, string> {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n  const colors = token.$value.map((v, i) =>\n    token.partialAliasOf?.[i]?.color\n      ? transformAlias(tokensSet[token.partialAliasOf[i]!.color!]!)\n      : transformColor({ $value: v.color } as ColorTokenNormalized, options),\n  );\n  const isHDR = colors.some((c) => typeof c === 'object');\n\n  const formatShadow = (colorKey: string) =>\n    token.$value\n      .map((v, i) =>\n        transformShadowLayer(v, {\n          tokensSet,\n          colorValue:\n            typeof colors[i] === 'string'\n              ? (colors[i] as string)\n              : colors[i]![colorKey as keyof (typeof colors)[number]]!,\n          partialAliasOf: token.partialAliasOf?.[i],\n          transformAlias,\n        }),\n      )\n      .join(', ');\n\n  return !isHDR\n    ? formatShadow('.')\n    : {\n        '.': formatShadow('.'),\n        srgb: formatShadow('srgb'),\n        p3: formatShadow('p3'),\n        rec2020: formatShadow('rec2020'),\n      };\n}\n","import type { StringTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert string value to CSS */\nexport function transformString(token: StringTokenNormalized, options: TransformCSSValueOptions): string {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n  // this seems like a useless function—because it is—but this is a placeholder\n  // that can handle unexpected values in the future should any arise\n  return String(token.$value);\n}\n","import type { CubicBezierTokenNormalized, DurationTokenNormalized, TransitionTokenNormalized } from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { transformCubicBezier } from './cubic-bezier.js';\nimport { transformDuration } from './duration.js';\nimport { defaultAliasTransform } from './lib.js';\n\n/** Convert transition value to shorthand */\nexport function transformTransition(token: TransitionTokenNormalized, options: TransformCSSValueOptions) {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  if (token.aliasChain?.[0]) {\n    return transformAlias(tokensSet[token.aliasChain[0]]!);\n  }\n\n  const duration = token.partialAliasOf?.duration\n    ? transformAlias(tokensSet[token.partialAliasOf.duration]!)\n    : transformDuration({ $value: token.$value.duration } as DurationTokenNormalized, options);\n  const delay = token.partialAliasOf?.delay\n    ? transformAlias(tokensSet[token.partialAliasOf.delay]!)\n    : transformDuration({ $value: token.$value.delay } as DurationTokenNormalized, options);\n  const timingFunction = token.partialAliasOf?.timingFunction\n    ? transformAlias(tokensSet[token.partialAliasOf.timingFunction]!)\n    : transformCubicBezier({ $value: token.$value.timingFunction } as CubicBezierTokenNormalized, options);\n\n  return `${duration} ${delay} ${timingFunction}`;\n}\n","import { kebabCase } from '../string.js';\nimport type {\n  DimensionTokenNormalized,\n  FontFamilyTokenNormalized,\n  FontWeightTokenNormalized,\n  NumberTokenNormalized,\n  StringTokenNormalized,\n  TokenNormalized,\n  TypographyTokenNormalized,\n} from '../types.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { transformDimension } from './dimension.js';\nimport { transformFontFamily } from './font-family.js';\nimport { transformFontWeight } from './font-weight.js';\nimport { defaultAliasTransform } from './lib.js';\nimport { transformNumber } from './number.js';\nimport { transformString } from './string.js';\n\n/** Convert typography value to multiple CSS values */\nexport function transformTypography(token: TypographyTokenNormalized, options: TransformCSSValueOptions) {\n  const { tokensSet, transformAlias = defaultAliasTransform } = options;\n  const output: Record<string, string> = {};\n  for (const [property, subvalue] of Object.entries(token.$value)) {\n    let transformedValue: string;\n    const aliasedID = token.aliasChain?.[0] ?? token.partialAliasOf?.[property];\n    if (aliasedID) {\n      const resolvedToken = tokensSet[aliasedID] as TypographyTokenNormalized;\n      transformedValue = transformAlias(\n        // if resolving against a typography token, inject the property as well\n        resolvedToken.$type === 'typography' ? ({ id: `${aliasedID}-${property}` } as TokenNormalized) : resolvedToken,\n      );\n    } else {\n      switch (property) {\n        case 'fontFamily': {\n          transformedValue = transformFontFamily({ $value: subvalue } as FontFamilyTokenNormalized, options);\n          break;\n        }\n        case 'fontSize':\n        case 'letterSpacing': {\n          transformedValue = transformDimension({ $value: subvalue } as DimensionTokenNormalized, options);\n          break;\n        }\n        case 'fontWeight': {\n          transformedValue = transformFontWeight({ $value: subvalue } as FontWeightTokenNormalized, options);\n          break;\n        }\n        case 'lineHeight': {\n          if (typeof subvalue === 'number') {\n            transformedValue = transformNumber({ $value: subvalue } as NumberTokenNormalized, options);\n          } else {\n            transformedValue = transformDimension({ $value: subvalue } as DimensionTokenNormalized, options);\n          }\n          break;\n        }\n        default: {\n          transformedValue = transformString({ $value: subvalue } as StringTokenNormalized, options);\n          break;\n        }\n      }\n    }\n    output[kebabCase(property)] = transformedValue;\n  }\n  return output;\n}\n","import type { TokenNormalized } from '../types.js';\nimport { transformBoolean } from './boolean.js';\nimport { transformBorder } from './border.js';\nimport { transformColor } from './color.js';\nimport type { TransformCSSValueOptions } from './css-types.js';\nimport { transformCubicBezier } from './cubic-bezier.js';\nimport { transformDimension } from './dimension.js';\nimport { transformDuration } from './duration.js';\nimport { transformFontFamily } from './font-family.js';\nimport { transformFontWeight } from './font-weight.js';\nimport { transformGradient } from './gradient.js';\nimport { transformLink } from './link.js';\nimport { transformNumber } from './number.js';\nimport { transformShadow } from './shadow.js';\nimport { transformString } from './string.js';\nimport { transformStrokeStyle } from './stroke-style.js';\nimport { transformTransition } from './transition.js';\nimport { transformTypography } from './typography.js';\n\nexport * from './boolean.js';\nexport * from './border.js';\nexport * from './color.js';\nexport * from './cubic-bezier.js';\nexport * from './dimension.js';\nexport * from './duration.js';\nexport * from './font-family.js';\nexport * from './font-weight.js';\nexport * from './gradient.js';\nexport * from './lib.js';\nexport * from './link.js';\nexport * from './number.js';\nexport * from './shadow.js';\nexport * from './string.js';\nexport * from './stroke-style.js';\nexport * from './transition.js';\nexport * from './typography.js';\n\n/** Main CSS Transform */\nexport function transformCSSValue<T extends TokenNormalized = TokenNormalized>(\n  token: T,\n  { mode, ...options }: { mode: keyof T['mode'] } & TransformCSSValueOptions,\n) {\n  const selectedMode = token.mode[mode as keyof typeof token.mode];\n  if (!selectedMode) {\n    return;\n  }\n  const tokenWithModeValue: T = {\n    id: token.id,\n    $type: token.$type,\n    // note: do NOT carry over aliasOf/partialAliasOf as that will result in incorrect values\n    ...selectedMode,\n  } as any;\n  switch (tokenWithModeValue.$type) {\n    case 'boolean': {\n      return transformBoolean(tokenWithModeValue, options);\n    }\n    case 'border': {\n      return transformBorder(tokenWithModeValue, options);\n    }\n    case 'color': {\n      return transformColor(tokenWithModeValue, options);\n    }\n    case 'cubicBezier': {\n      return transformCubicBezier(tokenWithModeValue, options);\n    }\n    case 'dimension': {\n      return transformDimension(tokenWithModeValue, options);\n    }\n    case 'duration': {\n      return transformDuration(tokenWithModeValue, options);\n    }\n    case 'fontFamily': {\n      return transformFontFamily(tokenWithModeValue, options);\n    }\n    case 'fontWeight': {\n      return transformFontWeight(tokenWithModeValue, options);\n    }\n    case 'gradient': {\n      return transformGradient(tokenWithModeValue, options);\n    }\n    case 'link': {\n      return transformLink(tokenWithModeValue, options);\n    }\n    case 'number': {\n      return transformNumber(tokenWithModeValue, options);\n    }\n    case 'shadow': {\n      return transformShadow(tokenWithModeValue, options);\n    }\n    case 'string': {\n      return transformString(tokenWithModeValue, options);\n    }\n    case 'strokeStyle': {\n      return transformStrokeStyle(tokenWithModeValue, options);\n    }\n    case 'transition': {\n      return transformTransition(tokenWithModeValue, options);\n    }\n    case 'typography': {\n      return transformTypography(tokenWithModeValue, options);\n    }\n  }\n}\n"],"mappings":"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"}