{"version":3,"file":"index.js","names":["TYPE_MAP: Record<Token['$type'], string>","output: string[]","tokenVals: Record<string, Record<string, string>>","options?: JSPluginOptions","transformedValue"],"sources":["../../token-tools/dist/js.js","../src/lib.ts","../src/build.ts","../src/index.ts"],"sourcesContent":["//#region src/js/index.ts\n/**\n* Convert token value to a JS string via acorn/astring.\n*/\nfunction transformJSValue(token, { mode, indent = 2, startingIndent = 0 }) {\n\tif (!(mode in token.mode)) return;\n\tconst indentStart = startingIndent > 0 ? \" \".repeat(startingIndent ?? 2) : \"\";\n\treturn JSON.stringify(token.mode[mode].$value, void 0, indent).replace(/\\n/g, `\\n${indentStart}`);\n}\n\n//#endregion\nexport { transformJSValue };\n//# sourceMappingURL=js.js.map","import type { Token, TokenNormalized, TokenTransformed } from '@terrazzo/parser';\n\nexport const FORMAT_JS_ID = 'js';\nexport const FORMAT_DTS_ID = 'd.ts';\n\nexport interface JSPluginOptions {\n  /**\n   * Output JS?\n   * @default true\n   */\n  js?: boolean | string;\n  /** Output JSON?\n   * @default false\n   */\n  json?: boolean | string;\n  /** Exclude token IDs from output? */\n  exclude?: string[];\n  /**\n   * Return deeply-nested values?\n   * @default: false\n   */\n  deep?: boolean;\n  /** Override certain token values */\n  transform?: (token: TokenNormalized, mode: string) => TokenTransformed['value'];\n}\n\nexport const FILE_HEADER = `/** ------------------------------------------\n *  Autogenerated by â›‹ Terrazzo. DO NOT EDIT!\n * ------------------------------------------- */`;\n\nexport const TYPE_MAP: Record<Token['$type'], string> = {\n  boolean: 'BooleanTokenNormalized',\n  border: 'BorderTokenNormalized',\n  color: 'ColorTokenNormalized',\n  cubicBezier: 'CubicBezierTokenNormalized',\n  dimension: 'DimensionTokenNormalized',\n  duration: 'DurationTokenNormalized',\n  fontFamily: 'FontFamilyTokenNormalized',\n  fontWeight: 'FontWeightTokenNormalized',\n  gradient: 'GradientTokenNormalized',\n  link: 'LinkTokenNormalized',\n  number: 'NumberTokenNormalized',\n  shadow: 'ShadowTokenNormalized',\n  string: 'StringTokenNormalized',\n  strokeStyle: 'StrokeStyleTokenNormalized',\n  typography: 'TypographyTokenNormalized',\n  transition: 'TransitionTokenNormalized',\n};\n","import type { BuildHookOptions } from '@terrazzo/parser';\nimport { FILE_HEADER, FORMAT_DTS_ID, FORMAT_JS_ID, TYPE_MAP } from './lib.js';\n\nexport function buildJS({ getTransforms }: { getTransforms: BuildHookOptions['getTransforms'] }): string {\n  const output: string[] = [FILE_HEADER, ''];\n\n  // gather vals\n  const tokenVals: Record<string, Record<string, string>> = {};\n  for (const token of getTransforms({ format: FORMAT_JS_ID, id: '*' })) {\n    if (!tokenVals[token.token.id]) {\n      tokenVals[token.token.id] = {};\n    }\n    tokenVals[token.token.id]![token.mode] = token.value as string;\n  }\n\n  // body\n  output.push('export const tokens = {');\n  for (const [id, tokenValue] of Object.entries(tokenVals)) {\n    output.push(`  \"${id}\": {`);\n    for (const [mode, modeValue] of Object.entries(tokenValue)) {\n      output.push(`    \"${mode}\": ${modeValue},`);\n    }\n    output.push('  },');\n  }\n  output.push('};', '');\n\n  // footer\n  output.push(\n    `/** Get individual token */\nexport function token(tokenID, modeName = \".\") {\n  return tokens[tokenID]?.[modeName];\n}`,\n    '',\n  );\n\n  return output.join('\\n');\n}\n\nexport function buildDTS({ getTransforms }: { getTransforms: BuildHookOptions['getTransforms'] }): string {\n  const output: string[] = [FILE_HEADER, ''];\n\n  const importDeps = new Set<string>();\n  const types = getTransforms({ format: FORMAT_DTS_ID, id: '*', mode: '.' }).map((t) => {\n    importDeps.add(TYPE_MAP[t.token.$type]); // collect only necessary types\n    if (t.type === 'MULTI_VALUE') {\n      const description = t.value.description ? `  /** ${t.value.description} */\\n` : '';\n      return `${description}  \"${t.token.id}\": ${t.value.value};`;\n    }\n    return `\"${t.token.id}\": ${t.value};`;\n  });\n\n  output.push(\n    'import type {',\n    ...[...importDeps].sort((a, b) => a.localeCompare(b)).map((dep) => `  ${dep},`),\n    '} from \"@terrazzo/parser\";',\n    '',\n    'export declare const tokens: {',\n    ...types,\n    '};',\n    '',\n    `export declare function token<K extends keyof typeof tokens>(tokenID: K, modeName?: never): (typeof tokens)[K][\".\"];\nexport declare function token<K extends keyof typeof tokens, M extends keyof (typeof tokens)[K]>(tokenID: K, modeName: M): (typeof tokens)[K][M];`,\n    '',\n  );\n\n  return output.join('\\n');\n}\n","import type { Plugin } from '@terrazzo/parser';\nimport { transformJSValue } from '@terrazzo/token-tools/js';\nimport { buildDTS, buildJS } from './build.js';\nimport { FORMAT_DTS_ID, FORMAT_JS_ID, type JSPluginOptions, TYPE_MAP } from './lib.js';\n\nexport * from './build.js';\nexport * from './lib.js';\n\nexport default function pluginJS(options?: JSPluginOptions): Plugin {\n  const customTransform = options?.transform;\n\n  return {\n    name: '@terrazzo/plugin-js',\n    async transform({ tokens, getTransforms, setTransform }) {\n      // skip work if another .js plugin has already run\n      const jsTokens = getTransforms({ format: FORMAT_JS_ID, id: '*', mode: '.' });\n      if (jsTokens.length) {\n        return;\n      }\n\n      for (const [id, token] of Object.entries(tokens)) {\n        // .d.ts (only default \".\" mode needed)\n        setTransform(id, {\n          format: FORMAT_DTS_ID,\n          value: {\n            description: token.$description!,\n            value: `Record<\"${Object.keys(token.mode).join('\" | \"')}\", ${TYPE_MAP[token.$type]}[\"$value\"]>`,\n          },\n          mode: '.',\n        });\n\n        // .js (all modes)\n        for (const mode of Object.keys(token.mode)) {\n          if (customTransform) {\n            const transformedValue = customTransform(token, mode);\n            if (transformedValue !== undefined && transformedValue !== null) {\n              setTransform(id, { format: FORMAT_JS_ID, value: transformedValue, mode });\n              continue;\n            }\n          }\n          const transformedValue = transformJSValue(token, { mode, startingIndent: 4 });\n          if (transformedValue !== undefined) {\n            setTransform(id, { format: FORMAT_JS_ID, value: transformedValue, mode });\n          }\n        }\n      }\n    },\n    async build({ getTransforms, outputFile }) {\n      // if (options?.json) {\n      //   const contents = buildJSON({ getTransforms });\n      //   outputFile(typeof options?.json === 'string' ? options.json : 'index.json', contents);\n      // }\n      if (options?.js) {\n        const js = buildJS({ getTransforms });\n        const jsFilename = typeof options?.js === 'string' ? options.js : 'index.js';\n        outputFile(jsFilename, js);\n\n        const dts = buildDTS({ getTransforms });\n        const dtsFilename = typeof options?.js === 'string' ? options.js.replace(/\\.js$/, '.d.ts') : 'index.d.ts';\n        outputFile(dtsFilename, dts);\n      }\n    },\n  };\n}\n"],"mappings":"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"}